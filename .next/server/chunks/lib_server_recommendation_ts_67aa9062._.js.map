{"version":3,"sources":["turbopack:///[project]/lib/server/recommendation.ts","turbopack:///[project]/lib/server/time-utils.ts","turbopack:///[project]/lib/server/googleMaps.ts"],"sourcesContent":["import type { SupabaseClient } from \"@supabase/supabase-js\";\nimport { distanceKm, estimateETA } from \"./geo-utils\";\nimport {\n  bucketLabel as bucketLabelForDate,\n  isWithinSameBucket,\n  truncateTo30MinBucket,\n} from \"./time-utils\";\nimport { getTrafficMatrix, type TrafficMatrixEntry } from \"./googleMaps\";\n\nconst DEFAULT_MAX_DISTANCE_KM = 12;\nconst SUCCESS_LOOKBACK_DAYS = 14;\nconst DEFAULT_FARE_INR = 180;\nconst SCORE_WEIGHTS = {\n  success: 0.4,\n  fare: 0.3,\n  eta: 0.2,\n  traffic: 0.1,\n} as const;\nconst TRAFFIC_REUSE_DISTANCE_METERS = 200;\nconst TRAFFIC_REUSE_INTERVAL_MS = 45_000;\n\nexport type RecommendationSignals = {\n  traffic_speed_idx?: number | null;\n  route_incident?: boolean | null;\n  airport_wave?: number | null;\n  weather_flag_rain?: boolean | null;\n  event_flag?: boolean | null;\n};\n\nexport type RecommendationContextSnapshot = RecommendationSignals & {\n  driver_id: string;\n  snapped_zone: number | null;\n  bucket_start: string;\n  bucket_label: string;\n  traffic_source?: \"google\" | \"cache\" | \"fallback\";\n  reason?: string;\n};\n\nexport type ZoneRecommendation = {\n  zone_id: number;\n  zone_name: string;\n  lat: number;\n  lon: number;\n  distance_km: number;\n  eta_min: number;\n  score: number;\n  success_prob: number;\n  expected_fare_inr: number;\n  normalized_fare: number;\n  traffic_penalty: number;\n  traffic_speed_idx: number | null;\n  reason: string;\n};\n\nexport type RecommendationResult = {\n  computed_at: string;\n  context: RecommendationContextSnapshot;\n  top: ZoneRecommendation[];\n  traffic_source: \"google\" | \"cache\" | \"fallback\";\n};\n\nexport interface ComputeNextZonesParams {\n  supabase: SupabaseClient;\n  driverId: string;\n  currentLoc: { lat: number; lon: number };\n  snappedZoneId?: number | null;\n  context?: RecommendationSignals;\n  now?: Date | string;\n  currentSpeedKmh?: number | null;\n  k?: number;\n}\n\ntype GeoPoint = {\n  type?: string;\n  coordinates?: [number, number];\n  crs?: { type: string; properties: Record<string, any> };\n};\n\ntype ZoneRow = {\n  id: number;\n  slug?: string | null;\n  name: string | null;\n  lat?: number | null;\n  lon?: number | null;\n  center?: GeoPoint | string | null;\n  geom?: GeoPoint | string | null;\n  radius_km?: number | null;\n  weight_demand?: number | null;\n  weight_airport?: number | null;\n  is_active?: boolean | null;\n  created_at?: string | null;\n};\n\ntype CandidateZone = {\n  zone: ZoneRow & { lat: number; lon: number; name: string };\n  distanceKm: number;\n};\n\ntype CandidateFetchResult = {\n  candidates: CandidateZone[];\n  totalZones: number;\n  zonesWithCoordinates: number;\n};\n\ntype TrainingRow = {\n  zone_id: number;\n  bucket_30m?: string | null;\n  label_ride_15m?: boolean | number | null;\n  success_prob?: number | null;\n  sample_size?: number | null;\n  created_at?: string | null;\n};\n\ntype TripRow = {\n  pickup_zone: number | null;\n  fare_inr: number | null;\n  completed_at?: string | null;\n};\n\ntype SuccessStats = Map<number, { prob: number; samples: number }>;\ntype FareStats = Map<number, { sum: number; count: number }>;\n\ntype TrafficSnapshotEntry = {\n  zoneId: number;\n  distanceMeters: number | null;\n  durationSeconds: number | null;\n  durationInTrafficSeconds: number | null;\n  trafficSpeedIdx: number | null;\n  status: string;\n};\n\ntype TrafficSnapshot = {\n  entries: Map<number, TrafficSnapshotEntry>;\n  source: \"google\" | \"cache\" | \"fallback\";\n  fetchedAt: number;\n};\n\ntype DriverTrafficCacheEntry = {\n  destKey: string;\n  origin: { lat: number; lon: number };\n  snapshot: TrafficSnapshot;\n};\n\nconst driverTrafficCache = new Map<string, DriverTrafficCacheEntry>();\n\n/**\n * Compute the top-k next zones for a driver by blending success probability,\n * fare expectations, travel time, and traffic signals.\n * This is the single entry point for recommendation logic so it can later\n * be swapped with a learning system / bandit without touching route handlers.\n */\nexport async function computeNextZonesForDriver(\n  params: ComputeNextZonesParams\n): Promise<RecommendationResult> {\n  const {\n    supabase,\n    driverId,\n    currentLoc,\n    snappedZoneId = null,\n    k = 3,\n    context,\n    now,\n    currentSpeedKmh,\n  } = params;\n\n  const computedAt =\n    typeof now === \"string\" ? new Date(now) : now ? now : new Date();\n\n  const bucketStart = truncateTo30MinBucket(computedAt);\n  const bucketIso = bucketStart.toISOString();\n  const bucketLabel = bucketLabelForDate(bucketStart);\n\n  const normalizedContext = normalizeContext(context);\n\n  const candidateFetch = await fetchCandidateZones(supabase, currentLoc);\n  const candidates = candidateFetch.candidates;\n  \n  console.log(\"[recommendations] candidate fetch result\", {\n    driverId,\n    currentLoc,\n    totalZones: candidateFetch.totalZones,\n    zonesWithCoordinates: candidateFetch.zonesWithCoordinates,\n    candidateCount: candidates.length,\n  });\n\n  if (candidates.length === 0) {\n    const reason =\n      candidateFetch.totalZones === 0\n        ? \"no_zones_in_db\"\n        : candidateFetch.zonesWithCoordinates === 0\n        ? \"no_zones_with_coords\"\n        : \"zones_too_far\";\n\n    console.warn(\"[recommendations] No candidates available\", {\n      driverId,\n      reason,\n      totalZones: candidateFetch.totalZones,\n      zonesWithCoordinates: candidateFetch.zonesWithCoordinates,\n      currentLoc,\n    });\n\n    return {\n      computed_at: computedAt.toISOString(),\n      context: {\n        ...normalizedContext,\n        driver_id: driverId,\n        snapped_zone: snappedZoneId,\n        bucket_start: bucketIso,\n        bucket_label: bucketLabel,\n        traffic_source: \"fallback\",\n        reason,\n      },\n      top: [],\n      traffic_source: \"fallback\",\n    };\n  }\n\n  const zoneIds = candidates.map((c) => c.zone.id);\n  const [successStats, fareStats, trafficSnapshot] = await Promise.all([\n    loadTrainingSuccess(supabase, zoneIds, bucketStart, driverId),\n    loadExpectedFare(supabase, zoneIds, bucketStart, driverId),\n    resolveTrafficSnapshot({\n      driverId,\n      origin: currentLoc,\n      candidates,\n      departure: computedAt,\n      currentSpeedKmh: currentSpeedKmh ?? null,\n    }),\n  ]);\n\n  const fallbackFare = resolveFallbackFare(fareStats);\n\n  let trafficSpeedSum = 0;\n  let trafficSpeedSamples = 0;\n\n  const zoneWithStats = candidates.map((candidate) => {\n    const zoneId = candidate.zone.id;\n    const successEntry = successStats.get(zoneId);\n    const successProb = successEntry ? successEntry.prob : 0.35;\n\n    const fareEntry = fareStats.get(zoneId);\n    const expectedFare =\n      fareEntry && fareEntry.count > 0\n        ? fareEntry.sum / fareEntry.count\n        : fallbackFare;\n\n    const trafficEntry = trafficSnapshot.entries.get(zoneId);\n    const fallbackDistanceMeters = candidate.distanceKm * 1000;\n    const distanceMeters =\n      trafficEntry?.distanceMeters && trafficEntry.distanceMeters > 0\n        ? trafficEntry.distanceMeters\n        : fallbackDistanceMeters;\n    const distanceKm = Number((distanceMeters / 1000).toFixed(2));\n    const etaSeconds =\n      trafficEntry?.durationInTrafficSeconds && trafficEntry.durationInTrafficSeconds > 0\n        ? trafficEntry.durationInTrafficSeconds\n        : estimateETA(fallbackDistanceMeters, currentSpeedKmh) * 60;\n    const etaMin = Number((etaSeconds / 60).toFixed(1));\n    const trafficSpeedIdx =\n      typeof trafficEntry?.trafficSpeedIdx === \"number\"\n        ? trafficEntry.trafficSpeedIdx\n        : null;\n\n    if (typeof trafficSpeedIdx === \"number\") {\n      trafficSpeedSum += trafficSpeedIdx;\n      trafficSpeedSamples += 1;\n    }\n\n    return {\n      zoneId,\n      zoneName: candidate.zone.name,\n      lat: candidate.zone.lat,\n      lon: candidate.zone.lon,\n      distanceKm,\n      etaMin,\n      successProb,\n      expectedFare,\n      trafficSpeedIdx,\n    };\n  });\n\n  const maxFare = zoneWithStats.reduce(\n    (max, zone) => Math.max(max, zone.expectedFare),\n    fallbackFare\n  );\n\n  const scored = zoneWithStats.map((stat) => {\n    const normalizedFare =\n      maxFare > 0 ? Number((stat.expectedFare / maxFare).toFixed(3)) : 0;\n    const etaPenalty = Math.min(stat.etaMin / 30, 1);\n    const trafficPenalty = computeZoneTrafficPenalty(stat.trafficSpeedIdx, normalizedContext);\n    const rawScore =\n      SCORE_WEIGHTS.success * stat.successProb +\n      SCORE_WEIGHTS.fare * normalizedFare -\n      SCORE_WEIGHTS.eta * etaPenalty -\n      SCORE_WEIGHTS.traffic * trafficPenalty;\n    const score = clamp(rawScore, 0, 1);\n\n    const reason = buildReason(\n      stat,\n      normalizedFare,\n      stat.trafficSpeedIdx,\n      normalizedContext\n    );\n\n    return {\n      zone_id: stat.zoneId,\n      zone_name: stat.zoneName,\n      lat: stat.lat,\n      lon: stat.lon,\n      distance_km: stat.distanceKm,\n      eta_min: stat.etaMin,\n      score: Number(score.toFixed(3)),\n      success_prob: Number(stat.successProb.toFixed(3)),\n      expected_fare_inr: Math.round(stat.expectedFare),\n      normalized_fare: normalizedFare,\n      traffic_penalty: Number(trafficPenalty.toFixed(2)),\n      traffic_speed_idx:\n        typeof stat.trafficSpeedIdx === \"number\"\n          ? Number(stat.trafficSpeedIdx.toFixed(2))\n          : null,\n      reason,\n    } as ZoneRecommendation;\n  });\n\n  scored.sort((a, b) => b.score - a.score);\n\n  const trafficSpeedIdx =\n    trafficSpeedSamples > 0\n      ? Number((trafficSpeedSum / trafficSpeedSamples).toFixed(2))\n      : normalizedContext.traffic_speed_idx ?? null;\n\n  let trafficSource: RecommendationResult[\"traffic_source\"] = trafficSnapshot.source;\n  let topRecommendations = scored.slice(0, Math.max(1, k));\n\n  // CRITICAL: Always ensure we return nearest zones when candidates exist\n  if (topRecommendations.length === 0 && candidates.length > 0) {\n    console.warn(\"[recommendations] scored list empty, falling back to nearest zones\", {\n      driverId,\n      candidateCount: candidates.length,\n      currentLoc,\n    });\n    topRecommendations = buildFallbackRecommendations(candidates, k, currentSpeedKmh ?? null);\n    trafficSource = \"fallback\";\n  }\n\n  // Additional safety: if topRecommendations is still empty but candidates exist, force nearest-by-distance\n  if (topRecommendations.length === 0 && candidates.length > 0) {\n    console.error(\"[recommendations] CRITICAL: topRecommendations empty despite candidates\", {\n      driverId,\n      candidateCount: candidates.length,\n      scoredCount: scored.length,\n      currentLoc,\n    });\n    const emergency = [...candidates]\n      .sort((a, b) => a.distanceKm - b.distanceKm)\n      .slice(0, Math.max(1, k));\n    topRecommendations = emergency.map((c) => ({\n      zone_id: c.zone.id,\n      zone_name: c.zone.name,\n      lat: c.zone.lat,\n      lon: c.zone.lon,\n      distance_km: Number(c.distanceKm.toFixed(2)),\n      eta_min: Number(estimateETA(c.distanceKm * 1000, currentSpeedKmh ?? undefined).toFixed(1)),\n      score: 0.5,\n      success_prob: 0.35,\n      expected_fare_inr: DEFAULT_FARE_INR,\n      normalized_fare: 0.5,\n      traffic_penalty: 0,\n      traffic_speed_idx: null,\n      reason: \"Emergency fallback: nearest by distance\",\n    }));\n    trafficSource = \"fallback\";\n  }\n\n  const contextSnapshot: RecommendationContextSnapshot = {\n    ...normalizedContext,\n    traffic_speed_idx: trafficSpeedIdx,\n    driver_id: driverId,\n    snapped_zone: snappedZoneId,\n    bucket_start: bucketIso,\n    bucket_label: bucketLabel,\n    traffic_source: trafficSource,\n  };\n\n  return {\n    computed_at: computedAt.toISOString(),\n    context: contextSnapshot,\n    top: topRecommendations,\n    traffic_source: trafficSource,\n  };\n}\n\nasync function fetchCandidateZones(\n  supabase: SupabaseClient,\n  currentLoc: { lat: number; lon: number }\n): Promise<CandidateFetchResult> {\n  const { data, error } = await supabase\n    .from(\"zones\")\n    .select(\"id,name,lat,lon,center,radius_km,weight_demand,weight_airport,is_active\")\n    .eq(\"is_active\", true)\n    .limit(200);\n\n  if (error || !data) {\n    console.error(\"[recommendations] zone fetch failed\", {\n      error,\n    });\n    return { candidates: [], totalZones: 0, zonesWithCoordinates: 0 };\n  }\n\n  const rows = data as ZoneRow[];\n  const totalZones = rows.length;\n  if (totalZones === 0) {\n    console.warn(\"[recommendations] No zones found in DB when building candidates\");\n    return { candidates: [], totalZones: 0, zonesWithCoordinates: 0 };\n  }\n\n  const activeRows = rows.filter((row) => row.is_active !== false);\n  const prioritizedRows = activeRows.length > 0 ? activeRows : rows;\n  const hardCap = 25;\n\n  const defaultCollection = collectCandidateZones(\n    prioritizedRows,\n    currentLoc,\n    DEFAULT_MAX_DISTANCE_KM * 1.5\n  );\n\n  let candidates = defaultCollection.candidates;\n  let zonesWithCoordinates = defaultCollection.totalResolved;\n\n  if (candidates.length === 0 && zonesWithCoordinates > 0) {\n    const relaxedRadius = DEFAULT_MAX_DISTANCE_KM * 3;\n    const relaxed = collectCandidateZones(prioritizedRows, currentLoc, relaxedRadius);\n    if (relaxed.candidates.length > 0) {\n      console.warn(\"[recommendations] No zones within default radius, using relaxed fallback\", {\n        totalZones,\n        relaxedRadiusKm: relaxedRadius,\n      });\n      candidates = relaxed.candidates;\n      zonesWithCoordinates = relaxed.totalResolved;\n    } else {\n      console.warn(\n        \"[recommendations] No zones within relaxed radius, defaulting to all zones sorted by distance\",\n        { totalZones, resolvedZones: zonesWithCoordinates }\n      );\n      const allCandidates = collectCandidateZones(prioritizedRows, currentLoc);\n      candidates = allCandidates.candidates;\n      zonesWithCoordinates = allCandidates.totalResolved;\n    }\n  } else if (candidates.length === 0 && zonesWithCoordinates === 0) {\n    console.warn(\"[recommendations] Zones exist but none contain usable coordinates\", {\n      totalZones,\n    });\n  }\n\n  return {\n    candidates: candidates.slice(0, hardCap),\n    totalZones,\n    zonesWithCoordinates,\n  };\n}\n\nfunction collectCandidateZones(\n  rows: ZoneRow[],\n  currentLoc: { lat: number; lon: number },\n  maxDistanceKm?: number\n): { candidates: CandidateZone[]; totalResolved: number } {\n  const resolved: CandidateZone[] = [];\n  for (const row of rows) {\n    const coords = resolveZoneCoordinates(row);\n    if (!coords) continue;\n    const distance = distanceKm(currentLoc.lat, currentLoc.lon, coords.lat, coords.lon);\n    resolved.push({\n      zone: {\n        ...row,\n        name: normalizeZoneName(row),\n        lat: coords.lat,\n        lon: coords.lon,\n      },\n      distanceKm: distance,\n    });\n  }\n\n  resolved.sort((a, b) => a.distanceKm - b.distanceKm);\n  const filtered =\n    typeof maxDistanceKm === \"number\"\n      ? resolved.filter((candidate) => candidate.distanceKm <= maxDistanceKm)\n      : resolved;\n\n  return {\n    candidates: filtered,\n    totalResolved: resolved.length,\n  };\n}\n\nfunction normalizeZoneName(row: ZoneRow): string {\n  if (row.name && row.name.trim().length > 0) {\n    return row.name.trim();\n  }\n  if (row.slug && row.slug.trim().length > 0) {\n    return row.slug.replace(/_/g, \" \").trim();\n  }\n  return `Zone ${row.id}`;\n}\n\nfunction resolveZoneCoordinates(row: ZoneRow): { lat: number; lon: number } | null {\n  const lat = toFiniteNumber(row.lat);\n  const lon = toFiniteNumber(row.lon);\n  if (lat !== null && lon !== null) {\n    return { lat, lon };\n  }\n\n  const fromCenter = parseGeometryValue(row.center);\n  if (fromCenter) return fromCenter;\n\n  const fromGeom = parseGeometryValue(row.geom);\n  if (fromGeom) return fromGeom;\n\n  return null;\n}\n\nfunction toFiniteNumber(value: unknown): number | null {\n  if (typeof value === \"number\" && Number.isFinite(value)) {\n    return value;\n  }\n  if (typeof value === \"string\") {\n    const parsed = Number(value);\n    if (Number.isFinite(parsed)) {\n      return parsed;\n    }\n  }\n  return null;\n}\n\nfunction parseGeometryValue(\n  value: GeoPoint | string | null | undefined\n): { lat: number; lon: number } | null {\n  if (!value) return null;\n\n  if (typeof value === \"string\") {\n    const trimmed = value.trim();\n    if (!trimmed) return null;\n    if (trimmed.startsWith(\"{\") || trimmed.startsWith(\"[\")) {\n      try {\n        const parsed = JSON.parse(trimmed);\n        return parseGeometryValue(parsed as GeoPoint);\n      } catch {\n        // fall through to WKT parsing\n      }\n    }\n    return parseWktPoint(trimmed);\n  }\n\n  const anyValue = value as Record<string, any>;\n  if (Array.isArray(anyValue.coordinates) && anyValue.coordinates.length >= 2) {\n    const [lon, lat] = anyValue.coordinates;\n    const latNum = toFiniteNumber(lat);\n    const lonNum = toFiniteNumber(lon);\n    if (latNum !== null && lonNum !== null) {\n      return { lat: latNum, lon: lonNum };\n    }\n  }\n\n  const fallbackLat = toFiniteNumber(anyValue.lat ?? anyValue.latitude);\n  const fallbackLon = toFiniteNumber(anyValue.lon ?? anyValue.lng ?? anyValue.longitude);\n  if (fallbackLat !== null && fallbackLon !== null) {\n    return { lat: fallbackLat, lon: fallbackLon };\n  }\n\n  return null;\n}\n\nfunction parseWktPoint(value: string): { lat: number; lon: number } | null {\n  const normalized = value.includes(\";\") ? value.split(\";\").pop()!.trim() : value.trim();\n  const match = normalized.match(/POINT\\s*\\(([^)]+)\\)/i);\n  if (!match) return null;\n  const [maybeLon, maybeLat] = match[1].trim().split(/\\s+/);\n  const lon = Number(maybeLon);\n  const lat = Number(maybeLat);\n  if (Number.isFinite(lat) && Number.isFinite(lon)) {\n    return { lat, lon };\n  }\n  return null;\n}\n\nfunction buildFallbackRecommendations(\n  candidates: CandidateZone[],\n  k: number,\n  currentSpeedKmh: number | null\n): ZoneRecommendation[] {\n  const limit = Math.max(1, k);\n  const fallbackZones = [...candidates].sort((a, b) => a.distanceKm - b.distanceKm).slice(0, limit);\n  return fallbackZones.map((candidate) => {\n    const distanceKm = Number(candidate.distanceKm.toFixed(2));\n    const etaMinutes = estimateETA(candidate.distanceKm * 1000, currentSpeedKmh ?? undefined);\n    const normalizedDistance = clamp(distanceKm / (DEFAULT_MAX_DISTANCE_KM * 2), 0, 1);\n    const demandWeight =\n      typeof candidate.zone.weight_demand === \"number\" && candidate.zone.weight_demand > 0\n        ? clamp(candidate.zone.weight_demand, 0.5, 2)\n        : 1;\n    const airportWeight =\n      typeof candidate.zone.weight_airport === \"number\"\n        ? clamp(candidate.zone.weight_airport, 0, 2)\n        : 0;\n    const baseScore = 1 - normalizedDistance;\n    const weightedScore = clamp(baseScore * demandWeight + airportWeight * 0.05, 0, 1);\n    const successProb = clamp(0.35 * demandWeight, 0.2, 0.95);\n    return {\n      zone_id: candidate.zone.id,\n      zone_name: candidate.zone.name,\n      lat: candidate.zone.lat,\n      lon: candidate.zone.lon,\n      distance_km: distanceKm,\n      eta_min: Number(etaMinutes.toFixed(1)),\n      score: Number(weightedScore.toFixed(3)),\n      success_prob: Number(successProb.toFixed(3)),\n      expected_fare_inr: DEFAULT_FARE_INR,\n      normalized_fare: clamp(0.5 * demandWeight, 0, 1),\n      traffic_penalty: 0.2,\n      traffic_speed_idx: null,\n      reason: \"Nearest zones by distance (fallback)\",\n    };\n  });\n}\n\nasync function loadTrainingSuccess(\n  supabase: SupabaseClient,\n  zoneIds: number[],\n  bucketStart: Date,\n  driverId: string\n): Promise<SuccessStats> {\n  const stats: SuccessStats = new Map();\n  if (zoneIds.length === 0) return stats;\n\n  const lookback = new Date(bucketStart);\n  lookback.setDate(lookback.getDate() - SUCCESS_LOOKBACK_DAYS);\n\n  const { data, error } = await supabase\n    .from(\"training_examples\")\n    .select(\"zone_id,label_ride_15m,success_prob,sample_size,bucket_30m,created_at\")\n    .in(\"zone_id\", zoneIds)\n    .gte(\"created_at\", lookback.toISOString());\n\n  if (error || !data) {\n    console.error(\"[recommendations] training fetch failed\", {\n      driverId,\n      error,\n    });\n    return stats;\n  }\n\n  for (const row of data as TrainingRow[]) {\n    const zoneId = row.zone_id;\n    const rowBucket = row.bucket_30m ?? row.created_at ?? bucketStart.toISOString();\n    if (!isWithinSameBucket(rowBucket, bucketStart)) continue;\n\n    const entry = stats.get(zoneId) ?? { prob: 0, samples: 0 };\n    const sampleSize =\n      typeof row.sample_size === \"number\" && row.sample_size > 0 ? row.sample_size : 1;\n    const labelValue =\n      typeof row.success_prob === \"number\" && sampleSize > 1\n        ? clamp(row.success_prob, 0, 1) * sampleSize\n        : normalizeLabel(row);\n\n    entry.prob += labelValue;\n    entry.samples += sampleSize;\n    stats.set(zoneId, entry);\n  }\n\n  for (const [zoneId, entry] of stats.entries()) {\n    const smoothed = smoothProbability(entry.prob, entry.samples);\n    stats.set(zoneId, { prob: smoothed, samples: entry.samples });\n  }\n\n  return stats;\n}\n\nasync function loadExpectedFare(\n  supabase: SupabaseClient,\n  zoneIds: number[],\n  bucketStart: Date,\n  driverId: string\n): Promise<FareStats> {\n  const stats: FareStats = new Map();\n  if (zoneIds.length === 0) return stats;\n\n  const lookback = new Date(bucketStart);\n  lookback.setDate(lookback.getDate() - SUCCESS_LOOKBACK_DAYS);\n\n  const { data, error } = await supabase\n    .from(\"trips\")\n    .select(\"pickup_zone,fare_inr,completed_at\")\n    .in(\"pickup_zone\", zoneIds)\n    .gte(\"completed_at\", lookback.toISOString());\n\n  if (error || !data) {\n    console.error(\"[recommendations] trip fare fetch failed\", {\n      driverId,\n      error,\n    });\n    return stats;\n  }\n\n  for (const row of data as TripRow[]) {\n    if (!row.pickup_zone) continue;\n    const completedAt = row.completed_at;\n    if (!completedAt || !isWithinSameBucket(completedAt, bucketStart)) continue;\n    if (typeof row.fare_inr !== \"number\" || row.fare_inr <= 0) continue;\n\n    const entry = stats.get(row.pickup_zone) ?? { sum: 0, count: 0 };\n    entry.sum += row.fare_inr;\n    entry.count += 1;\n    stats.set(row.pickup_zone, entry);\n  }\n\n  return stats;\n}\n\nfunction normalizeContext(\n  context?: RecommendationSignals\n): RecommendationSignals {\n  return {\n    traffic_speed_idx:\n      typeof context?.traffic_speed_idx === \"number\"\n        ? clamp(context.traffic_speed_idx, 0, 1)\n        : null,\n    route_incident: Boolean(context?.route_incident),\n    airport_wave:\n      typeof context?.airport_wave === \"number\"\n        ? clamp(context.airport_wave, 0, 1)\n        : null,\n    weather_flag_rain: Boolean(context?.weather_flag_rain),\n    event_flag: Boolean(context?.event_flag),\n  };\n}\n\nfunction computeZoneTrafficPenalty(\n  trafficSpeedIdx: number | null,\n  context: RecommendationSignals\n): number {\n  const effectiveIdx =\n    typeof trafficSpeedIdx === \"number\"\n      ? clamp(trafficSpeedIdx, 0, 1)\n      : typeof context.traffic_speed_idx === \"number\"\n        ? clamp(context.traffic_speed_idx, 0, 1)\n        : null;\n  const speedPenalty = effectiveIdx !== null ? 1 - effectiveIdx : 0.2;\n  const incidentPenalty = context.route_incident ? 0.5 : 0;\n  const weatherPenalty = context.weather_flag_rain ? 0.3 : 0;\n\n  return clamp(speedPenalty + incidentPenalty + weatherPenalty, 0, 1);\n}\n\nfunction buildReason(\n  stat: {\n    zoneId: number;\n    zoneName: string;\n    distanceKm: number;\n    etaMin: number;\n    successProb: number;\n    expectedFare: number;\n  },\n  normalizedFare: number,\n  trafficSpeedIdx: number | null,\n  context: RecommendationSignals\n): string {\n  const reasons: string[] = [];\n\n  if (stat.successProb >= 0.65) {\n    reasons.push(\"High hit rate\");\n  } else if (stat.successProb >= 0.5) {\n    reasons.push(\"Steady bookings\");\n  }\n\n  if (normalizedFare >= 0.7) {\n    reasons.push(\"Premium fares\");\n  } else if (stat.expectedFare >= DEFAULT_FARE_INR + 40) {\n    reasons.push(\"Above avg fare\");\n  }\n\n  if (stat.distanceKm <= 2) {\n    reasons.push(\"Very close\");\n  } else if (stat.distanceKm <= 5) {\n    reasons.push(\"Nearby\");\n  }\n\n  if (typeof trafficSpeedIdx === \"number\") {\n    if (trafficSpeedIdx >= 0.8) {\n      reasons.push(\"Traffic flowing\");\n    } else if (trafficSpeedIdx < 0.5) {\n      reasons.push(\"Heavy traffic\");\n    }\n  }\n\n  if (context.airport_wave && /airport/i.test(stat.zoneName)) {\n    reasons.push(\"Airport arrivals\");\n  }\n  if (context.event_flag) {\n    reasons.push(\"Event demand\");\n  }\n\n  if (reasons.length === 0) {\n    reasons.push(\"Balanced demand vs travel time\");\n  }\n\n  return reasons.slice(0, 3).join(\"; \");\n}\n\nasync function resolveTrafficSnapshot(opts: {\n  driverId: string;\n  origin: { lat: number; lon: number };\n  candidates: CandidateZone[];\n  departure: Date;\n  currentSpeedKmh: number | null;\n}): Promise<TrafficSnapshot> {\n  const destKey = opts.candidates.map((c) => c.zone.id).sort((a, b) => a - b).join(\",\");\n  const cached = driverTrafficCache.get(opts.driverId);\n  if (cached && cached.destKey === destKey) {\n    const movedMeters =\n      distanceKm(\n        opts.origin.lat,\n        opts.origin.lon,\n        cached.origin.lat,\n        cached.origin.lon\n      ) * 1000;\n    const ageMs = Date.now() - cached.snapshot.fetchedAt;\n    if (movedMeters < TRAFFIC_REUSE_DISTANCE_METERS && ageMs < TRAFFIC_REUSE_INTERVAL_MS) {\n      return {\n        entries: new Map(cached.snapshot.entries),\n        source: cached.snapshot.source === \"google\" ? \"cache\" : cached.snapshot.source,\n        fetchedAt: cached.snapshot.fetchedAt,\n      };\n    }\n  }\n\n  const destinations = opts.candidates.map((candidate) => ({\n    zoneId: candidate.zone.id,\n    lat: candidate.zone.lat,\n    lon: candidate.zone.lon,\n  }));\n\n  try {\n    const matrix = await getTrafficMatrix({\n      origin: opts.origin,\n      destinations,\n      departureTime: opts.departure,\n    });\n    const snapshot = buildTrafficSnapshotFromMatrix(matrix);\n    driverTrafficCache.set(opts.driverId, {\n      destKey,\n      origin: opts.origin,\n      snapshot,\n    });\n    return snapshot;\n  } catch (error) {\n    console.warn(\"[recommendations] traffic matrix failed, using fallback\", {\n      driverId: opts.driverId,\n      error,\n    });\n    const fallback = buildFallbackTrafficSnapshot(opts.candidates, opts.currentSpeedKmh);\n    driverTrafficCache.set(opts.driverId, {\n      destKey,\n      origin: opts.origin,\n      snapshot: fallback,\n    });\n    return fallback;\n  }\n}\n\nfunction buildTrafficSnapshotFromMatrix(entries: TrafficMatrixEntry[]): TrafficSnapshot {\n  const map = new Map<number, TrafficSnapshotEntry>();\n  for (const entry of entries) {\n    map.set(entry.zoneId, {\n      zoneId: entry.zoneId,\n      distanceMeters: entry.distanceMeters,\n      durationSeconds: entry.durationSeconds,\n      durationInTrafficSeconds: entry.durationInTrafficSeconds,\n      trafficSpeedIdx: computeSpeedIndex(entry),\n      status: entry.status,\n    });\n  }\n\n  return {\n    entries: map,\n    source: \"google\",\n    fetchedAt: Date.now(),\n  };\n}\n\nfunction buildFallbackTrafficSnapshot(\n  candidates: CandidateZone[],\n  currentSpeedKmh: number | null\n): TrafficSnapshot {\n  const map = new Map<number, TrafficSnapshotEntry>();\n  for (const candidate of candidates) {\n    const distanceMeters = candidate.distanceKm * 1000;\n    const etaSeconds = estimateETA(distanceMeters, currentSpeedKmh) * 60;\n    map.set(candidate.zone.id, {\n      zoneId: candidate.zone.id,\n      distanceMeters,\n      durationSeconds: etaSeconds,\n      durationInTrafficSeconds: etaSeconds,\n      trafficSpeedIdx: null,\n      status: \"FALLBACK\",\n    });\n  }\n\n  return {\n    entries: map,\n    source: \"fallback\",\n    fetchedAt: Date.now(),\n  };\n}\n\nfunction computeSpeedIndex(entry: TrafficMatrixEntry): number | null {\n  if (\n    !entry.durationSeconds ||\n    !entry.durationInTrafficSeconds ||\n    entry.durationSeconds <= 0 ||\n    entry.durationInTrafficSeconds <= 0\n  ) {\n    return null;\n  }\n  const ratio = entry.durationSeconds / entry.durationInTrafficSeconds;\n  return clamp(ratio, 0, 1);\n}\n\nfunction clamp(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(max, value));\n}\n\nfunction normalizeLabel(row: TrainingRow): number {\n  if (typeof row.success_prob === \"number\") {\n    return row.success_prob;\n  }\n  if (typeof row.label_ride_15m === \"number\") {\n    return clamp(row.label_ride_15m, 0, 1);\n  }\n  if (typeof row.label_ride_15m === \"boolean\") {\n    return row.label_ride_15m ? 1 : 0;\n  }\n  return 0;\n}\n\nfunction smoothProbability(successSum: number, samples: number): number {\n  return (successSum + 1) / (samples + 2);\n}\n\nfunction resolveFallbackFare(stats: FareStats): number {\n  if (stats.size === 0) return DEFAULT_FARE_INR;\n  let sum = 0;\n  let count = 0;\n  for (const entry of stats.values()) {\n    sum += entry.sum;\n    count += entry.count;\n  }\n  if (count === 0) return DEFAULT_FARE_INR;\n  return sum / count;\n}\n","/**\n * Time-bucketing helpers shared across server modules.\n * Buckets are 30-minute windows aligned to the top :00 or :30 minute.\n */\nexport function truncateTo30MinBucket(date: Date): Date {\n  const bucket = new Date(date);\n  bucket.setSeconds(0, 0);\n  const minutes = bucket.getMinutes();\n  bucket.setMinutes(minutes < 30 ? 0 : 30);\n  return bucket;\n}\n\nexport function bucketLabel(date: Date): string {\n  const hours = String(date.getHours()).padStart(2, \"0\");\n  const minutes = date.getMinutes() === 0 ? \"00\" : \"30\";\n  return `${hours}:${minutes}`;\n}\n\nexport function isWithinSameBucket(\n  candidate: string | Date,\n  bucketStart: Date\n): boolean {\n  const candidateDate =\n    typeof candidate === \"string\" ? new Date(candidate) : candidate;\n  return (\n    truncateTo30MinBucket(candidateDate).getTime() === bucketStart.getTime()\n  );\n}\n","const DISTANCE_MATRIX_URL = \"https://maps.googleapis.com/maps/api/distancematrix/json\";\nconst MAX_DESTINATIONS_PER_REQUEST = 25;\nconst CACHE_COORD_PRECISION = 3; // ~100m grid\nconst CACHE_TTL_MS = 60_000;\n\nexport type TrafficMatrixDestination = {\n  zoneId: number;\n  lat: number;\n  lon: number;\n};\n\nexport type TrafficMatrixEntry = {\n  zoneId: number;\n  distanceMeters: number | null;\n  durationSeconds: number | null;\n  durationInTrafficSeconds: number | null;\n  status: string;\n};\n\ntype CacheEntry = {\n  expiresAt: number;\n  data: TrafficMatrixEntry[];\n};\n\nconst responseCache = new Map<string, CacheEntry>();\n\nexport interface TrafficMatrixParams {\n  origin: { lat: number; lon: number };\n  destinations: TrafficMatrixDestination[];\n  departureTime?: Date;\n}\n\nexport async function getTrafficMatrix(\n  params: TrafficMatrixParams\n): Promise<TrafficMatrixEntry[]> {\n  if (params.destinations.length === 0) {\n    return [];\n  }\n\n  const apiKey = process.env.GOOGLE_MAPS_API_KEY;\n  if (!apiKey) {\n    throw new Error(\"Missing GOOGLE_MAPS_API_KEY environment variable\");\n  }\n\n  const departure = params.departureTime ?? new Date();\n  const departureEpoch = Math.floor(departure.getTime() / 1000);\n  const cacheKey = buildCacheKey(params.origin, params.destinations, departureEpoch);\n  const cached = responseCache.get(cacheKey);\n  if (cached && cached.expiresAt > Date.now()) {\n    return cached.data;\n  }\n\n  const entries: TrafficMatrixEntry[] = [];\n  const destinationChunks = chunkDestinations(params.destinations, MAX_DESTINATIONS_PER_REQUEST);\n\n  for (const chunk of destinationChunks) {\n    const url = new URL(DISTANCE_MATRIX_URL);\n    url.searchParams.set(\"origins\", formatLatLon(params.origin.lat, params.origin.lon));\n    url.searchParams.set(\"destinations\", chunk.map((dest) => formatLatLon(dest.lat, dest.lon)).join(\"|\"));\n    url.searchParams.set(\"departure_time\", departureEpoch.toString());\n    url.searchParams.set(\"traffic_model\", \"best_guess\");\n    url.searchParams.set(\"units\", \"metric\");\n    url.searchParams.set(\"key\", apiKey);\n\n    const res = await fetch(url.toString(), {\n      method: \"GET\",\n      cache: \"no-store\",\n    });\n\n    if (!res.ok) {\n      throw new Error(`Google Maps Distance Matrix HTTP ${res.status}`);\n    }\n\n    const payload = (await res.json()) as any;\n    if (payload.status !== \"OK\") {\n      throw new Error(\n        `Google Maps Distance Matrix error: ${payload.status}${\n          payload.error_message ? ` (${payload.error_message})` : \"\"\n        }`\n      );\n    }\n\n    const row = payload.rows?.[0];\n    if (!row || !Array.isArray(row.elements)) {\n      throw new Error(\"Google Maps Distance Matrix returned no rows\");\n    }\n\n    row.elements.forEach((element: any, idx: number) => {\n      const dest = chunk[idx];\n      entries.push({\n        zoneId: dest.zoneId,\n        distanceMeters: sanitizeNumber(element.distance?.value),\n        durationSeconds: sanitizeNumber(element.duration?.value),\n        durationInTrafficSeconds: sanitizeNumber(element.duration_in_traffic?.value),\n        status: element.status ?? \"UNKNOWN\",\n      });\n    });\n  }\n\n  responseCache.set(cacheKey, {\n    expiresAt: Date.now() + CACHE_TTL_MS,\n    data: entries,\n  });\n\n  return entries;\n}\n\nfunction sanitizeNumber(value: unknown): number | null {\n  return typeof value === \"number\" && Number.isFinite(value) ? value : null;\n}\n\nfunction formatLatLon(lat: number, lon: number) {\n  return `${lat},${lon}`;\n}\n\nfunction chunkDestinations<T>(input: T[], size: number): T[][] {\n  const chunks: T[][] = [];\n  for (let i = 0; i < input.length; i += size) {\n    chunks.push(input.slice(i, i + size));\n  }\n  return chunks;\n}\n\nfunction buildCacheKey(\n  origin: { lat: number; lon: number },\n  destinations: TrafficMatrixDestination[],\n  departureEpoch: number\n) {\n  const originKey = `${origin.lat.toFixed(CACHE_COORD_PRECISION)},${origin.lon.toFixed(\n    CACHE_COORD_PRECISION\n  )}`;\n  const destKey = destinations\n    .map(\n      (dest) =>\n        `${dest.zoneId}:${dest.lat.toFixed(CACHE_COORD_PRECISION)},${dest.lon.toFixed(\n          CACHE_COORD_PRECISION\n        )}`\n    )\n    .sort()\n    .join(\"|\");\n  const timeBucket = Math.floor(departureEpoch / 60); // 1-minute buckets\n  return `${originKey}|${destKey}|${timeBucket}`;\n}\n"],"names":[],"mappings":"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"}