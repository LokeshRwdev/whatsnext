(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/ieee754/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8){}
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8){}
    if (e === 0) {
        e = 1 - eBias;
    } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) {
            value += rt / c;
        } else {
            value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8){}
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8){}
    buffer[offset + i - d] |= s * 128;
};
}),
"[project]/node_modules/base64-js/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4');
    }
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join('');
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength){
        parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    }
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
    }
    return parts.join('');
}
}),
"[project]/node_modules/buffer/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ const base64 = __turbopack_context__.r("[project]/node_modules/base64-js/index.js [app-client] (ecmascript)");
const ieee754 = __turbopack_context__.r("[project]/node_modules/ieee754/index.js [app-client] (ecmascript)");
const customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
const K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
}
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        const arr = new Uint8Array(1);
        const proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
            throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192; // not used by this implementation
function from(value, encodingOrOffset, length) {
    if (typeof value === 'string') {
        return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
    }
    if (value == null) {
        throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === 'number') {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
        return Buffer.from(valueOf, encodingOrOffset, length);
    }
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
        return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
    }
    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
        return createBuffer(size);
    }
    if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpreted as a start offset.
        return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
    }
    if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        buf = buf.slice(0, actual);
    }
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1){
        buf[i] = array[i] & 255;
    }
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === undefined && length === undefined) {
        buf = new Uint8Array(array);
    } else if (length === undefined) {
        buf = new Uint8Array(array, byteOffset);
    } else {
        buf = new Uint8Array(array, byteOffset, length);
    }
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
            return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
            return createBuffer(0);
        }
        return fromArrayLike(obj);
    }
    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
    }
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
    }
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) {
        length = 0;
    }
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i){
        if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
        }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
        return Buffer.alloc(0);
    }
    let i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i){
            length += list[i].length;
        }
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(i = 0; i < list.length; ++i){
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                buf.copy(buffer, pos);
            } else {
                Uint8Array.prototype.set.call(buffer, buf, pos);
            }
        } else if (!Buffer.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
            buf.copy(buffer, pos);
        }
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) {
        return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
    }
    if (typeof string !== 'string') {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + typeof string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    let loweredCase = false;
    for(;;){
        switch(encoding){
            case 'ascii':
            case 'latin1':
            case 'binary':
                return len;
            case 'utf8':
            case 'utf-8':
                return utf8ToBytes(string).length;
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
                return len * 2;
            case 'hex':
                return len >>> 1;
            case 'base64':
                return base64ToBytes(string).length;
            default:
                if (loweredCase) {
                    return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
                    ;
                }
                encoding = ('' + encoding).toLowerCase();
                loweredCase = true;
        }
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    let loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
        start = 0;
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
        return '';
    }
    if (end === undefined || end > this.length) {
        end = this.length;
    }
    if (end <= 0) {
        return '';
    }
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
        return '';
    }
    if (!encoding) encoding = 'utf8';
    while(true){
        switch(encoding){
            case 'hex':
                return hexSlice(this, start, end);
            case 'utf8':
            case 'utf-8':
                return utf8Slice(this, start, end);
            case 'ascii':
                return asciiSlice(this, start, end);
            case 'latin1':
            case 'binary':
                return latin1Slice(this, start, end);
            case 'base64':
                return base64Slice(this, start, end);
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
                return utf16leSlice(this, start, end);
            default:
                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                encoding = (encoding + '').toLowerCase();
                loweredCase = true;
        }
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits');
    }
    for(let i = 0; i < len; i += 2){
        swap(this, i, i + 1);
    }
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits');
    }
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits');
    }
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = '';
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max) str += ' ... ';
    return '<Buffer ' + str + '>';
};
if (customInspectSymbol) {
    Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
}
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength);
    }
    if (!Buffer.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + typeof target);
    }
    if (start === undefined) {
        start = 0;
    }
    if (end === undefined) {
        end = target ? target.length : 0;
    }
    if (thisStart === undefined) {
        thisStart = 0;
    }
    if (thisEnd === undefined) {
        thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index');
    }
    if (thisStart >= thisEnd && start >= end) {
        return 0;
    }
    if (thisStart >= thisEnd) {
        return -1;
    }
    if (start >= end) {
        return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i){
        if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
        }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset; // Coerce to Number.
    if (numberIsNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : buffer.length - 1;
    }
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === 'string') {
        val = Buffer.from(val, encoding);
    }
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
            return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
        val = val & 0xFF; // Search for a byte value [0-255]
        if (typeof Uint8Array.prototype.indexOf === 'function') {
            if (dir) {
                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
            if (arr.length < 2 || val.length < 2) {
                return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) {
            return buf[i];
        } else {
            return buf.readUInt16BE(i * indexSize);
        }
    }
    let i;
    if (dir) {
        let foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++){
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                if (foundIndex === -1) foundIndex = i;
                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
            } else {
                if (foundIndex !== -1) i -= i - foundIndex;
                foundIndex = -1;
            }
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            let found = true;
            for(let j = 0; j < valLength; j++){
                if (read(arr, i + j) !== read(val, j)) {
                    found = false;
                    break;
                }
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
        length = remaining;
    } else {
        length = Number(length);
        if (length > remaining) {
            length = remaining;
        }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
        length = strLen / 2;
    }
    let i;
    for(i = 0; i < length; ++i){
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = 'utf8';
        } else {
            encoding = length;
            length = undefined;
        }
    } else {
        throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    }
    const remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds');
    }
    if (!encoding) encoding = 'utf8';
    let loweredCase = false;
    for(;;){
        switch(encoding){
            case 'hex':
                return hexWrite(this, string, offset, length);
            case 'utf8':
            case 'utf-8':
                return utf8Write(this, string, offset, length);
            case 'ascii':
            case 'latin1':
            case 'binary':
                return asciiWrite(this, string, offset, length);
            case 'base64':
                // Warning: maxLength not taken into account in base64Write
                return base64Write(this, string, offset, length);
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
                return ucs2Write(this, string, offset, length);
            default:
                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                encoding = ('' + encoding).toLowerCase();
                loweredCase = true;
        }
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
    } else {
        return base64.fromByteArray(buf.slice(start, end));
    }
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) {
                        codePoint = firstByte;
                    }
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                            codePoint = tempCodePoint;
                        }
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
        ;
    }
    // Decode in chunks to avoid "call stack size exceeded".
    let res = '';
    let i = 0;
    while(i < len){
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
}
function asciiSlice(buf, start, end) {
    let ret = '';
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i){
        ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret;
}
function latin1Slice(buf, start, end) {
    let ret = '';
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i){
        ret += String.fromCharCode(buf[i]);
    }
    return ret;
}
function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = '';
    for(let i = start; i < end; ++i){
        out += hexSliceLookupTable[buf[i]];
    }
    return out;
}
function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = '';
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(let i = 0; i < bytes.length - 1; i += 2){
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) {
        start = len;
    }
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) {
        end = len;
    }
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100)){
        val += this[offset + i] * mul;
    }
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
    }
    let val = this[offset + --byteLength];
    let mul = 1;
    while(byteLength > 0 && (mul *= 0x100)){
        val += this[offset + --byteLength] * mul;
    }
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100)){
        val += this[offset + i] * mul;
    }
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let i = byteLength;
    let mul = 1;
    let val = this[offset + --i];
    while(i > 0 && (mul *= 0x100)){
        val += this[offset + --i] * mul;
    }
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24) // Overflow
    ;
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        this[offset + i] = value / mul & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let i = byteLength - 1;
    let mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        this[offset + i] = value / mul & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = byteLength - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds');
    }
    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
        // Use built-in when available, missing from IE11
        this.copyWithin(targetStart, start, end);
    } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
        if (typeof start === 'string') {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === 'string') {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
            throw new TypeError('encoding must be a string');
        }
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
            throw new TypeError('Unknown encoding: ' + encoding);
        }
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
                // Fast path: If `val` fits into a single byte, use that numeric value.
                val = code;
            }
        }
    } else if (typeof val === 'number') {
        val = val & 255;
    } else if (typeof val === 'boolean') {
        val = Number(val);
    }
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index');
    }
    if (end <= start) {
        return this;
    }
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === 'number') {
        for(i = start; i < end; ++i){
            this[i] = val;
        }
    } else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for(i = 0; i < end - start; ++i){
            this[i + start] = bytes[i % len];
        }
    }
    return this;
};
// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
const errors = {};
function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
        constructor(){
            super();
            Object.defineProperty(this, 'message', {
                value: getMessage.apply(this, arguments),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            this.name = `${this.name} [${sym}]`;
            // Access the stack to generate the error message including the error code
            // from the name.
            this.stack; // eslint-disable-line no-unused-expressions
            // Reset the name to the actual name.
            delete this.name;
        }
        get code() {
            return sym;
        }
        set code(value) {
            Object.defineProperty(this, 'code', {
                configurable: true,
                enumerable: true,
                value,
                writable: true
            });
        }
        toString() {
            return `${this.name} [${sym}]: ${this.message}`;
        }
    };
}
E('ERR_BUFFER_OUT_OF_BOUNDS', function(name) {
    if (name) {
        return `${name} is outside of buffer bounds`;
    }
    return 'Attempt to access memory outside buffer bounds';
}, RangeError);
E('ERR_INVALID_ARG_TYPE', function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
E('ERR_OUT_OF_RANGE', function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
    } else if (typeof input === 'bigint') {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
        }
        received += 'n';
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
}, RangeError);
function addNumericalSeparator(val) {
    let res = '';
    let i = val.length;
    const start = val[0] === '-' ? 1 : 0;
    for(; i >= start + 4; i -= 3){
        res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
}
// CHECK FUNCTIONS
// ===============
function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, 'offset');
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
        boundsError(offset, buf.length - (byteLength + 1));
    }
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === 'bigint' ? 'n' : '';
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === BigInt(0)) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE('value', range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function validateNumber(value, name) {
    if (typeof value !== 'number') {
        throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
    }
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
    }
    if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', `>= ${type ? 1 : 0} and <= ${length}`, value);
}
// HELPER FUNCTIONS
// ================
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0){
        str = str + '=';
    }
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
            // valid bmp char, but last char was a lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else {
            throw new Error('Invalid code point');
        }
    }
    return bytes;
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray;
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    let i;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = function() {
    const alphabet = '0123456789abcdef';
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j){
            table[i16 + j] = alphabet[i] + alphabet[j];
        }
    }
    return table;
}();
// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
    return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error('BigInt not supported');
}
}),
"[project]/node_modules/safe-buffer/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ /* eslint-disable node/no-deprecated-api */ var buffer = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
var Buffer = buffer.Buffer;
// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
    for(var key in src){
        dst[key] = src[key];
    }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    module.exports = buffer;
} else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
}
function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
}
SafeBuffer.prototype = Object.create(Buffer.prototype);
// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);
SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
        throw new TypeError('Argument must not be a number');
    }
    return Buffer(arg, encodingOrOffset, length);
};
SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
    }
    var buf = Buffer(size);
    if (fill !== undefined) {
        if (typeof encoding === 'string') {
            buf.fill(fill, encoding);
        } else {
            buf.fill(fill);
        }
    } else {
        buf.fill(0);
    }
    return buf;
};
SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
    }
    return Buffer(size);
};
SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
    }
    return buffer.SlowBuffer(size);
};
}),
"[project]/node_modules/isarray/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

var toString = {}.toString;
module.exports = Array.isArray || function(arr) {
    return toString.call(arr) == '[object Array]';
};
}),
"[project]/node_modules/es-errors/type.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./type')} */ module.exports = TypeError;
}),
"[project]/node_modules/es-errors/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ module.exports = Error;
}),
"[project]/node_modules/es-errors/eval.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./eval')} */ module.exports = EvalError;
}),
"[project]/node_modules/es-errors/range.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./range')} */ module.exports = RangeError;
}),
"[project]/node_modules/es-errors/ref.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./ref')} */ module.exports = ReferenceError;
}),
"[project]/node_modules/es-errors/syntax.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./syntax')} */ module.exports = SyntaxError;
}),
"[project]/node_modules/es-errors/uri.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./uri')} */ module.exports = URIError;
}),
"[project]/node_modules/es-object-atoms/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ module.exports = Object;
}),
"[project]/node_modules/math-intrinsics/abs.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./abs')} */ module.exports = Math.abs;
}),
"[project]/node_modules/math-intrinsics/floor.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./floor')} */ module.exports = Math.floor;
}),
"[project]/node_modules/math-intrinsics/max.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./max')} */ module.exports = Math.max;
}),
"[project]/node_modules/math-intrinsics/min.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./min')} */ module.exports = Math.min;
}),
"[project]/node_modules/math-intrinsics/pow.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./pow')} */ module.exports = Math.pow;
}),
"[project]/node_modules/math-intrinsics/round.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./round')} */ module.exports = Math.round;
}),
"[project]/node_modules/math-intrinsics/isNaN.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./isNaN')} */ module.exports = Number.isNaN || function isNaN(a) {
    return a !== a;
};
}),
"[project]/node_modules/math-intrinsics/sign.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $isNaN = __turbopack_context__.r("[project]/node_modules/math-intrinsics/isNaN.js [app-client] (ecmascript)");
/** @type {import('./sign')} */ module.exports = function sign(number) {
    if ($isNaN(number) || number === 0) {
        return number;
    }
    return number < 0 ? -1 : +1;
};
}),
"[project]/node_modules/gopd/gOPD.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./gOPD')} */ module.exports = Object.getOwnPropertyDescriptor;
}),
"[project]/node_modules/gopd/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ var $gOPD = __turbopack_context__.r("[project]/node_modules/gopd/gOPD.js [app-client] (ecmascript)");
if ($gOPD) {
    try {
        $gOPD([], 'length');
    } catch (e) {
        // IE 8 has a broken gOPD
        $gOPD = null;
    }
}
module.exports = $gOPD;
}),
"[project]/node_modules/es-define-property/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
    try {
        $defineProperty({}, 'a', {
            value: 1
        });
    } catch (e) {
        // IE 8 has a broken defineProperty
        $defineProperty = false;
    }
}
module.exports = $defineProperty;
}),
"[project]/node_modules/has-symbols/shams.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./shams')} */ /* eslint complexity: [2, 18], max-statements: [2, 33] */ module.exports = function hasSymbols() {
    if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
        return false;
    }
    if (typeof Symbol.iterator === 'symbol') {
        return true;
    }
    /** @type {{ [k in symbol]?: unknown }} */ var obj = {};
    var sym = Symbol('test');
    var symObj = Object(sym);
    if (typeof sym === 'string') {
        return false;
    }
    if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
        return false;
    }
    if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
        return false;
    }
    // temp disabled per https://github.com/ljharb/object.assign/issues/17
    // if (sym instanceof Symbol) { return false; }
    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
    // if (!(symObj instanceof Symbol)) { return false; }
    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
    var symVal = 42;
    obj[sym] = symVal;
    for(var _ in obj){
        return false;
    } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
    if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
        return false;
    }
    if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
        return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === 'function') {
        // eslint-disable-next-line no-extra-parens
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
        }
    }
    return true;
};
}),
"[project]/node_modules/has-symbols/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __turbopack_context__.r("[project]/node_modules/has-symbols/shams.js [app-client] (ecmascript)");
/** @type {import('.')} */ module.exports = function hasNativeSymbols() {
    if (typeof origSymbol !== 'function') {
        return false;
    }
    if (typeof Symbol !== 'function') {
        return false;
    }
    if (typeof origSymbol('foo') !== 'symbol') {
        return false;
    }
    if (typeof Symbol('bar') !== 'symbol') {
        return false;
    }
    return hasSymbolSham();
};
}),
"[project]/node_modules/get-proto/Reflect.getPrototypeOf.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./Reflect.getPrototypeOf')} */ module.exports = typeof Reflect !== 'undefined' && Reflect.getPrototypeOf || null;
}),
"[project]/node_modules/get-proto/Object.getPrototypeOf.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $Object = __turbopack_context__.r("[project]/node_modules/es-object-atoms/index.js [app-client] (ecmascript)");
/** @type {import('./Object.getPrototypeOf')} */ module.exports = $Object.getPrototypeOf || null;
}),
"[project]/node_modules/get-proto/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var reflectGetProto = __turbopack_context__.r("[project]/node_modules/get-proto/Reflect.getPrototypeOf.js [app-client] (ecmascript)");
var originalGetProto = __turbopack_context__.r("[project]/node_modules/get-proto/Object.getPrototypeOf.js [app-client] (ecmascript)");
var getDunderProto = __turbopack_context__.r("[project]/node_modules/dunder-proto/get.js [app-client] (ecmascript)");
/** @type {import('.')} */ module.exports = reflectGetProto ? function getProto(O) {
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return reflectGetProto(O);
} : originalGetProto ? function getProto(O) {
    if (!O || typeof O !== 'object' && typeof O !== 'function') {
        throw new TypeError('getProto: not an object');
    }
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return originalGetProto(O);
} : getDunderProto ? function getProto(O) {
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return getDunderProto(O);
} : null;
}),
"[project]/node_modules/function-bind/implementation.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint no-invalid-this: 1 */ var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';
var concatty = function concatty(a, b) {
    var arr = [];
    for(var i = 0; i < a.length; i += 1){
        arr[i] = a[i];
    }
    for(var j = 0; j < b.length; j += 1){
        arr[j + a.length] = b[j];
    }
    return arr;
};
var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for(var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1){
        arr[j] = arrLike[i];
    }
    return arr;
};
var joiny = function(arr, joiner) {
    var str = '';
    for(var i = 0; i < arr.length; i += 1){
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};
module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
        if (this instanceof bound) {
            var result = target.apply(this, concatty(args, arguments));
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for(var i = 0; i < boundLength; i++){
        boundArgs[i] = '$' + i;
    }
    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }
    return bound;
};
}),
"[project]/node_modules/function-bind/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var implementation = __turbopack_context__.r("[project]/node_modules/function-bind/implementation.js [app-client] (ecmascript)");
module.exports = Function.prototype.bind || implementation;
}),
"[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./functionCall')} */ module.exports = Function.prototype.call;
}),
"[project]/node_modules/call-bind-apply-helpers/functionApply.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./functionApply')} */ module.exports = Function.prototype.apply;
}),
"[project]/node_modules/call-bind-apply-helpers/reflectApply.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./reflectApply')} */ module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;
}),
"[project]/node_modules/call-bind-apply-helpers/actualApply.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-client] (ecmascript)");
var $apply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionApply.js [app-client] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-client] (ecmascript)");
var $reflectApply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/reflectApply.js [app-client] (ecmascript)");
/** @type {import('./actualApply')} */ module.exports = $reflectApply || bind.call($call, $apply);
}),
"[project]/node_modules/call-bind-apply-helpers/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-client] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-client] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-client] (ecmascript)");
var $actualApply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/actualApply.js [app-client] (ecmascript)");
/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */ module.exports = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== 'function') {
        throw new $TypeError('a function is required');
    }
    return $actualApply(bind, $call, args);
};
}),
"[project]/node_modules/call-bind-apply-helpers/applyBind.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-client] (ecmascript)");
var $apply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionApply.js [app-client] (ecmascript)");
var actualApply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/actualApply.js [app-client] (ecmascript)");
/** @type {import('./applyBind')} */ module.exports = function applyBind() {
    return actualApply(bind, $apply, arguments);
};
}),
"[project]/node_modules/dunder-proto/get.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var callBind = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/index.js [app-client] (ecmascript)");
var gOPD = __turbopack_context__.r("[project]/node_modules/gopd/index.js [app-client] (ecmascript)");
var hasProtoAccessor;
try {
    // eslint-disable-next-line no-extra-parens, no-proto
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ [].__proto__ === Array.prototype;
} catch (e) {
    if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
        throw e;
    }
}
// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, '__proto__');
var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;
/** @type {import('./get')} */ module.exports = desc && typeof desc.get === 'function' ? callBind([
    desc.get
]) : typeof $getPrototypeOf === 'function' ? /** @type {import('./get')} */ function getDunder(value) {
    // eslint-disable-next-line eqeqeq
    return $getPrototypeOf(value == null ? value : $Object(value));
} : false;
}),
"[project]/node_modules/hasown/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-client] (ecmascript)");
/** @type {import('.')} */ module.exports = bind.call(call, $hasOwn);
}),
"[project]/node_modules/get-intrinsic/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var undefined1;
var $Object = __turbopack_context__.r("[project]/node_modules/es-object-atoms/index.js [app-client] (ecmascript)");
var $Error = __turbopack_context__.r("[project]/node_modules/es-errors/index.js [app-client] (ecmascript)");
var $EvalError = __turbopack_context__.r("[project]/node_modules/es-errors/eval.js [app-client] (ecmascript)");
var $RangeError = __turbopack_context__.r("[project]/node_modules/es-errors/range.js [app-client] (ecmascript)");
var $ReferenceError = __turbopack_context__.r("[project]/node_modules/es-errors/ref.js [app-client] (ecmascript)");
var $SyntaxError = __turbopack_context__.r("[project]/node_modules/es-errors/syntax.js [app-client] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-client] (ecmascript)");
var $URIError = __turbopack_context__.r("[project]/node_modules/es-errors/uri.js [app-client] (ecmascript)");
var abs = __turbopack_context__.r("[project]/node_modules/math-intrinsics/abs.js [app-client] (ecmascript)");
var floor = __turbopack_context__.r("[project]/node_modules/math-intrinsics/floor.js [app-client] (ecmascript)");
var max = __turbopack_context__.r("[project]/node_modules/math-intrinsics/max.js [app-client] (ecmascript)");
var min = __turbopack_context__.r("[project]/node_modules/math-intrinsics/min.js [app-client] (ecmascript)");
var pow = __turbopack_context__.r("[project]/node_modules/math-intrinsics/pow.js [app-client] (ecmascript)");
var round = __turbopack_context__.r("[project]/node_modules/math-intrinsics/round.js [app-client] (ecmascript)");
var sign = __turbopack_context__.r("[project]/node_modules/math-intrinsics/sign.js [app-client] (ecmascript)");
var $Function = Function;
// eslint-disable-next-line consistent-return
var getEvalledConstructor = function(expressionSyntax) {
    try {
        return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
    } catch (e) {}
};
var $gOPD = __turbopack_context__.r("[project]/node_modules/gopd/index.js [app-client] (ecmascript)");
var $defineProperty = __turbopack_context__.r("[project]/node_modules/es-define-property/index.js [app-client] (ecmascript)");
var throwTypeError = function() {
    throw new $TypeError();
};
var ThrowTypeError = $gOPD ? function() {
    try {
        // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
        arguments.callee; // IE 8 does not throw here
        return throwTypeError;
    } catch (calleeThrows) {
        try {
            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
            return $gOPD(arguments, 'callee').get;
        } catch (gOPDthrows) {
            return throwTypeError;
        }
    }
}() : throwTypeError;
var hasSymbols = __turbopack_context__.r("[project]/node_modules/has-symbols/index.js [app-client] (ecmascript)")();
var getProto = __turbopack_context__.r("[project]/node_modules/get-proto/index.js [app-client] (ecmascript)");
var $ObjectGPO = __turbopack_context__.r("[project]/node_modules/get-proto/Object.getPrototypeOf.js [app-client] (ecmascript)");
var $ReflectGPO = __turbopack_context__.r("[project]/node_modules/get-proto/Reflect.getPrototypeOf.js [app-client] (ecmascript)");
var $apply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionApply.js [app-client] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-client] (ecmascript)");
var needsEval = {};
var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);
var INTRINSICS = {
    __proto__: null,
    '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
    '%Array%': Array,
    '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
    '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
    '%AsyncFromSyncIteratorPrototype%': undefined,
    '%AsyncFunction%': needsEval,
    '%AsyncGenerator%': needsEval,
    '%AsyncGeneratorFunction%': needsEval,
    '%AsyncIteratorPrototype%': needsEval,
    '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
    '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
    '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
    '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
    '%Boolean%': Boolean,
    '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
    '%Date%': Date,
    '%decodeURI%': decodeURI,
    '%decodeURIComponent%': decodeURIComponent,
    '%encodeURI%': encodeURI,
    '%encodeURIComponent%': encodeURIComponent,
    '%Error%': $Error,
    '%eval%': eval,
    '%EvalError%': $EvalError,
    '%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
    '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
    '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
    '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
    '%Function%': $Function,
    '%GeneratorFunction%': needsEval,
    '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
    '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
    '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
    '%isFinite%': isFinite,
    '%isNaN%': isNaN,
    '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
    '%JSON%': typeof JSON === 'object' ? JSON : undefined,
    '%Map%': typeof Map === 'undefined' ? undefined : Map,
    '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
    '%Math%': Math,
    '%Number%': Number,
    '%Object%': $Object,
    '%Object.getOwnPropertyDescriptor%': $gOPD,
    '%parseFloat%': parseFloat,
    '%parseInt%': parseInt,
    '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
    '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
    '%RangeError%': $RangeError,
    '%ReferenceError%': $ReferenceError,
    '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
    '%RegExp%': RegExp,
    '%Set%': typeof Set === 'undefined' ? undefined : Set,
    '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
    '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
    '%String%': String,
    '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
    '%Symbol%': hasSymbols ? Symbol : undefined,
    '%SyntaxError%': $SyntaxError,
    '%ThrowTypeError%': ThrowTypeError,
    '%TypedArray%': TypedArray,
    '%TypeError%': $TypeError,
    '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
    '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
    '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
    '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
    '%URIError%': $URIError,
    '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
    '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
    '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,
    '%Function.prototype.call%': $call,
    '%Function.prototype.apply%': $apply,
    '%Object.defineProperty%': $defineProperty,
    '%Object.getPrototypeOf%': $ObjectGPO,
    '%Math.abs%': abs,
    '%Math.floor%': floor,
    '%Math.max%': max,
    '%Math.min%': min,
    '%Math.pow%': pow,
    '%Math.round%': round,
    '%Math.sign%': sign,
    '%Reflect.getPrototypeOf%': $ReflectGPO
};
if (getProto) {
    try {
        null.error; // eslint-disable-line no-unused-expressions
    } catch (e) {
        // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
        var errorProto = getProto(getProto(e));
        INTRINSICS['%Error.prototype%'] = errorProto;
    }
}
var doEval = function doEval(name) {
    var value;
    if (name === '%AsyncFunction%') {
        value = getEvalledConstructor('async function () {}');
    } else if (name === '%GeneratorFunction%') {
        value = getEvalledConstructor('function* () {}');
    } else if (name === '%AsyncGeneratorFunction%') {
        value = getEvalledConstructor('async function* () {}');
    } else if (name === '%AsyncGenerator%') {
        var fn = doEval('%AsyncGeneratorFunction%');
        if (fn) {
            value = fn.prototype;
        }
    } else if (name === '%AsyncIteratorPrototype%') {
        var gen = doEval('%AsyncGenerator%');
        if (gen && getProto) {
            value = getProto(gen.prototype);
        }
    }
    INTRINSICS[name] = value;
    return value;
};
var LEGACY_ALIASES = {
    __proto__: null,
    '%ArrayBufferPrototype%': [
        'ArrayBuffer',
        'prototype'
    ],
    '%ArrayPrototype%': [
        'Array',
        'prototype'
    ],
    '%ArrayProto_entries%': [
        'Array',
        'prototype',
        'entries'
    ],
    '%ArrayProto_forEach%': [
        'Array',
        'prototype',
        'forEach'
    ],
    '%ArrayProto_keys%': [
        'Array',
        'prototype',
        'keys'
    ],
    '%ArrayProto_values%': [
        'Array',
        'prototype',
        'values'
    ],
    '%AsyncFunctionPrototype%': [
        'AsyncFunction',
        'prototype'
    ],
    '%AsyncGenerator%': [
        'AsyncGeneratorFunction',
        'prototype'
    ],
    '%AsyncGeneratorPrototype%': [
        'AsyncGeneratorFunction',
        'prototype',
        'prototype'
    ],
    '%BooleanPrototype%': [
        'Boolean',
        'prototype'
    ],
    '%DataViewPrototype%': [
        'DataView',
        'prototype'
    ],
    '%DatePrototype%': [
        'Date',
        'prototype'
    ],
    '%ErrorPrototype%': [
        'Error',
        'prototype'
    ],
    '%EvalErrorPrototype%': [
        'EvalError',
        'prototype'
    ],
    '%Float32ArrayPrototype%': [
        'Float32Array',
        'prototype'
    ],
    '%Float64ArrayPrototype%': [
        'Float64Array',
        'prototype'
    ],
    '%FunctionPrototype%': [
        'Function',
        'prototype'
    ],
    '%Generator%': [
        'GeneratorFunction',
        'prototype'
    ],
    '%GeneratorPrototype%': [
        'GeneratorFunction',
        'prototype',
        'prototype'
    ],
    '%Int8ArrayPrototype%': [
        'Int8Array',
        'prototype'
    ],
    '%Int16ArrayPrototype%': [
        'Int16Array',
        'prototype'
    ],
    '%Int32ArrayPrototype%': [
        'Int32Array',
        'prototype'
    ],
    '%JSONParse%': [
        'JSON',
        'parse'
    ],
    '%JSONStringify%': [
        'JSON',
        'stringify'
    ],
    '%MapPrototype%': [
        'Map',
        'prototype'
    ],
    '%NumberPrototype%': [
        'Number',
        'prototype'
    ],
    '%ObjectPrototype%': [
        'Object',
        'prototype'
    ],
    '%ObjProto_toString%': [
        'Object',
        'prototype',
        'toString'
    ],
    '%ObjProto_valueOf%': [
        'Object',
        'prototype',
        'valueOf'
    ],
    '%PromisePrototype%': [
        'Promise',
        'prototype'
    ],
    '%PromiseProto_then%': [
        'Promise',
        'prototype',
        'then'
    ],
    '%Promise_all%': [
        'Promise',
        'all'
    ],
    '%Promise_reject%': [
        'Promise',
        'reject'
    ],
    '%Promise_resolve%': [
        'Promise',
        'resolve'
    ],
    '%RangeErrorPrototype%': [
        'RangeError',
        'prototype'
    ],
    '%ReferenceErrorPrototype%': [
        'ReferenceError',
        'prototype'
    ],
    '%RegExpPrototype%': [
        'RegExp',
        'prototype'
    ],
    '%SetPrototype%': [
        'Set',
        'prototype'
    ],
    '%SharedArrayBufferPrototype%': [
        'SharedArrayBuffer',
        'prototype'
    ],
    '%StringPrototype%': [
        'String',
        'prototype'
    ],
    '%SymbolPrototype%': [
        'Symbol',
        'prototype'
    ],
    '%SyntaxErrorPrototype%': [
        'SyntaxError',
        'prototype'
    ],
    '%TypedArrayPrototype%': [
        'TypedArray',
        'prototype'
    ],
    '%TypeErrorPrototype%': [
        'TypeError',
        'prototype'
    ],
    '%Uint8ArrayPrototype%': [
        'Uint8Array',
        'prototype'
    ],
    '%Uint8ClampedArrayPrototype%': [
        'Uint8ClampedArray',
        'prototype'
    ],
    '%Uint16ArrayPrototype%': [
        'Uint16Array',
        'prototype'
    ],
    '%Uint32ArrayPrototype%': [
        'Uint32Array',
        'prototype'
    ],
    '%URIErrorPrototype%': [
        'URIError',
        'prototype'
    ],
    '%WeakMapPrototype%': [
        'WeakMap',
        'prototype'
    ],
    '%WeakSetPrototype%': [
        'WeakSet',
        'prototype'
    ]
};
var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-client] (ecmascript)");
var hasOwn = __turbopack_context__.r("[project]/node_modules/hasown/index.js [app-client] (ecmascript)");
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);
/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */ 
var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === '%' && last !== '%') {
        throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
    } else if (last === '%' && first !== '%') {
        throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
    });
    return result;
};
/* end adaptation */ var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = '%' + alias[0] + '%';
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
            value = doEval(intrinsicName);
        }
        if (typeof value === 'undefined' && !allowMissing) {
            throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
        }
        return {
            alias: alias,
            name: intrinsicName,
            value: value
        };
    }
    throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};
module.exports = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== 'string' || name.length === 0) {
        throw new $TypeError('intrinsic name must be a non-empty string');
    }
    if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
        throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
    var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([
            0,
            1
        ], alias));
    }
    for(var i = 1, isOwn = true; i < parts.length; i += 1){
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
            throw new $SyntaxError('property names with quotes must have matching quotes');
        }
        if (part === 'constructor' || !isOwn) {
            skipFurtherCaching = true;
        }
        intrinsicBaseName += '.' + part;
        intrinsicRealName = '%' + intrinsicBaseName + '%';
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
            if (!(part in value)) {
                if (!allowMissing) {
                    throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                }
                return void undefined;
            }
            if ($gOPD && i + 1 >= parts.length) {
                var desc = $gOPD(value, part);
                isOwn = !!desc;
                // By convention, when a data property is converted to an accessor
                // property to emulate a data property that does not suffer from
                // the override mistake, that accessor's getter is marked with
                // an `originalValue` property. Here, when we detect this, we
                // uphold the illusion by pretending to see that original data
                // property, i.e., returning the value rather than the getter
                // itself.
                if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                    value = desc.get;
                } else {
                    value = value[part];
                }
            } else {
                isOwn = hasOwn(value, part);
                value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
                INTRINSICS[intrinsicRealName] = value;
            }
        }
    }
    return value;
};
}),
"[project]/node_modules/call-bound/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var GetIntrinsic = __turbopack_context__.r("[project]/node_modules/get-intrinsic/index.js [app-client] (ecmascript)");
var callBindBasic = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/index.js [app-client] (ecmascript)");
/** @type {(thisArg: string, searchString: string, position?: number) => number} */ var $indexOf = callBindBasic([
    GetIntrinsic('%String.prototype.indexOf%')
]);
/** @type {import('.')} */ module.exports = function callBoundIntrinsic(name, allowMissing) {
    /* eslint no-extra-parens: 0 */ var intrinsic = GetIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
        return callBindBasic([
            intrinsic
        ]);
    }
    return intrinsic;
};
}),
"[project]/node_modules/is-callable/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
    try {
        badArrayLike = Object.defineProperty({}, 'length', {
            get: function() {
                throw isCallableMarker;
            }
        });
        isCallableMarker = {};
        // eslint-disable-next-line no-throw-literal
        reflectApply(function() {
            throw 42;
        }, null, badArrayLike);
    } catch (_) {
        if (_ !== isCallableMarker) {
            reflectApply = null;
        }
    }
} else {
    reflectApply = null;
}
var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
    try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
    } catch (e) {
        return false; // not a function
    }
};
var tryFunctionObject = function tryFunctionToStr(value) {
    try {
        if (isES6ClassFn(value)) {
            return false;
        }
        fnToStr.call(value);
        return true;
    } catch (e) {
        return false;
    }
};
var toStr = Object.prototype.toString;
var objectClass = '[object Object]';
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var ddaClass = '[object HTMLAllCollection]'; // IE 11
var ddaClass2 = '[object HTML document.all class]';
var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`
var isIE68 = !(0 in [
    , 
]); // eslint-disable-line no-sparse-arrays, comma-spacing
var isDDA = function isDocumentDotAll() {
    return false;
};
if (typeof document === 'object') {
    // Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
    var all = document.all;
    if (toStr.call(all) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
            /* globals document: false */ // in IE 6-8, typeof document.all is "object" and it's truthy
            if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
                try {
                    var str = toStr.call(value);
                    return (str === ddaClass || str === ddaClass2 || str === ddaClass3 // opera 12.16
                     || str === objectClass // IE 6-8
                    ) && value('') == null; // eslint-disable-line eqeqeq
                } catch (e) {}
            }
            return false;
        };
    }
}
module.exports = reflectApply ? function isCallable(value) {
    if (isDDA(value)) {
        return true;
    }
    if (!value) {
        return false;
    }
    if (typeof value !== 'function' && typeof value !== 'object') {
        return false;
    }
    try {
        reflectApply(value, null, badArrayLike);
    } catch (e) {
        if (e !== isCallableMarker) {
            return false;
        }
    }
    return !isES6ClassFn(value) && tryFunctionObject(value);
} : function isCallable(value) {
    if (isDDA(value)) {
        return true;
    }
    if (!value) {
        return false;
    }
    if (typeof value !== 'function' && typeof value !== 'object') {
        return false;
    }
    if (hasToStringTag) {
        return tryFunctionObject(value);
    }
    if (isES6ClassFn(value)) {
        return false;
    }
    var strClass = toStr.call(value);
    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
    }
    return tryFunctionObject(value);
};
}),
"[project]/node_modules/for-each/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var isCallable = __turbopack_context__.r("[project]/node_modules/is-callable/index.js [app-client] (ecmascript)");
var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;
/** @type {<This, A extends readonly unknown[]>(arr: A, iterator: (this: This | void, value: A[number], index: number, arr: A) => void, receiver: This | undefined) => void} */ var forEachArray = function forEachArray(array, iterator, receiver) {
    for(var i = 0, len = array.length; i < len; i++){
        if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
                iterator(array[i], i, array);
            } else {
                iterator.call(receiver, array[i], i, array);
            }
        }
    }
};
/** @type {<This, S extends string>(string: S, iterator: (this: This | void, value: S[number], index: number, string: S) => void, receiver: This | undefined) => void} */ var forEachString = function forEachString(string, iterator, receiver) {
    for(var i = 0, len = string.length; i < len; i++){
        // no such thing as a sparse string.
        if (receiver == null) {
            iterator(string.charAt(i), i, string);
        } else {
            iterator.call(receiver, string.charAt(i), i, string);
        }
    }
};
/** @type {<This, O>(obj: O, iterator: (this: This | void, value: O[keyof O], index: keyof O, obj: O) => void, receiver: This | undefined) => void} */ var forEachObject = function forEachObject(object, iterator, receiver) {
    for(var k in object){
        if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
                iterator(object[k], k, object);
            } else {
                iterator.call(receiver, object[k], k, object);
            }
        }
    }
};
/** @type {(x: unknown) => x is readonly unknown[]} */ function isArray(x) {
    return toStr.call(x) === '[object Array]';
}
/** @type {import('.')._internal} */ module.exports = function forEach(list, iterator, thisArg) {
    if (!isCallable(iterator)) {
        throw new TypeError('iterator must be a function');
    }
    var receiver;
    if (arguments.length >= 3) {
        receiver = thisArg;
    }
    if (isArray(list)) {
        forEachArray(list, iterator, receiver);
    } else if (typeof list === 'string') {
        forEachString(list, iterator, receiver);
    } else {
        forEachObject(list, iterator, receiver);
    }
};
}),
"[project]/node_modules/possible-typed-array-names/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ module.exports = [
    'Float16Array',
    'Float32Array',
    'Float64Array',
    'Int8Array',
    'Int16Array',
    'Int32Array',
    'Uint8Array',
    'Uint8ClampedArray',
    'Uint16Array',
    'Uint32Array',
    'BigInt64Array',
    'BigUint64Array'
];
}),
"[project]/node_modules/available-typed-arrays/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var possibleNames = __turbopack_context__.r("[project]/node_modules/possible-typed-array-names/index.js [app-client] (ecmascript)");
var g = typeof globalThis === 'undefined' ? /*TURBOPACK member replacement*/ __turbopack_context__.g : globalThis;
/** @type {import('.')} */ module.exports = function availableTypedArrays() {
    var /** @type {ReturnType<typeof availableTypedArrays>} */ out = [];
    for(var i = 0; i < possibleNames.length; i++){
        if (typeof g[possibleNames[i]] === 'function') {
            // @ts-expect-error
            out[out.length] = possibleNames[i];
        }
    }
    return out;
};
}),
"[project]/node_modules/define-data-property/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $defineProperty = __turbopack_context__.r("[project]/node_modules/es-define-property/index.js [app-client] (ecmascript)");
var $SyntaxError = __turbopack_context__.r("[project]/node_modules/es-errors/syntax.js [app-client] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-client] (ecmascript)");
var gopd = __turbopack_context__.r("[project]/node_modules/gopd/index.js [app-client] (ecmascript)");
/** @type {import('.')} */ module.exports = function defineDataProperty(obj, property, value) {
    if (!obj || typeof obj !== 'object' && typeof obj !== 'function') {
        throw new $TypeError('`obj` must be an object or a function`');
    }
    if (typeof property !== 'string' && typeof property !== 'symbol') {
        throw new $TypeError('`property` must be a string or a symbol`');
    }
    if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
        throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
    }
    if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
        throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
    }
    if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
        throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
    }
    if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
        throw new $TypeError('`loose`, if provided, must be a boolean');
    }
    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
    var nonWritable = arguments.length > 4 ? arguments[4] : null;
    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
    var loose = arguments.length > 6 ? arguments[6] : false;
    /* @type {false | TypedPropertyDescriptor<unknown>} */ var desc = !!gopd && gopd(obj, property);
    if ($defineProperty) {
        $defineProperty(obj, property, {
            configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
            enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
            value: value,
            writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        // must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
        obj[property] = value; // eslint-disable-line no-param-reassign
    } else {
        throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
    }
};
}),
"[project]/node_modules/has-property-descriptors/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $defineProperty = __turbopack_context__.r("[project]/node_modules/es-define-property/index.js [app-client] (ecmascript)");
var hasPropertyDescriptors = function hasPropertyDescriptors() {
    return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    // node v0.6 has a bug where array lengths can be Set but not Defined
    if (!$defineProperty) {
        return null;
    }
    try {
        return $defineProperty([], 'length', {
            value: 1
        }).length !== 1;
    } catch (e) {
        // In Firefox 4-22, defining length on an array throws an exception.
        return true;
    }
};
module.exports = hasPropertyDescriptors;
}),
"[project]/node_modules/set-function-length/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var GetIntrinsic = __turbopack_context__.r("[project]/node_modules/get-intrinsic/index.js [app-client] (ecmascript)");
var define = __turbopack_context__.r("[project]/node_modules/define-data-property/index.js [app-client] (ecmascript)");
var hasDescriptors = __turbopack_context__.r("[project]/node_modules/has-property-descriptors/index.js [app-client] (ecmascript)")();
var gOPD = __turbopack_context__.r("[project]/node_modules/gopd/index.js [app-client] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-client] (ecmascript)");
var $floor = GetIntrinsic('%Math.floor%');
/** @type {import('.')} */ module.exports = function setFunctionLength(fn, length) {
    if (typeof fn !== 'function') {
        throw new $TypeError('`fn` is not a function');
    }
    if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
        throw new $TypeError('`length` must be a positive 32-bit integer');
    }
    var loose = arguments.length > 2 && !!arguments[2];
    var functionLengthIsConfigurable = true;
    var functionLengthIsWritable = true;
    if ('length' in fn && gOPD) {
        var desc = gOPD(fn, 'length');
        if (desc && !desc.configurable) {
            functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
            functionLengthIsWritable = false;
        }
    }
    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
            define(fn, 'length', length, true, true);
        } else {
            define(fn, 'length', length);
        }
    }
    return fn;
};
}),
"[project]/node_modules/call-bind/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var setFunctionLength = __turbopack_context__.r("[project]/node_modules/set-function-length/index.js [app-client] (ecmascript)");
var $defineProperty = __turbopack_context__.r("[project]/node_modules/es-define-property/index.js [app-client] (ecmascript)");
var callBindBasic = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/index.js [app-client] (ecmascript)");
var applyBind = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/applyBind.js [app-client] (ecmascript)");
module.exports = function callBind(originalFunction) {
    var func = callBindBasic(arguments);
    var adjustedLength = originalFunction.length - (arguments.length - 1);
    return setFunctionLength(func, 1 + (adjustedLength > 0 ? adjustedLength : 0), true);
};
if ($defineProperty) {
    $defineProperty(module.exports, 'apply', {
        value: applyBind
    });
} else {
    module.exports.apply = applyBind;
}
}),
"[project]/node_modules/has-tostringtag/shams.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var hasSymbols = __turbopack_context__.r("[project]/node_modules/has-symbols/shams.js [app-client] (ecmascript)");
/** @type {import('.')} */ module.exports = function hasToStringTagShams() {
    return hasSymbols() && !!Symbol.toStringTag;
};
}),
"[project]/node_modules/which-typed-array/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var forEach = __turbopack_context__.r("[project]/node_modules/for-each/index.js [app-client] (ecmascript)");
var availableTypedArrays = __turbopack_context__.r("[project]/node_modules/available-typed-arrays/index.js [app-client] (ecmascript)");
var callBind = __turbopack_context__.r("[project]/node_modules/call-bind/index.js [app-client] (ecmascript)");
var callBound = __turbopack_context__.r("[project]/node_modules/call-bound/index.js [app-client] (ecmascript)");
var gOPD = __turbopack_context__.r("[project]/node_modules/gopd/index.js [app-client] (ecmascript)");
var getProto = __turbopack_context__.r("[project]/node_modules/get-proto/index.js [app-client] (ecmascript)");
var $toString = callBound('Object.prototype.toString');
var hasToStringTag = __turbopack_context__.r("[project]/node_modules/has-tostringtag/shams.js [app-client] (ecmascript)")();
var g = typeof globalThis === 'undefined' ? /*TURBOPACK member replacement*/ __turbopack_context__.g : globalThis;
var typedArrays = availableTypedArrays();
var $slice = callBound('String.prototype.slice');
/** @type {<T = unknown>(array: readonly T[], value: unknown) => number} */ var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
    for(var i = 0; i < array.length; i += 1){
        if (array[i] === value) {
            return i;
        }
    }
    return -1;
};
/** @typedef {import('./types').Getter} Getter */ /** @type {import('./types').Cache} */ var cache = {
    __proto__: null
};
if (hasToStringTag && gOPD && getProto) {
    forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr && getProto) {
            var proto = getProto(arr);
            // @ts-expect-error TS won't narrow inside a closure
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor && proto) {
                var superProto = getProto(proto);
                // @ts-expect-error TS won't narrow inside a closure
                descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            // @ts-expect-error TODO: fix
            cache['$' + typedArray] = callBind(descriptor.get);
        }
    });
} else {
    forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        var fn = arr.slice || arr.set;
        if (fn) {
            cache['$' + typedArray] = // @ts-expect-error TODO FIXME
            callBind(fn);
        }
    });
}
/** @type {(value: object) => false | import('.').TypedArrayName} */ var tryTypedArrays = function tryAllTypedArrays(value) {
    /** @type {ReturnType<typeof tryAllTypedArrays>} */ var found = false;
    forEach(cache, /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */ function(getter, typedArray) {
        if (!found) {
            try {
                // @ts-expect-error a throw is fine here
                if ('$' + getter(value) === typedArray) {
                    found = $slice(typedArray, 1);
                }
            } catch (e) {}
        }
    });
    return found;
};
/** @type {(value: object) => false | import('.').TypedArrayName} */ var trySlices = function tryAllSlices(value) {
    /** @type {ReturnType<typeof tryAllSlices>} */ var found = false;
    forEach(cache, /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */ function(getter, name) {
        if (!found) {
            try {
                // @ts-expect-error a throw is fine here
                getter(value);
                found = $slice(name, 1);
            } catch (e) {}
        }
    });
    return found;
};
/** @type {import('.')} */ module.exports = function whichTypedArray(value) {
    if (!value || typeof value !== 'object') {
        return false;
    }
    if (!hasToStringTag) {
        /** @type {string} */ var tag = $slice($toString(value), 8, -1);
        if ($indexOf(typedArrays, tag) > -1) {
            return tag;
        }
        if (tag !== 'Object') {
            return false;
        }
        // node < 0.6 hits here on real Typed Arrays
        return trySlices(value);
    }
    if (!gOPD) {
        return null;
    } // unknown engine
    return tryTypedArrays(value);
};
}),
"[project]/node_modules/is-typed-array/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var whichTypedArray = __turbopack_context__.r("[project]/node_modules/which-typed-array/index.js [app-client] (ecmascript)");
/** @type {import('.')} */ module.exports = function isTypedArray(value) {
    return !!whichTypedArray(value);
};
}),
"[project]/node_modules/typed-array-buffer/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-client] (ecmascript)");
var callBound = __turbopack_context__.r("[project]/node_modules/call-bound/index.js [app-client] (ecmascript)");
/** @type {undefined | ((thisArg: import('.').TypedArray) => Buffer<ArrayBufferLike>)} */ var $typedArrayBuffer = callBound('TypedArray.prototype.buffer', true);
var isTypedArray = __turbopack_context__.r("[project]/node_modules/is-typed-array/index.js [app-client] (ecmascript)");
/** @type {import('.')} */ // node <= 0.10, < 0.11.4 has a nonconfigurable own property instead of a prototype getter
module.exports = $typedArrayBuffer || function typedArrayBuffer(x) {
    if (!isTypedArray(x)) {
        throw new $TypeError('Not a Typed Array');
    }
    return x.buffer;
};
}),
"[project]/node_modules/to-buffer/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-client] (ecmascript)").Buffer;
var isArray = __turbopack_context__.r("[project]/node_modules/isarray/index.js [app-client] (ecmascript)");
var typedArrayBuffer = __turbopack_context__.r("[project]/node_modules/typed-array-buffer/index.js [app-client] (ecmascript)");
var isView = ArrayBuffer.isView || function isView(obj) {
    try {
        typedArrayBuffer(obj);
        return true;
    } catch (e) {
        return false;
    }
};
var useUint8Array = typeof Uint8Array !== 'undefined';
var useArrayBuffer = typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined';
var useFromArrayBuffer = useArrayBuffer && (Buffer.prototype instanceof Uint8Array || Buffer.TYPED_ARRAY_SUPPORT);
module.exports = function toBuffer(data, encoding) {
    if (Buffer.isBuffer(data)) {
        if (data.constructor && !('isBuffer' in data)) {
            // probably a SlowBuffer
            return Buffer.from(data);
        }
        return data;
    }
    if (typeof data === 'string') {
        return Buffer.from(data, encoding);
    }
    /*
	 * Wrap any TypedArray instances and DataViews
	 * Makes sense only on engines with full TypedArray support -- let Buffer detect that
	 */ if (useArrayBuffer && isView(data)) {
        // Bug in Node.js <6.3.1, which treats this as out-of-bounds
        if (data.byteLength === 0) {
            return Buffer.alloc(0);
        }
        // When Buffer is based on Uint8Array, we can just construct it from ArrayBuffer
        if (useFromArrayBuffer) {
            var res = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
            /*
			 * Recheck result size, as offset/length doesn't work on Node.js <5.10
			 * We just go to Uint8Array case if this fails
			 */ if (res.byteLength === data.byteLength) {
                return res;
            }
        }
        // Convert to Uint8Array bytes and then to Buffer
        var uint8 = data instanceof Uint8Array ? data : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
        var result = Buffer.from(uint8);
        /*
		 * Let's recheck that conversion succeeded
		 * We have .length but not .byteLength when useFromArrayBuffer is false
		 */ if (result.length === data.byteLength) {
            return result;
        }
    }
    /*
	 * Uint8Array in engines where Buffer.from might not work with ArrayBuffer, just copy over
	 * Doesn't make sense with other TypedArray instances
	 */ if (useUint8Array && data instanceof Uint8Array) {
        return Buffer.from(data);
    }
    var isArr = isArray(data);
    if (isArr) {
        for(var i = 0; i < data.length; i += 1){
            var x = data[i];
            if (typeof x !== 'number' || x < 0 || x > 255 || ~~x !== x // NaN and integer check
            ) {
                throw new RangeError('Array items must be numbers in the range 0-255.');
            }
        }
    }
    /*
	 * Old Buffer polyfill on an engine that doesn't have TypedArray support
	 * Also, this is from a different Buffer polyfill implementation then we have, as instanceof check failed
	 * Convert to our current Buffer implementation
	 */ if (isArr || Buffer.isBuffer(data) && data.constructor && typeof data.constructor.isBuffer === 'function' && data.constructor.isBuffer(data)) {
        return Buffer.from(data);
    }
    throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');
};
}),
"[project]/node_modules/redux/dist/redux.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/utils/formatProdErrorMessage.ts
__turbopack_context__.s([
    "__DO_NOT_USE__ActionTypes",
    ()=>actionTypes_default,
    "applyMiddleware",
    ()=>applyMiddleware,
    "bindActionCreators",
    ()=>bindActionCreators,
    "combineReducers",
    ()=>combineReducers,
    "compose",
    ()=>compose,
    "createStore",
    ()=>createStore,
    "isAction",
    ()=>isAction,
    "isPlainObject",
    ()=>isPlainObject,
    "legacy_createStore",
    ()=>legacy_createStore
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
function formatProdErrorMessage(code) {
    return `Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
}
// src/utils/symbol-observable.ts
var $$observable = /* @__PURE__ */ (()=>typeof Symbol === "function" && Symbol.observable || "@@observable")();
var symbol_observable_default = $$observable;
// src/utils/actionTypes.ts
var randomString = ()=>Math.random().toString(36).substring(7).split("").join(".");
var ActionTypes = {
    INIT: `@@redux/INIT${/* @__PURE__ */ randomString()}`,
    REPLACE: `@@redux/REPLACE${/* @__PURE__ */ randomString()}`,
    PROBE_UNKNOWN_ACTION: ()=>`@@redux/PROBE_UNKNOWN_ACTION${randomString()}`
};
var actionTypes_default = ActionTypes;
// src/utils/isPlainObject.ts
function isPlainObject(obj) {
    if (typeof obj !== "object" || obj === null) return false;
    let proto = obj;
    while(Object.getPrototypeOf(proto) !== null){
        proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;
}
// src/utils/kindOf.ts
function miniKindOf(val) {
    if (val === void 0) return "undefined";
    if (val === null) return "null";
    const type = typeof val;
    switch(type){
        case "boolean":
        case "string":
        case "number":
        case "symbol":
        case "function":
            {
                return type;
            }
    }
    if (Array.isArray(val)) return "array";
    if (isDate(val)) return "date";
    if (isError(val)) return "error";
    const constructorName = ctorName(val);
    switch(constructorName){
        case "Symbol":
        case "Promise":
        case "WeakMap":
        case "WeakSet":
        case "Map":
        case "Set":
            return constructorName;
    }
    return Object.prototype.toString.call(val).slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function ctorName(val) {
    return typeof val.constructor === "function" ? val.constructor.name : null;
}
function isError(val) {
    return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function isDate(val) {
    if (val instanceof Date) return true;
    return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function kindOf(val) {
    let typeOfVal = typeof val;
    if ("TURBOPACK compile-time truthy", 1) {
        typeOfVal = miniKindOf(val);
    }
    return typeOfVal;
}
// src/createStore.ts
function createStore(reducer, preloadedState, enhancer) {
    if (typeof reducer !== "function") {
        throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : `Expected the root reducer to be a function. Instead, received: '${kindOf(reducer)}'`);
    }
    if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
        throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
    }
    if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
        enhancer = preloadedState;
        preloadedState = void 0;
    }
    if (typeof enhancer !== "undefined") {
        if (typeof enhancer !== "function") {
            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : `Expected the enhancer to be a function. Instead, received: '${kindOf(enhancer)}'`);
        }
        return enhancer(createStore)(reducer, preloadedState);
    }
    let currentReducer = reducer;
    let currentState = preloadedState;
    let currentListeners = /* @__PURE__ */ new Map();
    let nextListeners = currentListeners;
    let listenerIdCounter = 0;
    let isDispatching = false;
    function ensureCanMutateNextListeners() {
        if (nextListeners === currentListeners) {
            nextListeners = /* @__PURE__ */ new Map();
            currentListeners.forEach((listener, key)=>{
                nextListeners.set(key, listener);
            });
        }
    }
    function getState() {
        if (isDispatching) {
            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
        }
        return currentState;
    }
    function subscribe(listener) {
        if (typeof listener !== "function") {
            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : `Expected the listener to be a function. Instead, received: '${kindOf(listener)}'`);
        }
        if (isDispatching) {
            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
        }
        let isSubscribed = true;
        ensureCanMutateNextListeners();
        const listenerId = listenerIdCounter++;
        nextListeners.set(listenerId, listener);
        return function unsubscribe() {
            if (!isSubscribed) {
                return;
            }
            if (isDispatching) {
                throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
            }
            isSubscribed = false;
            ensureCanMutateNextListeners();
            nextListeners.delete(listenerId);
            currentListeners = null;
        };
    }
    function dispatch(action) {
        if (!isPlainObject(action)) {
            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : `Actions must be plain objects. Instead, the actual type was: '${kindOf(action)}'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`);
        }
        if (typeof action.type === "undefined") {
            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
        }
        if (typeof action.type !== "string") {
            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : `Action "type" property must be a string. Instead, the actual type was: '${kindOf(action.type)}'. Value was: '${action.type}' (stringified)`);
        }
        if (isDispatching) {
            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "Reducers may not dispatch actions.");
        }
        try {
            isDispatching = true;
            currentState = currentReducer(currentState, action);
        } finally{
            isDispatching = false;
        }
        const listeners = currentListeners = nextListeners;
        listeners.forEach((listener)=>{
            listener();
        });
        return action;
    }
    function replaceReducer(nextReducer) {
        if (typeof nextReducer !== "function") {
            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : `Expected the nextReducer to be a function. Instead, received: '${kindOf(nextReducer)}`);
        }
        currentReducer = nextReducer;
        dispatch({
            type: actionTypes_default.REPLACE
        });
    }
    function observable() {
        const outerSubscribe = subscribe;
        return {
            /**
       * The minimal observable subscription method.
       * @param observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */ subscribe (observer) {
                if (typeof observer !== "object" || observer === null) {
                    throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : `Expected the observer to be an object. Instead, received: '${kindOf(observer)}'`);
                }
                function observeState() {
                    const observerAsObserver = observer;
                    if (observerAsObserver.next) {
                        observerAsObserver.next(getState());
                    }
                }
                observeState();
                const unsubscribe = outerSubscribe(observeState);
                return {
                    unsubscribe
                };
            },
            [symbol_observable_default] () {
                return this;
            }
        };
    }
    dispatch({
        type: actionTypes_default.INIT
    });
    const store = {
        dispatch,
        subscribe,
        getState,
        replaceReducer,
        [symbol_observable_default]: observable
    };
    return store;
}
function legacy_createStore(reducer, preloadedState, enhancer) {
    return createStore(reducer, preloadedState, enhancer);
}
// src/utils/warning.ts
function warning(message) {
    if (typeof console !== "undefined" && typeof console.error === "function") {
        console.error(message);
    }
    try {
        throw new Error(message);
    } catch (e) {}
}
// src/combineReducers.ts
function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
    const reducerKeys = Object.keys(reducers);
    const argumentName = action && action.type === actionTypes_default.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
    if (reducerKeys.length === 0) {
        return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
    }
    if (!isPlainObject(inputState)) {
        return `The ${argumentName} has unexpected type of "${kindOf(inputState)}". Expected argument to be an object with the following keys: "${reducerKeys.join('", "')}"`;
    }
    const unexpectedKeys = Object.keys(inputState).filter((key)=>!reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]);
    unexpectedKeys.forEach((key)=>{
        unexpectedKeyCache[key] = true;
    });
    if (action && action.type === actionTypes_default.REPLACE) return;
    if (unexpectedKeys.length > 0) {
        return `Unexpected ${unexpectedKeys.length > 1 ? "keys" : "key"} "${unexpectedKeys.join('", "')}" found in ${argumentName}. Expected to find one of the known reducer keys instead: "${reducerKeys.join('", "')}". Unexpected keys will be ignored.`;
    }
}
function assertReducerShape(reducers) {
    Object.keys(reducers).forEach((key)=>{
        const reducer = reducers[key];
        const initialState = reducer(void 0, {
            type: actionTypes_default.INIT
        });
        if (typeof initialState === "undefined") {
            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : `The slice reducer for key "${key}" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);
        }
        if (typeof reducer(void 0, {
            type: actionTypes_default.PROBE_UNKNOWN_ACTION()
        }) === "undefined") {
            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : `The slice reducer for key "${key}" returned undefined when probed with a random type. Don't try to handle '${actionTypes_default.INIT}' or other actions in "redux/*" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.`);
        }
    });
}
function combineReducers(reducers) {
    const reducerKeys = Object.keys(reducers);
    const finalReducers = {};
    for(let i = 0; i < reducerKeys.length; i++){
        const key = reducerKeys[i];
        if ("TURBOPACK compile-time truthy", 1) {
            if (typeof reducers[key] === "undefined") {
                warning(`No reducer provided for key "${key}"`);
            }
        }
        if (typeof reducers[key] === "function") {
            finalReducers[key] = reducers[key];
        }
    }
    const finalReducerKeys = Object.keys(finalReducers);
    let unexpectedKeyCache;
    if (("TURBOPACK compile-time value", "development") !== "production") {
        unexpectedKeyCache = {};
    }
    let shapeAssertionError;
    try {
        assertReducerShape(finalReducers);
    } catch (e) {
        shapeAssertionError = e;
    }
    return function combination(state = {}, action) {
        if (shapeAssertionError) {
            throw shapeAssertionError;
        }
        if ("TURBOPACK compile-time truthy", 1) {
            const warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
            if (warningMessage) {
                warning(warningMessage);
            }
        }
        let hasChanged = false;
        const nextState = {};
        for(let i = 0; i < finalReducerKeys.length; i++){
            const key = finalReducerKeys[i];
            const reducer = finalReducers[key];
            const previousStateForKey = state[key];
            const nextStateForKey = reducer(previousStateForKey, action);
            if (typeof nextStateForKey === "undefined") {
                const actionType = action && action.type;
                throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : `When called with an action of type ${actionType ? `"${String(actionType)}"` : "(unknown type)"}, the slice reducer for key "${key}" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.`);
            }
            nextState[key] = nextStateForKey;
            hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
        }
        hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
        return hasChanged ? nextState : state;
    };
}
// src/bindActionCreators.ts
function bindActionCreator(actionCreator, dispatch) {
    return function(...args) {
        return dispatch(actionCreator.apply(this, args));
    };
}
function bindActionCreators(actionCreators, dispatch) {
    if (typeof actionCreators === "function") {
        return bindActionCreator(actionCreators, dispatch);
    }
    if (typeof actionCreators !== "object" || actionCreators === null) {
        throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : `bindActionCreators expected an object or a function, but instead received: '${kindOf(actionCreators)}'. Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?`);
    }
    const boundActionCreators = {};
    for(const key in actionCreators){
        const actionCreator = actionCreators[key];
        if (typeof actionCreator === "function") {
            boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
        }
    }
    return boundActionCreators;
}
// src/compose.ts
function compose(...funcs) {
    if (funcs.length === 0) {
        return (arg)=>arg;
    }
    if (funcs.length === 1) {
        return funcs[0];
    }
    return funcs.reduce((a, b)=>(...args)=>a(b(...args)));
}
// src/applyMiddleware.ts
function applyMiddleware(...middlewares) {
    return (createStore2)=>(reducer, preloadedState)=>{
            const store = createStore2(reducer, preloadedState);
            let dispatch = ()=>{
                throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
            };
            const middlewareAPI = {
                getState: store.getState,
                dispatch: (action, ...args)=>dispatch(action, ...args)
            };
            const chain = middlewares.map((middleware)=>middleware(middlewareAPI));
            dispatch = compose(...chain)(store.dispatch);
            return {
                ...store,
                dispatch
            };
        };
}
// src/utils/isAction.ts
function isAction(action) {
    return isPlainObject(action) && "type" in action && typeof action.type === "string";
}
;
 //# sourceMappingURL=redux.mjs.map
}),
"[project]/node_modules/redux-immutable/dist/utilities/getStateName.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = function(action) {
    return action && action.type === '@@redux/INIT' ? 'initialState argument passed to createStore' : 'previous state received by the reducer';
};
module.exports = exports['default']; //# sourceMappingURL=getStateName.js.map
}),
"[project]/node_modules/redux-immutable/dist/utilities/getUnexpectedInvocationParameterMessage.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
var _immutable = __turbopack_context__.r("[project]/node_modules/immutable/dist/immutable.js [app-client] (ecmascript)");
var _immutable2 = _interopRequireDefault(_immutable);
var _getStateName = __turbopack_context__.r("[project]/node_modules/redux-immutable/dist/utilities/getStateName.js [app-client] (ecmascript)");
var _getStateName2 = _interopRequireDefault(_getStateName);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
exports.default = function(state, reducers, action) {
    var reducerNames = Object.keys(reducers);
    if (!reducerNames.length) {
        return 'Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.';
    }
    var stateName = (0, _getStateName2.default)(action);
    if (_immutable2.default.isImmutable ? !_immutable2.default.isImmutable(state) : !_immutable2.default.Iterable.isIterable(state)) {
        return 'The ' + stateName + ' is of unexpected type. Expected argument to be an instance of Immutable.Collection or Immutable.Record with the following properties: "' + reducerNames.join('", "') + '".';
    }
    var unexpectedStatePropertyNames = state.toSeq().keySeq().toArray().filter(function(name) {
        return !reducers.hasOwnProperty(name);
    });
    if (unexpectedStatePropertyNames.length > 0) {
        return 'Unexpected ' + (unexpectedStatePropertyNames.length === 1 ? 'property' : 'properties') + ' "' + unexpectedStatePropertyNames.join('", "') + '" found in ' + stateName + '. Expected to find one of the known reducer property names instead: "' + reducerNames.join('", "') + '". Unexpected properties will be ignored.';
    }
    return null;
};
module.exports = exports['default']; //# sourceMappingURL=getUnexpectedInvocationParameterMessage.js.map
}),
"[project]/node_modules/redux-immutable/dist/utilities/validateNextState.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = function(nextState, reducerName, action) {
    // eslint-disable-next-line no-undefined
    if (nextState === undefined) {
        throw new Error('Reducer "' + reducerName + '" returned undefined when handling "' + action.type + '" action. To ignore an action, you must explicitly return the previous state.');
    }
};
module.exports = exports['default']; //# sourceMappingURL=validateNextState.js.map
}),
"[project]/node_modules/redux-immutable/dist/utilities/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validateNextState = exports.getUnexpectedInvocationParameterMessage = exports.getStateName = undefined;
var _getStateName2 = __turbopack_context__.r("[project]/node_modules/redux-immutable/dist/utilities/getStateName.js [app-client] (ecmascript)");
var _getStateName3 = _interopRequireDefault(_getStateName2);
var _getUnexpectedInvocationParameterMessage2 = __turbopack_context__.r("[project]/node_modules/redux-immutable/dist/utilities/getUnexpectedInvocationParameterMessage.js [app-client] (ecmascript)");
var _getUnexpectedInvocationParameterMessage3 = _interopRequireDefault(_getUnexpectedInvocationParameterMessage2);
var _validateNextState2 = __turbopack_context__.r("[project]/node_modules/redux-immutable/dist/utilities/validateNextState.js [app-client] (ecmascript)");
var _validateNextState3 = _interopRequireDefault(_validateNextState2);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
exports.getStateName = _getStateName3.default;
exports.getUnexpectedInvocationParameterMessage = _getUnexpectedInvocationParameterMessage3.default;
exports.validateNextState = _validateNextState3.default; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/redux-immutable/dist/combineReducers.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _immutable = __turbopack_context__.r("[project]/node_modules/immutable/dist/immutable.js [app-client] (ecmascript)");
var _immutable2 = _interopRequireDefault(_immutable);
var _utilities = __turbopack_context__.r("[project]/node_modules/redux-immutable/dist/utilities/index.js [app-client] (ecmascript)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
exports.default = function(reducers) {
    var getDefaultState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _immutable2.default.Map;
    var reducerKeys = Object.keys(reducers);
    // eslint-disable-next-line space-infix-ops
    return function() {
        var inputState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getDefaultState();
        var action = arguments[1];
        // eslint-disable-next-line no-process-env
        if ("TURBOPACK compile-time truthy", 1) {
            var warningMessage = (0, _utilities.getUnexpectedInvocationParameterMessage)(inputState, reducers, action);
            if (warningMessage) {
                // eslint-disable-next-line no-console
                console.error(warningMessage);
            }
        }
        return inputState.withMutations(function(temporaryState) {
            reducerKeys.forEach(function(reducerName) {
                var reducer = reducers[reducerName];
                var currentDomainState = temporaryState.get(reducerName);
                var nextDomainState = reducer(currentDomainState, action);
                (0, _utilities.validateNextState)(nextDomainState, reducerName, action);
                temporaryState.set(reducerName, nextDomainState);
            });
        });
    };
};
module.exports = exports['default']; //# sourceMappingURL=combineReducers.js.map
}),
"[project]/node_modules/redux-immutable/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.combineReducers = undefined;
var _combineReducers2 = __turbopack_context__.r("[project]/node_modules/redux-immutable/dist/combineReducers.js [app-client] (ecmascript)");
var _combineReducers3 = _interopRequireDefault(_combineReducers2);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
exports.combineReducers = _combineReducers3.default; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

(function() {
    var e = {
        675: function(e, r) {
            "use strict";
            r.byteLength = byteLength;
            r.toByteArray = toByteArray;
            r.fromByteArray = fromByteArray;
            var t = [];
            var f = [];
            var n = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
            var i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            for(var o = 0, u = i.length; o < u; ++o){
                t[o] = i[o];
                f[i.charCodeAt(o)] = o;
            }
            f["-".charCodeAt(0)] = 62;
            f["_".charCodeAt(0)] = 63;
            function getLens(e) {
                var r = e.length;
                if (r % 4 > 0) {
                    throw new Error("Invalid string. Length must be a multiple of 4");
                }
                var t = e.indexOf("=");
                if (t === -1) t = r;
                var f = t === r ? 0 : 4 - t % 4;
                return [
                    t,
                    f
                ];
            }
            function byteLength(e) {
                var r = getLens(e);
                var t = r[0];
                var f = r[1];
                return (t + f) * 3 / 4 - f;
            }
            function _byteLength(e, r, t) {
                return (r + t) * 3 / 4 - t;
            }
            function toByteArray(e) {
                var r;
                var t = getLens(e);
                var i = t[0];
                var o = t[1];
                var u = new n(_byteLength(e, i, o));
                var a = 0;
                var s = o > 0 ? i - 4 : i;
                var h;
                for(h = 0; h < s; h += 4){
                    r = f[e.charCodeAt(h)] << 18 | f[e.charCodeAt(h + 1)] << 12 | f[e.charCodeAt(h + 2)] << 6 | f[e.charCodeAt(h + 3)];
                    u[a++] = r >> 16 & 255;
                    u[a++] = r >> 8 & 255;
                    u[a++] = r & 255;
                }
                if (o === 2) {
                    r = f[e.charCodeAt(h)] << 2 | f[e.charCodeAt(h + 1)] >> 4;
                    u[a++] = r & 255;
                }
                if (o === 1) {
                    r = f[e.charCodeAt(h)] << 10 | f[e.charCodeAt(h + 1)] << 4 | f[e.charCodeAt(h + 2)] >> 2;
                    u[a++] = r >> 8 & 255;
                    u[a++] = r & 255;
                }
                return u;
            }
            function tripletToBase64(e) {
                return t[e >> 18 & 63] + t[e >> 12 & 63] + t[e >> 6 & 63] + t[e & 63];
            }
            function encodeChunk(e, r, t) {
                var f;
                var n = [];
                for(var i = r; i < t; i += 3){
                    f = (e[i] << 16 & 16711680) + (e[i + 1] << 8 & 65280) + (e[i + 2] & 255);
                    n.push(tripletToBase64(f));
                }
                return n.join("");
            }
            function fromByteArray(e) {
                var r;
                var f = e.length;
                var n = f % 3;
                var i = [];
                var o = 16383;
                for(var u = 0, a = f - n; u < a; u += o){
                    i.push(encodeChunk(e, u, u + o > a ? a : u + o));
                }
                if (n === 1) {
                    r = e[f - 1];
                    i.push(t[r >> 2] + t[r << 4 & 63] + "==");
                } else if (n === 2) {
                    r = (e[f - 2] << 8) + e[f - 1];
                    i.push(t[r >> 10] + t[r >> 4 & 63] + t[r << 2 & 63] + "=");
                }
                return i.join("");
            }
        },
        72: function(e, r, t) {
            "use strict";
            /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ var f = t(675);
            var n = t(783);
            var i = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
            r.Buffer = Buffer;
            r.SlowBuffer = SlowBuffer;
            r.INSPECT_MAX_BYTES = 50;
            var o = 2147483647;
            r.kMaxLength = o;
            Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
            if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
                console.error("This browser lacks typed array (Uint8Array) support which is required by " + "`buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
            }
            function typedArraySupport() {
                try {
                    var e = new Uint8Array(1);
                    var r = {
                        foo: function() {
                            return 42;
                        }
                    };
                    Object.setPrototypeOf(r, Uint8Array.prototype);
                    Object.setPrototypeOf(e, r);
                    return e.foo() === 42;
                } catch (e) {
                    return false;
                }
            }
            Object.defineProperty(Buffer.prototype, "parent", {
                enumerable: true,
                get: function() {
                    if (!Buffer.isBuffer(this)) return undefined;
                    return this.buffer;
                }
            });
            Object.defineProperty(Buffer.prototype, "offset", {
                enumerable: true,
                get: function() {
                    if (!Buffer.isBuffer(this)) return undefined;
                    return this.byteOffset;
                }
            });
            function createBuffer(e) {
                if (e > o) {
                    throw new RangeError('The value "' + e + '" is invalid for option "size"');
                }
                var r = new Uint8Array(e);
                Object.setPrototypeOf(r, Buffer.prototype);
                return r;
            }
            function Buffer(e, r, t) {
                if (typeof e === "number") {
                    if (typeof r === "string") {
                        throw new TypeError('The "string" argument must be of type string. Received type number');
                    }
                    return allocUnsafe(e);
                }
                return from(e, r, t);
            }
            Buffer.poolSize = 8192;
            function from(e, r, t) {
                if (typeof e === "string") {
                    return fromString(e, r);
                }
                if (ArrayBuffer.isView(e)) {
                    return fromArrayLike(e);
                }
                if (e == null) {
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof e);
                }
                if (isInstance(e, ArrayBuffer) || e && isInstance(e.buffer, ArrayBuffer)) {
                    return fromArrayBuffer(e, r, t);
                }
                if (typeof SharedArrayBuffer !== "undefined" && (isInstance(e, SharedArrayBuffer) || e && isInstance(e.buffer, SharedArrayBuffer))) {
                    return fromArrayBuffer(e, r, t);
                }
                if (typeof e === "number") {
                    throw new TypeError('The "value" argument must not be of type number. Received type number');
                }
                var f = e.valueOf && e.valueOf();
                if (f != null && f !== e) {
                    return Buffer.from(f, r, t);
                }
                var n = fromObject(e);
                if (n) return n;
                if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] === "function") {
                    return Buffer.from(e[Symbol.toPrimitive]("string"), r, t);
                }
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof e);
            }
            Buffer.from = function(e, r, t) {
                return from(e, r, t);
            };
            Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
            Object.setPrototypeOf(Buffer, Uint8Array);
            function assertSize(e) {
                if (typeof e !== "number") {
                    throw new TypeError('"size" argument must be of type number');
                } else if (e < 0) {
                    throw new RangeError('The value "' + e + '" is invalid for option "size"');
                }
            }
            function alloc(e, r, t) {
                assertSize(e);
                if (e <= 0) {
                    return createBuffer(e);
                }
                if (r !== undefined) {
                    return typeof t === "string" ? createBuffer(e).fill(r, t) : createBuffer(e).fill(r);
                }
                return createBuffer(e);
            }
            Buffer.alloc = function(e, r, t) {
                return alloc(e, r, t);
            };
            function allocUnsafe(e) {
                assertSize(e);
                return createBuffer(e < 0 ? 0 : checked(e) | 0);
            }
            Buffer.allocUnsafe = function(e) {
                return allocUnsafe(e);
            };
            Buffer.allocUnsafeSlow = function(e) {
                return allocUnsafe(e);
            };
            function fromString(e, r) {
                if (typeof r !== "string" || r === "") {
                    r = "utf8";
                }
                if (!Buffer.isEncoding(r)) {
                    throw new TypeError("Unknown encoding: " + r);
                }
                var t = byteLength(e, r) | 0;
                var f = createBuffer(t);
                var n = f.write(e, r);
                if (n !== t) {
                    f = f.slice(0, n);
                }
                return f;
            }
            function fromArrayLike(e) {
                var r = e.length < 0 ? 0 : checked(e.length) | 0;
                var t = createBuffer(r);
                for(var f = 0; f < r; f += 1){
                    t[f] = e[f] & 255;
                }
                return t;
            }
            function fromArrayBuffer(e, r, t) {
                if (r < 0 || e.byteLength < r) {
                    throw new RangeError('"offset" is outside of buffer bounds');
                }
                if (e.byteLength < r + (t || 0)) {
                    throw new RangeError('"length" is outside of buffer bounds');
                }
                var f;
                if (r === undefined && t === undefined) {
                    f = new Uint8Array(e);
                } else if (t === undefined) {
                    f = new Uint8Array(e, r);
                } else {
                    f = new Uint8Array(e, r, t);
                }
                Object.setPrototypeOf(f, Buffer.prototype);
                return f;
            }
            function fromObject(e) {
                if (Buffer.isBuffer(e)) {
                    var r = checked(e.length) | 0;
                    var t = createBuffer(r);
                    if (t.length === 0) {
                        return t;
                    }
                    e.copy(t, 0, 0, r);
                    return t;
                }
                if (e.length !== undefined) {
                    if (typeof e.length !== "number" || numberIsNaN(e.length)) {
                        return createBuffer(0);
                    }
                    return fromArrayLike(e);
                }
                if (e.type === "Buffer" && Array.isArray(e.data)) {
                    return fromArrayLike(e.data);
                }
            }
            function checked(e) {
                if (e >= o) {
                    throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + o.toString(16) + " bytes");
                }
                return e | 0;
            }
            function SlowBuffer(e) {
                if (+e != e) {
                    e = 0;
                }
                return Buffer.alloc(+e);
            }
            Buffer.isBuffer = function isBuffer(e) {
                return e != null && e._isBuffer === true && e !== Buffer.prototype;
            };
            Buffer.compare = function compare(e, r) {
                if (isInstance(e, Uint8Array)) e = Buffer.from(e, e.offset, e.byteLength);
                if (isInstance(r, Uint8Array)) r = Buffer.from(r, r.offset, r.byteLength);
                if (!Buffer.isBuffer(e) || !Buffer.isBuffer(r)) {
                    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                }
                if (e === r) return 0;
                var t = e.length;
                var f = r.length;
                for(var n = 0, i = Math.min(t, f); n < i; ++n){
                    if (e[n] !== r[n]) {
                        t = e[n];
                        f = r[n];
                        break;
                    }
                }
                if (t < f) return -1;
                if (f < t) return 1;
                return 0;
            };
            Buffer.isEncoding = function isEncoding(e) {
                switch(String(e).toLowerCase()){
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return true;
                    default:
                        return false;
                }
            };
            Buffer.concat = function concat(e, r) {
                if (!Array.isArray(e)) {
                    throw new TypeError('"list" argument must be an Array of Buffers');
                }
                if (e.length === 0) {
                    return Buffer.alloc(0);
                }
                var t;
                if (r === undefined) {
                    r = 0;
                    for(t = 0; t < e.length; ++t){
                        r += e[t].length;
                    }
                }
                var f = Buffer.allocUnsafe(r);
                var n = 0;
                for(t = 0; t < e.length; ++t){
                    var i = e[t];
                    if (isInstance(i, Uint8Array)) {
                        i = Buffer.from(i);
                    }
                    if (!Buffer.isBuffer(i)) {
                        throw new TypeError('"list" argument must be an Array of Buffers');
                    }
                    i.copy(f, n);
                    n += i.length;
                }
                return f;
            };
            function byteLength(e, r) {
                if (Buffer.isBuffer(e)) {
                    return e.length;
                }
                if (ArrayBuffer.isView(e) || isInstance(e, ArrayBuffer)) {
                    return e.byteLength;
                }
                if (typeof e !== "string") {
                    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + "Received type " + typeof e);
                }
                var t = e.length;
                var f = arguments.length > 2 && arguments[2] === true;
                if (!f && t === 0) return 0;
                var n = false;
                for(;;){
                    switch(r){
                        case "ascii":
                        case "latin1":
                        case "binary":
                            return t;
                        case "utf8":
                        case "utf-8":
                            return utf8ToBytes(e).length;
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return t * 2;
                        case "hex":
                            return t >>> 1;
                        case "base64":
                            return base64ToBytes(e).length;
                        default:
                            if (n) {
                                return f ? -1 : utf8ToBytes(e).length;
                            }
                            r = ("" + r).toLowerCase();
                            n = true;
                    }
                }
            }
            Buffer.byteLength = byteLength;
            function slowToString(e, r, t) {
                var f = false;
                if (r === undefined || r < 0) {
                    r = 0;
                }
                if (r > this.length) {
                    return "";
                }
                if (t === undefined || t > this.length) {
                    t = this.length;
                }
                if (t <= 0) {
                    return "";
                }
                t >>>= 0;
                r >>>= 0;
                if (t <= r) {
                    return "";
                }
                if (!e) e = "utf8";
                while(true){
                    switch(e){
                        case "hex":
                            return hexSlice(this, r, t);
                        case "utf8":
                        case "utf-8":
                            return utf8Slice(this, r, t);
                        case "ascii":
                            return asciiSlice(this, r, t);
                        case "latin1":
                        case "binary":
                            return latin1Slice(this, r, t);
                        case "base64":
                            return base64Slice(this, r, t);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return utf16leSlice(this, r, t);
                        default:
                            if (f) throw new TypeError("Unknown encoding: " + e);
                            e = (e + "").toLowerCase();
                            f = true;
                    }
                }
            }
            Buffer.prototype._isBuffer = true;
            function swap(e, r, t) {
                var f = e[r];
                e[r] = e[t];
                e[t] = f;
            }
            Buffer.prototype.swap16 = function swap16() {
                var e = this.length;
                if (e % 2 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 16-bits");
                }
                for(var r = 0; r < e; r += 2){
                    swap(this, r, r + 1);
                }
                return this;
            };
            Buffer.prototype.swap32 = function swap32() {
                var e = this.length;
                if (e % 4 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 32-bits");
                }
                for(var r = 0; r < e; r += 4){
                    swap(this, r, r + 3);
                    swap(this, r + 1, r + 2);
                }
                return this;
            };
            Buffer.prototype.swap64 = function swap64() {
                var e = this.length;
                if (e % 8 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 64-bits");
                }
                for(var r = 0; r < e; r += 8){
                    swap(this, r, r + 7);
                    swap(this, r + 1, r + 6);
                    swap(this, r + 2, r + 5);
                    swap(this, r + 3, r + 4);
                }
                return this;
            };
            Buffer.prototype.toString = function toString() {
                var e = this.length;
                if (e === 0) return "";
                if (arguments.length === 0) return utf8Slice(this, 0, e);
                return slowToString.apply(this, arguments);
            };
            Buffer.prototype.toLocaleString = Buffer.prototype.toString;
            Buffer.prototype.equals = function equals(e) {
                if (!Buffer.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
                if (this === e) return true;
                return Buffer.compare(this, e) === 0;
            };
            Buffer.prototype.inspect = function inspect() {
                var e = "";
                var t = r.INSPECT_MAX_BYTES;
                e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim();
                if (this.length > t) e += " ... ";
                return "<Buffer " + e + ">";
            };
            if (i) {
                Buffer.prototype[i] = Buffer.prototype.inspect;
            }
            Buffer.prototype.compare = function compare(e, r, t, f, n) {
                if (isInstance(e, Uint8Array)) {
                    e = Buffer.from(e, e.offset, e.byteLength);
                }
                if (!Buffer.isBuffer(e)) {
                    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + "Received type " + typeof e);
                }
                if (r === undefined) {
                    r = 0;
                }
                if (t === undefined) {
                    t = e ? e.length : 0;
                }
                if (f === undefined) {
                    f = 0;
                }
                if (n === undefined) {
                    n = this.length;
                }
                if (r < 0 || t > e.length || f < 0 || n > this.length) {
                    throw new RangeError("out of range index");
                }
                if (f >= n && r >= t) {
                    return 0;
                }
                if (f >= n) {
                    return -1;
                }
                if (r >= t) {
                    return 1;
                }
                r >>>= 0;
                t >>>= 0;
                f >>>= 0;
                n >>>= 0;
                if (this === e) return 0;
                var i = n - f;
                var o = t - r;
                var u = Math.min(i, o);
                var a = this.slice(f, n);
                var s = e.slice(r, t);
                for(var h = 0; h < u; ++h){
                    if (a[h] !== s[h]) {
                        i = a[h];
                        o = s[h];
                        break;
                    }
                }
                if (i < o) return -1;
                if (o < i) return 1;
                return 0;
            };
            function bidirectionalIndexOf(e, r, t, f, n) {
                if (e.length === 0) return -1;
                if (typeof t === "string") {
                    f = t;
                    t = 0;
                } else if (t > 2147483647) {
                    t = 2147483647;
                } else if (t < -2147483648) {
                    t = -2147483648;
                }
                t = +t;
                if (numberIsNaN(t)) {
                    t = n ? 0 : e.length - 1;
                }
                if (t < 0) t = e.length + t;
                if (t >= e.length) {
                    if (n) return -1;
                    else t = e.length - 1;
                } else if (t < 0) {
                    if (n) t = 0;
                    else return -1;
                }
                if (typeof r === "string") {
                    r = Buffer.from(r, f);
                }
                if (Buffer.isBuffer(r)) {
                    if (r.length === 0) {
                        return -1;
                    }
                    return arrayIndexOf(e, r, t, f, n);
                } else if (typeof r === "number") {
                    r = r & 255;
                    if (typeof Uint8Array.prototype.indexOf === "function") {
                        if (n) {
                            return Uint8Array.prototype.indexOf.call(e, r, t);
                        } else {
                            return Uint8Array.prototype.lastIndexOf.call(e, r, t);
                        }
                    }
                    return arrayIndexOf(e, [
                        r
                    ], t, f, n);
                }
                throw new TypeError("val must be string, number or Buffer");
            }
            function arrayIndexOf(e, r, t, f, n) {
                var i = 1;
                var o = e.length;
                var u = r.length;
                if (f !== undefined) {
                    f = String(f).toLowerCase();
                    if (f === "ucs2" || f === "ucs-2" || f === "utf16le" || f === "utf-16le") {
                        if (e.length < 2 || r.length < 2) {
                            return -1;
                        }
                        i = 2;
                        o /= 2;
                        u /= 2;
                        t /= 2;
                    }
                }
                function read(e, r) {
                    if (i === 1) {
                        return e[r];
                    } else {
                        return e.readUInt16BE(r * i);
                    }
                }
                var a;
                if (n) {
                    var s = -1;
                    for(a = t; a < o; a++){
                        if (read(e, a) === read(r, s === -1 ? 0 : a - s)) {
                            if (s === -1) s = a;
                            if (a - s + 1 === u) return s * i;
                        } else {
                            if (s !== -1) a -= a - s;
                            s = -1;
                        }
                    }
                } else {
                    if (t + u > o) t = o - u;
                    for(a = t; a >= 0; a--){
                        var h = true;
                        for(var c = 0; c < u; c++){
                            if (read(e, a + c) !== read(r, c)) {
                                h = false;
                                break;
                            }
                        }
                        if (h) return a;
                    }
                }
                return -1;
            }
            Buffer.prototype.includes = function includes(e, r, t) {
                return this.indexOf(e, r, t) !== -1;
            };
            Buffer.prototype.indexOf = function indexOf(e, r, t) {
                return bidirectionalIndexOf(this, e, r, t, true);
            };
            Buffer.prototype.lastIndexOf = function lastIndexOf(e, r, t) {
                return bidirectionalIndexOf(this, e, r, t, false);
            };
            function hexWrite(e, r, t, f) {
                t = Number(t) || 0;
                var n = e.length - t;
                if (!f) {
                    f = n;
                } else {
                    f = Number(f);
                    if (f > n) {
                        f = n;
                    }
                }
                var i = r.length;
                if (f > i / 2) {
                    f = i / 2;
                }
                for(var o = 0; o < f; ++o){
                    var u = parseInt(r.substr(o * 2, 2), 16);
                    if (numberIsNaN(u)) return o;
                    e[t + o] = u;
                }
                return o;
            }
            function utf8Write(e, r, t, f) {
                return blitBuffer(utf8ToBytes(r, e.length - t), e, t, f);
            }
            function asciiWrite(e, r, t, f) {
                return blitBuffer(asciiToBytes(r), e, t, f);
            }
            function latin1Write(e, r, t, f) {
                return asciiWrite(e, r, t, f);
            }
            function base64Write(e, r, t, f) {
                return blitBuffer(base64ToBytes(r), e, t, f);
            }
            function ucs2Write(e, r, t, f) {
                return blitBuffer(utf16leToBytes(r, e.length - t), e, t, f);
            }
            Buffer.prototype.write = function write(e, r, t, f) {
                if (r === undefined) {
                    f = "utf8";
                    t = this.length;
                    r = 0;
                } else if (t === undefined && typeof r === "string") {
                    f = r;
                    t = this.length;
                    r = 0;
                } else if (isFinite(r)) {
                    r = r >>> 0;
                    if (isFinite(t)) {
                        t = t >>> 0;
                        if (f === undefined) f = "utf8";
                    } else {
                        f = t;
                        t = undefined;
                    }
                } else {
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                }
                var n = this.length - r;
                if (t === undefined || t > n) t = n;
                if (e.length > 0 && (t < 0 || r < 0) || r > this.length) {
                    throw new RangeError("Attempt to write outside buffer bounds");
                }
                if (!f) f = "utf8";
                var i = false;
                for(;;){
                    switch(f){
                        case "hex":
                            return hexWrite(this, e, r, t);
                        case "utf8":
                        case "utf-8":
                            return utf8Write(this, e, r, t);
                        case "ascii":
                            return asciiWrite(this, e, r, t);
                        case "latin1":
                        case "binary":
                            return latin1Write(this, e, r, t);
                        case "base64":
                            return base64Write(this, e, r, t);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return ucs2Write(this, e, r, t);
                        default:
                            if (i) throw new TypeError("Unknown encoding: " + f);
                            f = ("" + f).toLowerCase();
                            i = true;
                    }
                }
            };
            Buffer.prototype.toJSON = function toJSON() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                };
            };
            function base64Slice(e, r, t) {
                if (r === 0 && t === e.length) {
                    return f.fromByteArray(e);
                } else {
                    return f.fromByteArray(e.slice(r, t));
                }
            }
            function utf8Slice(e, r, t) {
                t = Math.min(e.length, t);
                var f = [];
                var n = r;
                while(n < t){
                    var i = e[n];
                    var o = null;
                    var u = i > 239 ? 4 : i > 223 ? 3 : i > 191 ? 2 : 1;
                    if (n + u <= t) {
                        var a, s, h, c;
                        switch(u){
                            case 1:
                                if (i < 128) {
                                    o = i;
                                }
                                break;
                            case 2:
                                a = e[n + 1];
                                if ((a & 192) === 128) {
                                    c = (i & 31) << 6 | a & 63;
                                    if (c > 127) {
                                        o = c;
                                    }
                                }
                                break;
                            case 3:
                                a = e[n + 1];
                                s = e[n + 2];
                                if ((a & 192) === 128 && (s & 192) === 128) {
                                    c = (i & 15) << 12 | (a & 63) << 6 | s & 63;
                                    if (c > 2047 && (c < 55296 || c > 57343)) {
                                        o = c;
                                    }
                                }
                                break;
                            case 4:
                                a = e[n + 1];
                                s = e[n + 2];
                                h = e[n + 3];
                                if ((a & 192) === 128 && (s & 192) === 128 && (h & 192) === 128) {
                                    c = (i & 15) << 18 | (a & 63) << 12 | (s & 63) << 6 | h & 63;
                                    if (c > 65535 && c < 1114112) {
                                        o = c;
                                    }
                                }
                        }
                    }
                    if (o === null) {
                        o = 65533;
                        u = 1;
                    } else if (o > 65535) {
                        o -= 65536;
                        f.push(o >>> 10 & 1023 | 55296);
                        o = 56320 | o & 1023;
                    }
                    f.push(o);
                    n += u;
                }
                return decodeCodePointsArray(f);
            }
            var u = 4096;
            function decodeCodePointsArray(e) {
                var r = e.length;
                if (r <= u) {
                    return String.fromCharCode.apply(String, e);
                }
                var t = "";
                var f = 0;
                while(f < r){
                    t += String.fromCharCode.apply(String, e.slice(f, f += u));
                }
                return t;
            }
            function asciiSlice(e, r, t) {
                var f = "";
                t = Math.min(e.length, t);
                for(var n = r; n < t; ++n){
                    f += String.fromCharCode(e[n] & 127);
                }
                return f;
            }
            function latin1Slice(e, r, t) {
                var f = "";
                t = Math.min(e.length, t);
                for(var n = r; n < t; ++n){
                    f += String.fromCharCode(e[n]);
                }
                return f;
            }
            function hexSlice(e, r, t) {
                var f = e.length;
                if (!r || r < 0) r = 0;
                if (!t || t < 0 || t > f) t = f;
                var n = "";
                for(var i = r; i < t; ++i){
                    n += s[e[i]];
                }
                return n;
            }
            function utf16leSlice(e, r, t) {
                var f = e.slice(r, t);
                var n = "";
                for(var i = 0; i < f.length; i += 2){
                    n += String.fromCharCode(f[i] + f[i + 1] * 256);
                }
                return n;
            }
            Buffer.prototype.slice = function slice(e, r) {
                var t = this.length;
                e = ~~e;
                r = r === undefined ? t : ~~r;
                if (e < 0) {
                    e += t;
                    if (e < 0) e = 0;
                } else if (e > t) {
                    e = t;
                }
                if (r < 0) {
                    r += t;
                    if (r < 0) r = 0;
                } else if (r > t) {
                    r = t;
                }
                if (r < e) r = e;
                var f = this.subarray(e, r);
                Object.setPrototypeOf(f, Buffer.prototype);
                return f;
            };
            function checkOffset(e, r, t) {
                if (e % 1 !== 0 || e < 0) throw new RangeError("offset is not uint");
                if (e + r > t) throw new RangeError("Trying to access beyond buffer length");
            }
            Buffer.prototype.readUIntLE = function readUIntLE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = this[e];
                var n = 1;
                var i = 0;
                while(++i < r && (n *= 256)){
                    f += this[e + i] * n;
                }
                return f;
            };
            Buffer.prototype.readUIntBE = function readUIntBE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) {
                    checkOffset(e, r, this.length);
                }
                var f = this[e + --r];
                var n = 1;
                while(r > 0 && (n *= 256)){
                    f += this[e + --r] * n;
                }
                return f;
            };
            Buffer.prototype.readUInt8 = function readUInt8(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 1, this.length);
                return this[e];
            };
            Buffer.prototype.readUInt16LE = function readUInt16LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                return this[e] | this[e + 1] << 8;
            };
            Buffer.prototype.readUInt16BE = function readUInt16BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                return this[e] << 8 | this[e + 1];
            };
            Buffer.prototype.readUInt32LE = function readUInt32LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
            };
            Buffer.prototype.readUInt32BE = function readUInt32BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
            };
            Buffer.prototype.readIntLE = function readIntLE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = this[e];
                var n = 1;
                var i = 0;
                while(++i < r && (n *= 256)){
                    f += this[e + i] * n;
                }
                n *= 128;
                if (f >= n) f -= Math.pow(2, 8 * r);
                return f;
            };
            Buffer.prototype.readIntBE = function readIntBE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = r;
                var n = 1;
                var i = this[e + --f];
                while(f > 0 && (n *= 256)){
                    i += this[e + --f] * n;
                }
                n *= 128;
                if (i >= n) i -= Math.pow(2, 8 * r);
                return i;
            };
            Buffer.prototype.readInt8 = function readInt8(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 1, this.length);
                if (!(this[e] & 128)) return this[e];
                return (255 - this[e] + 1) * -1;
            };
            Buffer.prototype.readInt16LE = function readInt16LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                var t = this[e] | this[e + 1] << 8;
                return t & 32768 ? t | 4294901760 : t;
            };
            Buffer.prototype.readInt16BE = function readInt16BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                var t = this[e + 1] | this[e] << 8;
                return t & 32768 ? t | 4294901760 : t;
            };
            Buffer.prototype.readInt32LE = function readInt32LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
            };
            Buffer.prototype.readInt32BE = function readInt32BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
            };
            Buffer.prototype.readFloatLE = function readFloatLE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return n.read(this, e, true, 23, 4);
            };
            Buffer.prototype.readFloatBE = function readFloatBE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return n.read(this, e, false, 23, 4);
            };
            Buffer.prototype.readDoubleLE = function readDoubleLE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 8, this.length);
                return n.read(this, e, true, 52, 8);
            };
            Buffer.prototype.readDoubleBE = function readDoubleBE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 8, this.length);
                return n.read(this, e, false, 52, 8);
            };
            function checkInt(e, r, t, f, n, i) {
                if (!Buffer.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
                if (r > n || r < i) throw new RangeError('"value" argument is out of bounds');
                if (t + f > e.length) throw new RangeError("Index out of range");
            }
            Buffer.prototype.writeUIntLE = function writeUIntLE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                t = t >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t) - 1;
                    checkInt(this, e, r, t, n, 0);
                }
                var i = 1;
                var o = 0;
                this[r] = e & 255;
                while(++o < t && (i *= 256)){
                    this[r + o] = e / i & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeUIntBE = function writeUIntBE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                t = t >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t) - 1;
                    checkInt(this, e, r, t, n, 0);
                }
                var i = t - 1;
                var o = 1;
                this[r + i] = e & 255;
                while(--i >= 0 && (o *= 256)){
                    this[r + i] = e / o & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeUInt8 = function writeUInt8(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 1, 255, 0);
                this[r] = e & 255;
                return r + 1;
            };
            Buffer.prototype.writeUInt16LE = function writeUInt16LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 65535, 0);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                return r + 2;
            };
            Buffer.prototype.writeUInt16BE = function writeUInt16BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 65535, 0);
                this[r] = e >>> 8;
                this[r + 1] = e & 255;
                return r + 2;
            };
            Buffer.prototype.writeUInt32LE = function writeUInt32LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 4294967295, 0);
                this[r + 3] = e >>> 24;
                this[r + 2] = e >>> 16;
                this[r + 1] = e >>> 8;
                this[r] = e & 255;
                return r + 4;
            };
            Buffer.prototype.writeUInt32BE = function writeUInt32BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 4294967295, 0);
                this[r] = e >>> 24;
                this[r + 1] = e >>> 16;
                this[r + 2] = e >>> 8;
                this[r + 3] = e & 255;
                return r + 4;
            };
            Buffer.prototype.writeIntLE = function writeIntLE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t - 1);
                    checkInt(this, e, r, t, n - 1, -n);
                }
                var i = 0;
                var o = 1;
                var u = 0;
                this[r] = e & 255;
                while(++i < t && (o *= 256)){
                    if (e < 0 && u === 0 && this[r + i - 1] !== 0) {
                        u = 1;
                    }
                    this[r + i] = (e / o >> 0) - u & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeIntBE = function writeIntBE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t - 1);
                    checkInt(this, e, r, t, n - 1, -n);
                }
                var i = t - 1;
                var o = 1;
                var u = 0;
                this[r + i] = e & 255;
                while(--i >= 0 && (o *= 256)){
                    if (e < 0 && u === 0 && this[r + i + 1] !== 0) {
                        u = 1;
                    }
                    this[r + i] = (e / o >> 0) - u & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeInt8 = function writeInt8(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 1, 127, -128);
                if (e < 0) e = 255 + e + 1;
                this[r] = e & 255;
                return r + 1;
            };
            Buffer.prototype.writeInt16LE = function writeInt16LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 32767, -32768);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                return r + 2;
            };
            Buffer.prototype.writeInt16BE = function writeInt16BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 32767, -32768);
                this[r] = e >>> 8;
                this[r + 1] = e & 255;
                return r + 2;
            };
            Buffer.prototype.writeInt32LE = function writeInt32LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                this[r + 2] = e >>> 16;
                this[r + 3] = e >>> 24;
                return r + 4;
            };
            Buffer.prototype.writeInt32BE = function writeInt32BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);
                if (e < 0) e = 4294967295 + e + 1;
                this[r] = e >>> 24;
                this[r + 1] = e >>> 16;
                this[r + 2] = e >>> 8;
                this[r + 3] = e & 255;
                return r + 4;
            };
            function checkIEEE754(e, r, t, f, n, i) {
                if (t + f > e.length) throw new RangeError("Index out of range");
                if (t < 0) throw new RangeError("Index out of range");
            }
            function writeFloat(e, r, t, f, i) {
                r = +r;
                t = t >>> 0;
                if (!i) {
                    checkIEEE754(e, r, t, 4, 34028234663852886e22, -34028234663852886e22);
                }
                n.write(e, r, t, f, 23, 4);
                return t + 4;
            }
            Buffer.prototype.writeFloatLE = function writeFloatLE(e, r, t) {
                return writeFloat(this, e, r, true, t);
            };
            Buffer.prototype.writeFloatBE = function writeFloatBE(e, r, t) {
                return writeFloat(this, e, r, false, t);
            };
            function writeDouble(e, r, t, f, i) {
                r = +r;
                t = t >>> 0;
                if (!i) {
                    checkIEEE754(e, r, t, 8, 17976931348623157e292, -17976931348623157e292);
                }
                n.write(e, r, t, f, 52, 8);
                return t + 8;
            }
            Buffer.prototype.writeDoubleLE = function writeDoubleLE(e, r, t) {
                return writeDouble(this, e, r, true, t);
            };
            Buffer.prototype.writeDoubleBE = function writeDoubleBE(e, r, t) {
                return writeDouble(this, e, r, false, t);
            };
            Buffer.prototype.copy = function copy(e, r, t, f) {
                if (!Buffer.isBuffer(e)) throw new TypeError("argument should be a Buffer");
                if (!t) t = 0;
                if (!f && f !== 0) f = this.length;
                if (r >= e.length) r = e.length;
                if (!r) r = 0;
                if (f > 0 && f < t) f = t;
                if (f === t) return 0;
                if (e.length === 0 || this.length === 0) return 0;
                if (r < 0) {
                    throw new RangeError("targetStart out of bounds");
                }
                if (t < 0 || t >= this.length) throw new RangeError("Index out of range");
                if (f < 0) throw new RangeError("sourceEnd out of bounds");
                if (f > this.length) f = this.length;
                if (e.length - r < f - t) {
                    f = e.length - r + t;
                }
                var n = f - t;
                if (this === e && typeof Uint8Array.prototype.copyWithin === "function") {
                    this.copyWithin(r, t, f);
                } else if (this === e && t < r && r < f) {
                    for(var i = n - 1; i >= 0; --i){
                        e[i + r] = this[i + t];
                    }
                } else {
                    Uint8Array.prototype.set.call(e, this.subarray(t, f), r);
                }
                return n;
            };
            Buffer.prototype.fill = function fill(e, r, t, f) {
                if (typeof e === "string") {
                    if (typeof r === "string") {
                        f = r;
                        r = 0;
                        t = this.length;
                    } else if (typeof t === "string") {
                        f = t;
                        t = this.length;
                    }
                    if (f !== undefined && typeof f !== "string") {
                        throw new TypeError("encoding must be a string");
                    }
                    if (typeof f === "string" && !Buffer.isEncoding(f)) {
                        throw new TypeError("Unknown encoding: " + f);
                    }
                    if (e.length === 1) {
                        var n = e.charCodeAt(0);
                        if (f === "utf8" && n < 128 || f === "latin1") {
                            e = n;
                        }
                    }
                } else if (typeof e === "number") {
                    e = e & 255;
                } else if (typeof e === "boolean") {
                    e = Number(e);
                }
                if (r < 0 || this.length < r || this.length < t) {
                    throw new RangeError("Out of range index");
                }
                if (t <= r) {
                    return this;
                }
                r = r >>> 0;
                t = t === undefined ? this.length : t >>> 0;
                if (!e) e = 0;
                var i;
                if (typeof e === "number") {
                    for(i = r; i < t; ++i){
                        this[i] = e;
                    }
                } else {
                    var o = Buffer.isBuffer(e) ? e : Buffer.from(e, f);
                    var u = o.length;
                    if (u === 0) {
                        throw new TypeError('The value "' + e + '" is invalid for argument "value"');
                    }
                    for(i = 0; i < t - r; ++i){
                        this[i + r] = o[i % u];
                    }
                }
                return this;
            };
            var a = /[^+/0-9A-Za-z-_]/g;
            function base64clean(e) {
                e = e.split("=")[0];
                e = e.trim().replace(a, "");
                if (e.length < 2) return "";
                while(e.length % 4 !== 0){
                    e = e + "=";
                }
                return e;
            }
            function utf8ToBytes(e, r) {
                r = r || Infinity;
                var t;
                var f = e.length;
                var n = null;
                var i = [];
                for(var o = 0; o < f; ++o){
                    t = e.charCodeAt(o);
                    if (t > 55295 && t < 57344) {
                        if (!n) {
                            if (t > 56319) {
                                if ((r -= 3) > -1) i.push(239, 191, 189);
                                continue;
                            } else if (o + 1 === f) {
                                if ((r -= 3) > -1) i.push(239, 191, 189);
                                continue;
                            }
                            n = t;
                            continue;
                        }
                        if (t < 56320) {
                            if ((r -= 3) > -1) i.push(239, 191, 189);
                            n = t;
                            continue;
                        }
                        t = (n - 55296 << 10 | t - 56320) + 65536;
                    } else if (n) {
                        if ((r -= 3) > -1) i.push(239, 191, 189);
                    }
                    n = null;
                    if (t < 128) {
                        if ((r -= 1) < 0) break;
                        i.push(t);
                    } else if (t < 2048) {
                        if ((r -= 2) < 0) break;
                        i.push(t >> 6 | 192, t & 63 | 128);
                    } else if (t < 65536) {
                        if ((r -= 3) < 0) break;
                        i.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
                    } else if (t < 1114112) {
                        if ((r -= 4) < 0) break;
                        i.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
                    } else {
                        throw new Error("Invalid code point");
                    }
                }
                return i;
            }
            function asciiToBytes(e) {
                var r = [];
                for(var t = 0; t < e.length; ++t){
                    r.push(e.charCodeAt(t) & 255);
                }
                return r;
            }
            function utf16leToBytes(e, r) {
                var t, f, n;
                var i = [];
                for(var o = 0; o < e.length; ++o){
                    if ((r -= 2) < 0) break;
                    t = e.charCodeAt(o);
                    f = t >> 8;
                    n = t % 256;
                    i.push(n);
                    i.push(f);
                }
                return i;
            }
            function base64ToBytes(e) {
                return f.toByteArray(base64clean(e));
            }
            function blitBuffer(e, r, t, f) {
                for(var n = 0; n < f; ++n){
                    if (n + t >= r.length || n >= e.length) break;
                    r[n + t] = e[n];
                }
                return n;
            }
            function isInstance(e, r) {
                return e instanceof r || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === r.name;
            }
            function numberIsNaN(e) {
                return e !== e;
            }
            var s = function() {
                var e = "0123456789abcdef";
                var r = new Array(256);
                for(var t = 0; t < 16; ++t){
                    var f = t * 16;
                    for(var n = 0; n < 16; ++n){
                        r[f + n] = e[t] + e[n];
                    }
                }
                return r;
            }();
        },
        783: function(e, r) {
            /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ r.read = function(e, r, t, f, n) {
                var i, o;
                var u = n * 8 - f - 1;
                var a = (1 << u) - 1;
                var s = a >> 1;
                var h = -7;
                var c = t ? n - 1 : 0;
                var l = t ? -1 : 1;
                var p = e[r + c];
                c += l;
                i = p & (1 << -h) - 1;
                p >>= -h;
                h += u;
                for(; h > 0; i = i * 256 + e[r + c], c += l, h -= 8){}
                o = i & (1 << -h) - 1;
                i >>= -h;
                h += f;
                for(; h > 0; o = o * 256 + e[r + c], c += l, h -= 8){}
                if (i === 0) {
                    i = 1 - s;
                } else if (i === a) {
                    return o ? NaN : (p ? -1 : 1) * Infinity;
                } else {
                    o = o + Math.pow(2, f);
                    i = i - s;
                }
                return (p ? -1 : 1) * o * Math.pow(2, i - f);
            };
            r.write = function(e, r, t, f, n, i) {
                var o, u, a;
                var s = i * 8 - n - 1;
                var h = (1 << s) - 1;
                var c = h >> 1;
                var l = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
                var p = f ? 0 : i - 1;
                var y = f ? 1 : -1;
                var g = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
                r = Math.abs(r);
                if (isNaN(r) || r === Infinity) {
                    u = isNaN(r) ? 1 : 0;
                    o = h;
                } else {
                    o = Math.floor(Math.log(r) / Math.LN2);
                    if (r * (a = Math.pow(2, -o)) < 1) {
                        o--;
                        a *= 2;
                    }
                    if (o + c >= 1) {
                        r += l / a;
                    } else {
                        r += l * Math.pow(2, 1 - c);
                    }
                    if (r * a >= 2) {
                        o++;
                        a /= 2;
                    }
                    if (o + c >= h) {
                        u = 0;
                        o = h;
                    } else if (o + c >= 1) {
                        u = (r * a - 1) * Math.pow(2, n);
                        o = o + c;
                    } else {
                        u = r * Math.pow(2, c - 1) * Math.pow(2, n);
                        o = 0;
                    }
                }
                for(; n >= 8; e[t + p] = u & 255, p += y, u /= 256, n -= 8){}
                o = o << n | u;
                s += n;
                for(; s > 0; e[t + p] = o & 255, p += y, o /= 256, s -= 8){}
                e[t + p - y] |= g * 128;
            };
        }
    };
    var r = {};
    function __nccwpck_require__(t) {
        var f = r[t];
        if (f !== undefined) {
            return f.exports;
        }
        var n = r[t] = {
            exports: {}
        };
        var i = true;
        try {
            e[t](n, n.exports, __nccwpck_require__);
            i = false;
        } finally{
            if (i) delete r[t];
        }
        return n.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/buffer") + "/";
    var t = __nccwpck_require__(72);
    module.exports = t;
})();
}),
"[project]/node_modules/next/dist/build/polyfills/object-assign.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var assign = Object.assign.bind(Object);
module.exports = assign;
module.exports.default = module.exports; //# sourceMappingURL=object-assign.js.map
}),
"[project]/node_modules/serialize-error/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
'use strict';
class NonError extends Error {
    constructor(message){
        super(NonError._prepareSuperMessage(message));
        Object.defineProperty(this, 'name', {
            value: 'NonError',
            configurable: true,
            writable: true
        });
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, NonError);
        }
    }
    static _prepareSuperMessage(message) {
        try {
            return JSON.stringify(message);
        } catch  {
            return String(message);
        }
    }
}
const commonProperties = [
    {
        property: 'name',
        enumerable: false
    },
    {
        property: 'message',
        enumerable: false
    },
    {
        property: 'stack',
        enumerable: false
    },
    {
        property: 'code',
        enumerable: true
    }
];
const isCalled = Symbol('.toJSON called');
const toJSON = (from)=>{
    from[isCalled] = true;
    const json = from.toJSON();
    delete from[isCalled];
    return json;
};
const destroyCircular = ({ from, seen, to_, forceEnumerable, maxDepth, depth })=>{
    const to = to_ || (Array.isArray(from) ? [] : {});
    seen.push(from);
    if (depth >= maxDepth) {
        return to;
    }
    if (typeof from.toJSON === 'function' && from[isCalled] !== true) {
        return toJSON(from);
    }
    for (const [key, value] of Object.entries(from)){
        if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"] === 'function' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(value)) {
            to[key] = '[object Buffer]';
            continue;
        }
        if (typeof value === 'function') {
            continue;
        }
        if (!value || typeof value !== 'object') {
            to[key] = value;
            continue;
        }
        if (!seen.includes(from[key])) {
            depth++;
            to[key] = destroyCircular({
                from: from[key],
                seen: seen.slice(),
                forceEnumerable,
                maxDepth,
                depth
            });
            continue;
        }
        to[key] = '[Circular]';
    }
    for (const { property, enumerable } of commonProperties){
        if (typeof from[property] === 'string') {
            Object.defineProperty(to, property, {
                value: from[property],
                enumerable: forceEnumerable ? true : enumerable,
                configurable: true,
                writable: true
            });
        }
    }
    return to;
};
const serializeError = (value, options = {})=>{
    const { maxDepth = Number.POSITIVE_INFINITY } = options;
    if (typeof value === 'object' && value !== null) {
        return destroyCircular({
            from: value,
            seen: [],
            forceEnumerable: true,
            maxDepth,
            depth: 0
        });
    }
    // People sometimes throw things besides Error objects
    if (typeof value === 'function') {
        // `JSON.stringify()` discards functions. We do too, unless a function is thrown directly.
        return `[Function: ${value.name || 'anonymous'}]`;
    }
    return value;
};
const deserializeError = (value, options = {})=>{
    const { maxDepth = Number.POSITIVE_INFINITY } = options;
    if (value instanceof Error) {
        return value;
    }
    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        const newError = new Error(); // eslint-disable-line unicorn/error-message
        destroyCircular({
            from: value,
            seen: [],
            to_: newError,
            maxDepth,
            depth: 0
        });
        return newError;
    }
    return new NonError(value);
};
module.exports = {
    serializeError,
    deserializeError
};
}),
"[project]/node_modules/css.escape/css.escape.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license */ ;
(function(root, factory) {
    // https://github.com/umdjs/umd/blob/master/returnExports.js
    if ("TURBOPACK compile-time truthy", 1) {
        // For Node.js.
        module.exports = factory(root);
    } else //TURBOPACK unreachable
    ;
})(("TURBOPACK compile-time truthy", 1) ? /*TURBOPACK member replacement*/ __turbopack_context__.g : "TURBOPACK unreachable", function(root) {
    if (root.CSS && root.CSS.escape) {
        return root.CSS.escape;
    }
    // https://drafts.csswg.org/cssom/#serialize-an-identifier
    var cssEscape = function(value) {
        if (arguments.length == 0) {
            throw new TypeError('`CSS.escape` requires an argument.');
        }
        var string = String(value);
        var length = string.length;
        var index = -1;
        var codeUnit;
        var result = '';
        var firstCodeUnit = string.charCodeAt(0);
        while(++index < length){
            codeUnit = string.charCodeAt(index);
            // Note: theres no need to special-case astral symbols, surrogate
            // pairs, or lone surrogates.
            // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
            // (U+FFFD).
            if (codeUnit == 0x0000) {
                result += '\uFFFD';
                continue;
            }
            if (// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
            // U+007F, []
            codeUnit >= 0x0001 && codeUnit <= 0x001F || codeUnit == 0x007F || index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039 || index == 1 && codeUnit >= 0x0030 && codeUnit <= 0x0039 && firstCodeUnit == 0x002D) {
                // https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
                result += '\\' + codeUnit.toString(16) + ' ';
                continue;
            }
            if (// If the character is the first character and is a `-` (U+002D), and
            // there is no second character, []
            index == 0 && length == 1 && codeUnit == 0x002D) {
                result += '\\' + string.charAt(index);
                continue;
            }
            // If the character is not handled by one of the above rules and is
            // greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
            // is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
            // U+005A), or [a-z] (U+0061 to U+007A), []
            if (codeUnit >= 0x0080 || codeUnit == 0x002D || codeUnit == 0x005F || codeUnit >= 0x0030 && codeUnit <= 0x0039 || codeUnit >= 0x0041 && codeUnit <= 0x005A || codeUnit >= 0x0061 && codeUnit <= 0x007A) {
                // the character itself
                result += string.charAt(index);
                continue;
            }
            // Otherwise, the escaped character.
            // https://drafts.csswg.org/cssom/#escape-a-character
            result += '\\' + string.charAt(index);
        }
        return result;
    };
    if (!root.CSS) {
        root.CSS = {};
    }
    root.CSS.escape = cssEscape;
    return cssEscape;
});
}),
"[project]/node_modules/requires-port/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */ module.exports = function required(port, protocol) {
    protocol = protocol.split(':')[0];
    port = +port;
    if (!port) return false;
    switch(protocol){
        case 'http':
        case 'ws':
            return port !== 80;
        case 'https':
        case 'wss':
            return port !== 443;
        case 'ftp':
            return port !== 21;
        case 'gopher':
            return port !== 70;
        case 'file':
            return false;
    }
    return port !== 0;
};
}),
"[project]/node_modules/querystringify/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var has = Object.prototype.hasOwnProperty, undef;
/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */ function decode(input) {
    try {
        return decodeURIComponent(input.replace(/\+/g, ' '));
    } catch (e) {
        return null;
    }
}
/**
 * Attempts to encode a given input.
 *
 * @param {String} input The string that needs to be encoded.
 * @returns {String|Null} The encoded string.
 * @api private
 */ function encode(input) {
    try {
        return encodeURIComponent(input);
    } catch (e) {
        return null;
    }
}
/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */ function querystring(query) {
    var parser = /([^=?#&]+)=?([^&]*)/g, result = {}, part;
    while(part = parser.exec(query)){
        var key = decode(part[1]), value = decode(part[2]);
        //
        // Prevent overriding of existing properties. This ensures that build-in
        // methods like `toString` or __proto__ are not overriden by malicious
        // querystrings.
        //
        // In the case if failed decoding, we want to omit the key/value pairs
        // from the result.
        //
        if (key === null || value === null || key in result) continue;
        result[key] = value;
    }
    return result;
}
/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */ function querystringify(obj, prefix) {
    prefix = prefix || '';
    var pairs = [], value, key;
    //
    // Optionally prefix with a '?' if needed
    //
    if ('string' !== typeof prefix) prefix = '?';
    for(key in obj){
        if (has.call(obj, key)) {
            value = obj[key];
            //
            // Edge cases where we actually want to encode the value to an empty
            // string instead of the stringified value.
            //
            if (!value && (value === null || value === undef || isNaN(value))) {
                value = '';
            }
            key = encode(key);
            value = encode(value);
            //
            // If we failed to encode the strings, we should bail out as we don't
            // want to add invalid strings to the query.
            //
            if (key === null || value === null) continue;
            pairs.push(key + '=' + value);
        }
    }
    return pairs.length ? prefix + pairs.join('&') : '';
}
//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;
}),
"[project]/node_modules/url-parse/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var required = __turbopack_context__.r("[project]/node_modules/requires-port/index.js [app-client] (ecmascript)"), qs = __turbopack_context__.r("[project]/node_modules/querystringify/index.js [app-client] (ecmascript)"), controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/, CRHTLF = /[\n\r\t]/g, slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//, port = /:\d+$/, protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i, windowsDriveLetter = /^[a-zA-Z]:/;
/**
 * Remove control characters and whitespace from the beginning of a string.
 *
 * @param {Object|String} str String to trim.
 * @returns {String} A new string representing `str` stripped of control
 *     characters and whitespace from its beginning.
 * @public
 */ function trimLeft(str) {
    return (str ? str : '').toString().replace(controlOrWhitespace, '');
}
/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */ var rules = [
    [
        '#',
        'hash'
    ],
    [
        '?',
        'query'
    ],
    function sanitize(address, url) {
        return isSpecial(url.protocol) ? address.replace(/\\/g, '/') : address;
    },
    [
        '/',
        'pathname'
    ],
    [
        '@',
        'auth',
        1
    ],
    [
        NaN,
        'host',
        undefined,
        1,
        1
    ],
    [
        /:(\d*)$/,
        'port',
        undefined,
        1
    ],
    [
        NaN,
        'hostname',
        undefined,
        1,
        1
    ] // Set left over.
];
/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */ var ignore = {
    hash: 1,
    query: 1
};
/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */ function lolcation(loc) {
    var globalVar;
    if (typeof window !== 'undefined') globalVar = window;
    else if ("TURBOPACK compile-time truthy", 1) globalVar = /*TURBOPACK member replacement*/ __turbopack_context__.g;
    else //TURBOPACK unreachable
    ;
    var location = globalVar.location || {};
    loc = loc || location;
    var finaldestination = {}, type = typeof loc, key;
    if ('blob:' === loc.protocol) {
        finaldestination = new Url(unescape(loc.pathname), {});
    } else if ('string' === type) {
        finaldestination = new Url(loc, {});
        for(key in ignore)delete finaldestination[key];
    } else if ('object' === type) {
        for(key in loc){
            if (key in ignore) continue;
            finaldestination[key] = loc[key];
        }
        if (finaldestination.slashes === undefined) {
            finaldestination.slashes = slashes.test(loc.href);
        }
    }
    return finaldestination;
}
/**
 * Check whether a protocol scheme is special.
 *
 * @param {String} The protocol scheme of the URL
 * @return {Boolean} `true` if the protocol scheme is special, else `false`
 * @private
 */ function isSpecial(scheme) {
    return scheme === 'file:' || scheme === 'ftp:' || scheme === 'http:' || scheme === 'https:' || scheme === 'ws:' || scheme === 'wss:';
}
/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */ /**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @param {Object} location
 * @return {ProtocolExtract} Extracted information.
 * @private
 */ function extractProtocol(address, location) {
    address = trimLeft(address);
    address = address.replace(CRHTLF, '');
    location = location || {};
    var match = protocolre.exec(address);
    var protocol = match[1] ? match[1].toLowerCase() : '';
    var forwardSlashes = !!match[2];
    var otherSlashes = !!match[3];
    var slashesCount = 0;
    var rest;
    if (forwardSlashes) {
        if (otherSlashes) {
            rest = match[2] + match[3] + match[4];
            slashesCount = match[2].length + match[3].length;
        } else {
            rest = match[2] + match[4];
            slashesCount = match[2].length;
        }
    } else {
        if (otherSlashes) {
            rest = match[3] + match[4];
            slashesCount = match[3].length;
        } else {
            rest = match[4];
        }
    }
    if (protocol === 'file:') {
        if (slashesCount >= 2) {
            rest = rest.slice(2);
        }
    } else if (isSpecial(protocol)) {
        rest = match[4];
    } else if (protocol) {
        if (forwardSlashes) {
            rest = rest.slice(2);
        }
    } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
        rest = match[4];
    }
    return {
        protocol: protocol,
        slashes: forwardSlashes || isSpecial(protocol),
        slashesCount: slashesCount,
        rest: rest
    };
}
/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */ function resolve(relative, base) {
    if (relative === '') return base;
    var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/')), i = path.length, last = path[i - 1], unshift = false, up = 0;
    while(i--){
        if (path[i] === '.') {
            path.splice(i, 1);
        } else if (path[i] === '..') {
            path.splice(i, 1);
            up++;
        } else if (up) {
            if (i === 0) unshift = true;
            path.splice(i, 1);
            up--;
        }
    }
    if (unshift) path.unshift('');
    if (last === '.' || last === '..') path.push('');
    return path.join('/');
}
/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */ function Url(address, location, parser) {
    address = trimLeft(address);
    address = address.replace(CRHTLF, '');
    if (!(this instanceof Url)) {
        return new Url(address, location, parser);
    }
    var relative, extracted, parse, instruction, index, key, instructions = rules.slice(), type = typeof location, url = this, i = 0;
    //
    // The following if statements allows this module two have compatibility with
    // 2 different API:
    //
    // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
    //    where the boolean indicates that the query string should also be parsed.
    //
    // 2. The `URL` interface of the browser which accepts a URL, object as
    //    arguments. The supplied object will be used as default values / fall-back
    //    for relative paths.
    //
    if ('object' !== type && 'string' !== type) {
        parser = location;
        location = null;
    }
    if (parser && 'function' !== typeof parser) parser = qs.parse;
    location = lolcation(location);
    //
    // Extract protocol information before running the instructions.
    //
    extracted = extractProtocol(address || '', location);
    relative = !extracted.protocol && !extracted.slashes;
    url.slashes = extracted.slashes || relative && location.slashes;
    url.protocol = extracted.protocol || location.protocol || '';
    address = extracted.rest;
    //
    // When the authority component is absent the URL starts with a path
    // component.
    //
    if (extracted.protocol === 'file:' && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {
        instructions[3] = [
            /(.*)/,
            'pathname'
        ];
    }
    for(; i < instructions.length; i++){
        instruction = instructions[i];
        if (typeof instruction === 'function') {
            address = instruction(address, url);
            continue;
        }
        parse = instruction[0];
        key = instruction[1];
        if (parse !== parse) {
            url[key] = address;
        } else if ('string' === typeof parse) {
            index = parse === '@' ? address.lastIndexOf(parse) : address.indexOf(parse);
            if (~index) {
                if ('number' === typeof instruction[2]) {
                    url[key] = address.slice(0, index);
                    address = address.slice(index + instruction[2]);
                } else {
                    url[key] = address.slice(index);
                    address = address.slice(0, index);
                }
            }
        } else if (index = parse.exec(address)) {
            url[key] = index[1];
            address = address.slice(0, index.index);
        }
        url[key] = url[key] || (relative && instruction[3] ? location[key] || '' : '');
        //
        // Hostname, host and protocol should be lowercased so they can be used to
        // create a proper `origin`.
        //
        if (instruction[4]) url[key] = url[key].toLowerCase();
    }
    //
    // Also parse the supplied query string in to an object. If we're supplied
    // with a custom parser as function use that instead of the default build-in
    // parser.
    //
    if (parser) url.query = parser(url.query);
    //
    // If the URL is relative, resolve the pathname against the base URL.
    //
    if (relative && location.slashes && url.pathname.charAt(0) !== '/' && (url.pathname !== '' || location.pathname !== '')) {
        url.pathname = resolve(url.pathname, location.pathname);
    }
    //
    // Default to a / for pathname if none exists. This normalizes the URL
    // to always have a /
    //
    if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {
        url.pathname = '/' + url.pathname;
    }
    //
    // We should not add port numbers if they are already the default port number
    // for a given protocol. As the host also contains the port number we're going
    // override it with the hostname which contains no port number.
    //
    if (!required(url.port, url.protocol)) {
        url.host = url.hostname;
        url.port = '';
    }
    //
    // Parse down the `auth` for the username and password.
    //
    url.username = url.password = '';
    if (url.auth) {
        index = url.auth.indexOf(':');
        if (~index) {
            url.username = url.auth.slice(0, index);
            url.username = encodeURIComponent(decodeURIComponent(url.username));
            url.password = url.auth.slice(index + 1);
            url.password = encodeURIComponent(decodeURIComponent(url.password));
        } else {
            url.username = encodeURIComponent(decodeURIComponent(url.auth));
        }
        url.auth = url.password ? url.username + ':' + url.password : url.username;
    }
    url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host ? url.protocol + '//' + url.host : 'null';
    //
    // The href is just the compiled result.
    //
    url.href = url.toString();
}
/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */ function set(part, value, fn) {
    var url = this;
    switch(part){
        case 'query':
            if ('string' === typeof value && value.length) {
                value = (fn || qs.parse)(value);
            }
            url[part] = value;
            break;
        case 'port':
            url[part] = value;
            if (!required(value, url.protocol)) {
                url.host = url.hostname;
                url[part] = '';
            } else if (value) {
                url.host = url.hostname + ':' + value;
            }
            break;
        case 'hostname':
            url[part] = value;
            if (url.port) value += ':' + url.port;
            url.host = value;
            break;
        case 'host':
            url[part] = value;
            if (port.test(value)) {
                value = value.split(':');
                url.port = value.pop();
                url.hostname = value.join(':');
            } else {
                url.hostname = value;
                url.port = '';
            }
            break;
        case 'protocol':
            url.protocol = value.toLowerCase();
            url.slashes = !fn;
            break;
        case 'pathname':
        case 'hash':
            if (value) {
                var char = part === 'pathname' ? '/' : '#';
                url[part] = value.charAt(0) !== char ? char + value : value;
            } else {
                url[part] = value;
            }
            break;
        case 'username':
        case 'password':
            url[part] = encodeURIComponent(value);
            break;
        case 'auth':
            var index = value.indexOf(':');
            if (~index) {
                url.username = value.slice(0, index);
                url.username = encodeURIComponent(decodeURIComponent(url.username));
                url.password = value.slice(index + 1);
                url.password = encodeURIComponent(decodeURIComponent(url.password));
            } else {
                url.username = encodeURIComponent(decodeURIComponent(value));
            }
    }
    for(var i = 0; i < rules.length; i++){
        var ins = rules[i];
        if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
    }
    url.auth = url.password ? url.username + ':' + url.password : url.username;
    url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host ? url.protocol + '//' + url.host : 'null';
    url.href = url.toString();
    return url;
}
/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */ function toString(stringify) {
    if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;
    var query, url = this, host = url.host, protocol = url.protocol;
    if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';
    var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? '//' : '');
    if (url.username) {
        result += url.username;
        if (url.password) result += ':' + url.password;
        result += '@';
    } else if (url.password) {
        result += ':' + url.password;
        result += '@';
    } else if (url.protocol !== 'file:' && isSpecial(url.protocol) && !host && url.pathname !== '/') {
        //
        // Add back the empty userinfo, otherwise the original invalid URL
        // might be transformed into a valid one with `url.pathname` as host.
        //
        result += '@';
    }
    //
    // Trailing colon is removed from `url.host` when it is parsed. If it still
    // ends with a colon, then add back the trailing colon that was removed. This
    // prevents an invalid URL from being transformed into a valid one.
    //
    if (host[host.length - 1] === ':' || port.test(url.hostname) && !url.port) {
        host += ':';
    }
    result += host + url.pathname;
    query = 'object' === typeof url.query ? stringify(url.query) : url.query;
    if (query) result += '?' !== query.charAt(0) ? '?' + query : query;
    if (url.hash) result += url.hash;
    return result;
}
Url.prototype = {
    set: set,
    toString: toString
};
//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;
module.exports = Url;
}),
"[project]/node_modules/reselect/dist/reselect.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/devModeChecks/identityFunctionCheck.ts
__turbopack_context__.s([
    "createSelector",
    ()=>createSelector,
    "createSelectorCreator",
    ()=>createSelectorCreator,
    "createStructuredSelector",
    ()=>createStructuredSelector,
    "lruMemoize",
    ()=>lruMemoize,
    "referenceEqualityCheck",
    ()=>referenceEqualityCheck,
    "setGlobalDevModeChecks",
    ()=>setGlobalDevModeChecks,
    "unstable_autotrackMemoize",
    ()=>autotrackMemoize,
    "weakMapMemoize",
    ()=>weakMapMemoize
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var runIdentityFunctionCheck = (resultFunc, inputSelectorsResults, outputSelectorResult)=>{
    if (inputSelectorsResults.length === 1 && inputSelectorsResults[0] === outputSelectorResult) {
        let isInputSameAsOutput = false;
        try {
            const emptyObject = {};
            if (resultFunc(emptyObject) === emptyObject) isInputSameAsOutput = true;
        } catch  {}
        if (isInputSameAsOutput) {
            let stack = void 0;
            try {
                throw new Error();
            } catch (e) {
                ;
                ({ stack } = e);
            }
            console.warn("The result function returned its own inputs without modification. e.g\n`createSelector([state => state.todos], todos => todos)`\nThis could lead to inefficient memoization and unnecessary re-renders.\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.", {
                stack
            });
        }
    }
};
// src/devModeChecks/inputStabilityCheck.ts
var runInputStabilityCheck = (inputSelectorResultsObject, options, inputSelectorArgs)=>{
    const { memoize, memoizeOptions } = options;
    const { inputSelectorResults, inputSelectorResultsCopy } = inputSelectorResultsObject;
    const createAnEmptyObject = memoize(()=>({}), ...memoizeOptions);
    const areInputSelectorResultsEqual = createAnEmptyObject.apply(null, inputSelectorResults) === createAnEmptyObject.apply(null, inputSelectorResultsCopy);
    if (!areInputSelectorResultsEqual) {
        let stack = void 0;
        try {
            throw new Error();
        } catch (e) {
            ;
            ({ stack } = e);
        }
        console.warn("An input selector returned a different result when passed same arguments.\nThis means your output selector will likely run more frequently than intended.\nAvoid returning a new reference inside your input selector, e.g.\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`", {
            arguments: inputSelectorArgs,
            firstInputs: inputSelectorResults,
            secondInputs: inputSelectorResultsCopy,
            stack
        });
    }
};
// src/devModeChecks/setGlobalDevModeChecks.ts
var globalDevModeChecks = {
    inputStabilityCheck: "once",
    identityFunctionCheck: "once"
};
var setGlobalDevModeChecks = (devModeChecks)=>{
    Object.assign(globalDevModeChecks, devModeChecks);
};
// src/utils.ts
var NOT_FOUND = /* @__PURE__ */ Symbol("NOT_FOUND");
function assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {
    if (typeof func !== "function") {
        throw new TypeError(errorMessage);
    }
}
function assertIsObject(object, errorMessage = `expected an object, instead received ${typeof object}`) {
    if (typeof object !== "object") {
        throw new TypeError(errorMessage);
    }
}
function assertIsArrayOfFunctions(array, errorMessage = `expected all items to be functions, instead received the following types: `) {
    if (!array.every((item)=>typeof item === "function")) {
        const itemTypes = array.map((item)=>typeof item === "function" ? `function ${item.name || "unnamed"}()` : typeof item).join(", ");
        throw new TypeError(`${errorMessage}[${itemTypes}]`);
    }
}
var ensureIsArray = (item)=>{
    return Array.isArray(item) ? item : [
        item
    ];
};
function getDependencies(createSelectorArgs) {
    const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;
    assertIsArrayOfFunctions(dependencies, `createSelector expects all input-selectors to be functions, but received the following types: `);
    return dependencies;
}
function collectInputSelectorResults(dependencies, inputSelectorArgs) {
    const inputSelectorResults = [];
    const { length } = dependencies;
    for(let i = 0; i < length; i++){
        inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));
    }
    return inputSelectorResults;
}
var getDevModeChecksExecutionInfo = (firstRun, devModeChecks)=>{
    const { identityFunctionCheck, inputStabilityCheck } = {
        ...globalDevModeChecks,
        ...devModeChecks
    };
    return {
        identityFunctionCheck: {
            shouldRun: identityFunctionCheck === "always" || identityFunctionCheck === "once" && firstRun,
            run: runIdentityFunctionCheck
        },
        inputStabilityCheck: {
            shouldRun: inputStabilityCheck === "always" || inputStabilityCheck === "once" && firstRun,
            run: runInputStabilityCheck
        }
    };
};
// src/autotrackMemoize/autotracking.ts
var $REVISION = 0;
var CURRENT_TRACKER = null;
var Cell = class {
    revision = $REVISION;
    _value;
    _lastValue;
    _isEqual = tripleEq;
    constructor(initialValue, isEqual = tripleEq){
        this._value = this._lastValue = initialValue;
        this._isEqual = isEqual;
    }
    // Whenever a storage value is read, it'll add itself to the current tracker if
    // one exists, entangling its state with that cache.
    get value() {
        CURRENT_TRACKER?.add(this);
        return this._value;
    }
    // Whenever a storage value is updated, we bump the global revision clock,
    // assign the revision for this storage to the new value, _and_ we schedule a
    // rerender. This is important, and it's what makes autotracking  _pull_
    // based. We don't actively tell the caches which depend on the storage that
    // anything has happened. Instead, we recompute the caches when needed.
    set value(newValue) {
        if (this.value === newValue) return;
        this._value = newValue;
        this.revision = ++$REVISION;
    }
};
function tripleEq(a, b) {
    return a === b;
}
var TrackingCache = class {
    _cachedValue;
    _cachedRevision = -1;
    _deps = [];
    hits = 0;
    fn;
    constructor(fn){
        this.fn = fn;
    }
    clear() {
        this._cachedValue = void 0;
        this._cachedRevision = -1;
        this._deps = [];
        this.hits = 0;
    }
    get value() {
        if (this.revision > this._cachedRevision) {
            const { fn } = this;
            const currentTracker = /* @__PURE__ */ new Set();
            const prevTracker = CURRENT_TRACKER;
            CURRENT_TRACKER = currentTracker;
            this._cachedValue = fn();
            CURRENT_TRACKER = prevTracker;
            this.hits++;
            this._deps = Array.from(currentTracker);
            this._cachedRevision = this.revision;
        }
        CURRENT_TRACKER?.add(this);
        return this._cachedValue;
    }
    get revision() {
        return Math.max(...this._deps.map((d)=>d.revision), 0);
    }
};
function getValue(cell) {
    if (!(cell instanceof Cell)) {
        console.warn("Not a valid cell! ", cell);
    }
    return cell.value;
}
function setValue(storage, value) {
    if (!(storage instanceof Cell)) {
        throw new TypeError("setValue must be passed a tracked store created with `createStorage`.");
    }
    storage.value = storage._lastValue = value;
}
function createCell(initialValue, isEqual = tripleEq) {
    return new Cell(initialValue, isEqual);
}
function createCache(fn) {
    assertIsFunction(fn, "the first parameter to `createCache` must be a function");
    return new TrackingCache(fn);
}
// src/autotrackMemoize/tracking.ts
var neverEq = (a, b)=>false;
function createTag() {
    return createCell(null, neverEq);
}
function dirtyTag(tag, value) {
    setValue(tag, value);
}
var consumeCollection = (node)=>{
    let tag = node.collectionTag;
    if (tag === null) {
        tag = node.collectionTag = createTag();
    }
    getValue(tag);
};
var dirtyCollection = (node)=>{
    const tag = node.collectionTag;
    if (tag !== null) {
        dirtyTag(tag, null);
    }
};
// src/autotrackMemoize/proxy.ts
var REDUX_PROXY_LABEL = Symbol();
var nextId = 0;
var proto = Object.getPrototypeOf({});
var ObjectTreeNode = class {
    constructor(value){
        this.value = value;
        this.value = value;
        this.tag.value = value;
    }
    proxy = new Proxy(this, objectProxyHandler);
    tag = createTag();
    tags = {};
    children = {};
    collectionTag = null;
    id = nextId++;
};
var objectProxyHandler = {
    get (node, key) {
        function calculateResult() {
            const { value } = node;
            const childValue = Reflect.get(value, key);
            if (typeof key === "symbol") {
                return childValue;
            }
            if (key in proto) {
                return childValue;
            }
            if (typeof childValue === "object" && childValue !== null) {
                let childNode = node.children[key];
                if (childNode === void 0) {
                    childNode = node.children[key] = createNode(childValue);
                }
                if (childNode.tag) {
                    getValue(childNode.tag);
                }
                return childNode.proxy;
            } else {
                let tag = node.tags[key];
                if (tag === void 0) {
                    tag = node.tags[key] = createTag();
                    tag.value = childValue;
                }
                getValue(tag);
                return childValue;
            }
        }
        const res = calculateResult();
        return res;
    },
    ownKeys (node) {
        consumeCollection(node);
        return Reflect.ownKeys(node.value);
    },
    getOwnPropertyDescriptor (node, prop) {
        return Reflect.getOwnPropertyDescriptor(node.value, prop);
    },
    has (node, prop) {
        return Reflect.has(node.value, prop);
    }
};
var ArrayTreeNode = class {
    constructor(value){
        this.value = value;
        this.value = value;
        this.tag.value = value;
    }
    proxy = new Proxy([
        this
    ], arrayProxyHandler);
    tag = createTag();
    tags = {};
    children = {};
    collectionTag = null;
    id = nextId++;
};
var arrayProxyHandler = {
    get ([node], key) {
        if (key === "length") {
            consumeCollection(node);
        }
        return objectProxyHandler.get(node, key);
    },
    ownKeys ([node]) {
        return objectProxyHandler.ownKeys(node);
    },
    getOwnPropertyDescriptor ([node], prop) {
        return objectProxyHandler.getOwnPropertyDescriptor(node, prop);
    },
    has ([node], prop) {
        return objectProxyHandler.has(node, prop);
    }
};
function createNode(value) {
    if (Array.isArray(value)) {
        return new ArrayTreeNode(value);
    }
    return new ObjectTreeNode(value);
}
function updateNode(node, newValue) {
    const { value, tags, children } = node;
    node.value = newValue;
    if (Array.isArray(value) && Array.isArray(newValue) && value.length !== newValue.length) {
        dirtyCollection(node);
    } else {
        if (value !== newValue) {
            let oldKeysSize = 0;
            let newKeysSize = 0;
            let anyKeysAdded = false;
            for(const _key in value){
                oldKeysSize++;
            }
            for(const key in newValue){
                newKeysSize++;
                if (!(key in value)) {
                    anyKeysAdded = true;
                    break;
                }
            }
            const isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize;
            if (isDifferent) {
                dirtyCollection(node);
            }
        }
    }
    for(const key in tags){
        const childValue = value[key];
        const newChildValue = newValue[key];
        if (childValue !== newChildValue) {
            dirtyCollection(node);
            dirtyTag(tags[key], newChildValue);
        }
        if (typeof newChildValue === "object" && newChildValue !== null) {
            delete tags[key];
        }
    }
    for(const key in children){
        const childNode = children[key];
        const newChildValue = newValue[key];
        const childValue = childNode.value;
        if (childValue === newChildValue) {
            continue;
        } else if (typeof newChildValue === "object" && newChildValue !== null) {
            updateNode(childNode, newChildValue);
        } else {
            deleteNode(childNode);
            delete children[key];
        }
    }
}
function deleteNode(node) {
    if (node.tag) {
        dirtyTag(node.tag, null);
    }
    dirtyCollection(node);
    for(const key in node.tags){
        dirtyTag(node.tags[key], null);
    }
    for(const key in node.children){
        deleteNode(node.children[key]);
    }
}
// src/lruMemoize.ts
function createSingletonCache(equals) {
    let entry;
    return {
        get (key) {
            if (entry && equals(entry.key, key)) {
                return entry.value;
            }
            return NOT_FOUND;
        },
        put (key, value) {
            entry = {
                key,
                value
            };
        },
        getEntries () {
            return entry ? [
                entry
            ] : [];
        },
        clear () {
            entry = void 0;
        }
    };
}
function createLruCache(maxSize, equals) {
    let entries = [];
    function get(key) {
        const cacheIndex = entries.findIndex((entry)=>equals(key, entry.key));
        if (cacheIndex > -1) {
            const entry = entries[cacheIndex];
            if (cacheIndex > 0) {
                entries.splice(cacheIndex, 1);
                entries.unshift(entry);
            }
            return entry.value;
        }
        return NOT_FOUND;
    }
    function put(key, value) {
        if (get(key) === NOT_FOUND) {
            entries.unshift({
                key,
                value
            });
            if (entries.length > maxSize) {
                entries.pop();
            }
        }
    }
    function getEntries() {
        return entries;
    }
    function clear() {
        entries = [];
    }
    return {
        get,
        put,
        getEntries,
        clear
    };
}
var referenceEqualityCheck = (a, b)=>a === b;
function createCacheKeyComparator(equalityCheck) {
    return function areArgumentsShallowlyEqual(prev, next) {
        if (prev === null || next === null || prev.length !== next.length) {
            return false;
        }
        const { length } = prev;
        for(let i = 0; i < length; i++){
            if (!equalityCheck(prev[i], next[i])) {
                return false;
            }
        }
        return true;
    };
}
function lruMemoize(func, equalityCheckOrOptions) {
    const providedOptions = typeof equalityCheckOrOptions === "object" ? equalityCheckOrOptions : {
        equalityCheck: equalityCheckOrOptions
    };
    const { equalityCheck = referenceEqualityCheck, maxSize = 1, resultEqualityCheck } = providedOptions;
    const comparator = createCacheKeyComparator(equalityCheck);
    let resultsCount = 0;
    const cache = maxSize <= 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);
    function memoized() {
        let value = cache.get(arguments);
        if (value === NOT_FOUND) {
            value = func.apply(null, arguments);
            resultsCount++;
            if (resultEqualityCheck) {
                const entries = cache.getEntries();
                const matchingEntry = entries.find((entry)=>resultEqualityCheck(entry.value, value));
                if (matchingEntry) {
                    value = matchingEntry.value;
                    resultsCount !== 0 && resultsCount--;
                }
            }
            cache.put(arguments, value);
        }
        return value;
    }
    memoized.clearCache = ()=>{
        cache.clear();
        memoized.resetResultsCount();
    };
    memoized.resultsCount = ()=>resultsCount;
    memoized.resetResultsCount = ()=>{
        resultsCount = 0;
    };
    return memoized;
}
// src/autotrackMemoize/autotrackMemoize.ts
function autotrackMemoize(func) {
    const node = createNode([]);
    let lastArgs = null;
    const shallowEqual = createCacheKeyComparator(referenceEqualityCheck);
    const cache = createCache(()=>{
        const res = func.apply(null, node.proxy);
        return res;
    });
    function memoized() {
        if (!shallowEqual(lastArgs, arguments)) {
            updateNode(node, arguments);
            lastArgs = arguments;
        }
        return cache.value;
    }
    memoized.clearCache = ()=>{
        return cache.clear();
    };
    return memoized;
}
// src/weakMapMemoize.ts
var StrongRef = class {
    constructor(value){
        this.value = value;
    }
    deref() {
        return this.value;
    }
};
var Ref = typeof WeakRef !== "undefined" ? WeakRef : StrongRef;
var UNTERMINATED = 0;
var TERMINATED = 1;
function createCacheNode() {
    return {
        s: UNTERMINATED,
        v: void 0,
        o: null,
        p: null
    };
}
function weakMapMemoize(func, options = {}) {
    let fnNode = createCacheNode();
    const { resultEqualityCheck } = options;
    let lastResult;
    let resultsCount = 0;
    function memoized() {
        let cacheNode = fnNode;
        const { length } = arguments;
        for(let i = 0, l = length; i < l; i++){
            const arg = arguments[i];
            if (typeof arg === "function" || typeof arg === "object" && arg !== null) {
                let objectCache = cacheNode.o;
                if (objectCache === null) {
                    cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();
                }
                const objectNode = objectCache.get(arg);
                if (objectNode === void 0) {
                    cacheNode = createCacheNode();
                    objectCache.set(arg, cacheNode);
                } else {
                    cacheNode = objectNode;
                }
            } else {
                let primitiveCache = cacheNode.p;
                if (primitiveCache === null) {
                    cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();
                }
                const primitiveNode = primitiveCache.get(arg);
                if (primitiveNode === void 0) {
                    cacheNode = createCacheNode();
                    primitiveCache.set(arg, cacheNode);
                } else {
                    cacheNode = primitiveNode;
                }
            }
        }
        const terminatedNode = cacheNode;
        let result;
        if (cacheNode.s === TERMINATED) {
            result = cacheNode.v;
        } else {
            result = func.apply(null, arguments);
            resultsCount++;
            if (resultEqualityCheck) {
                const lastResultValue = lastResult?.deref?.() ?? lastResult;
                if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {
                    result = lastResultValue;
                    resultsCount !== 0 && resultsCount--;
                }
                const needsWeakRef = typeof result === "object" && result !== null || typeof result === "function";
                lastResult = needsWeakRef ? new Ref(result) : result;
            }
        }
        terminatedNode.s = TERMINATED;
        terminatedNode.v = result;
        return result;
    }
    memoized.clearCache = ()=>{
        fnNode = createCacheNode();
        memoized.resetResultsCount();
    };
    memoized.resultsCount = ()=>resultsCount;
    memoized.resetResultsCount = ()=>{
        resultsCount = 0;
    };
    return memoized;
}
// src/createSelectorCreator.ts
function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {
    const createSelectorCreatorOptions = typeof memoizeOrOptions === "function" ? {
        memoize: memoizeOrOptions,
        memoizeOptions: memoizeOptionsFromArgs
    } : memoizeOrOptions;
    const createSelector2 = (...createSelectorArgs)=>{
        let recomputations = 0;
        let dependencyRecomputations = 0;
        let lastResult;
        let directlyPassedOptions = {};
        let resultFunc = createSelectorArgs.pop();
        if (typeof resultFunc === "object") {
            directlyPassedOptions = resultFunc;
            resultFunc = createSelectorArgs.pop();
        }
        assertIsFunction(resultFunc, `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`);
        const combinedOptions = {
            ...createSelectorCreatorOptions,
            ...directlyPassedOptions
        };
        const { memoize, memoizeOptions = [], argsMemoize = weakMapMemoize, argsMemoizeOptions = [], devModeChecks = {} } = combinedOptions;
        const finalMemoizeOptions = ensureIsArray(memoizeOptions);
        const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);
        const dependencies = getDependencies(createSelectorArgs);
        const memoizedResultFunc = memoize(function recomputationWrapper() {
            recomputations++;
            return resultFunc.apply(null, arguments);
        }, ...finalMemoizeOptions);
        let firstRun = true;
        const selector = argsMemoize(function dependenciesChecker() {
            dependencyRecomputations++;
            const inputSelectorResults = collectInputSelectorResults(dependencies, arguments);
            lastResult = memoizedResultFunc.apply(null, inputSelectorResults);
            if ("TURBOPACK compile-time truthy", 1) {
                const { identityFunctionCheck, inputStabilityCheck } = getDevModeChecksExecutionInfo(firstRun, devModeChecks);
                if (identityFunctionCheck.shouldRun) {
                    identityFunctionCheck.run(resultFunc, inputSelectorResults, lastResult);
                }
                if (inputStabilityCheck.shouldRun) {
                    const inputSelectorResultsCopy = collectInputSelectorResults(dependencies, arguments);
                    inputStabilityCheck.run({
                        inputSelectorResults,
                        inputSelectorResultsCopy
                    }, {
                        memoize,
                        memoizeOptions: finalMemoizeOptions
                    }, arguments);
                }
                if (firstRun) firstRun = false;
            }
            return lastResult;
        }, ...finalArgsMemoizeOptions);
        return Object.assign(selector, {
            resultFunc,
            memoizedResultFunc,
            dependencies,
            dependencyRecomputations: ()=>dependencyRecomputations,
            resetDependencyRecomputations: ()=>{
                dependencyRecomputations = 0;
            },
            lastResult: ()=>lastResult,
            recomputations: ()=>recomputations,
            resetRecomputations: ()=>{
                recomputations = 0;
            },
            memoize,
            argsMemoize
        });
    };
    Object.assign(createSelector2, {
        withTypes: ()=>createSelector2
    });
    return createSelector2;
}
var createSelector = /* @__PURE__ */ createSelectorCreator(weakMapMemoize);
// src/createStructuredSelector.ts
var createStructuredSelector = Object.assign((inputSelectorsObject, selectorCreator = createSelector)=>{
    assertIsObject(inputSelectorsObject, `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`);
    const inputSelectorKeys = Object.keys(inputSelectorsObject);
    const dependencies = inputSelectorKeys.map((key)=>inputSelectorsObject[key]);
    const structuredSelector = selectorCreator(dependencies, (...inputSelectorResults)=>{
        return inputSelectorResults.reduce((composition, value, index)=>{
            composition[inputSelectorKeys[index]] = value;
            return composition;
        }, {});
    });
    return structuredSelector;
}, {
    withTypes: ()=>createStructuredSelector
});
;
 //# sourceMappingURL=reselect.mjs.map
}),
"[project]/node_modules/react-is/cjs/react-is.development.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time truthy", 1) {
    (function() {
        'use strict';
        // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
        // nor polyfill, then a plain number is used for performance.
        var hasSymbol = typeof Symbol === 'function' && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
        // (unstable) APIs that have been removed. Can we remove the symbols?
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;
        function isValidElementType(type) {
            return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
            type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
            if (typeof object === 'object' && object !== null) {
                var $$typeof = object.$$typeof;
                switch($$typeof){
                    case REACT_ELEMENT_TYPE:
                        var type = object.type;
                        switch(type){
                            case REACT_ASYNC_MODE_TYPE:
                            case REACT_CONCURRENT_MODE_TYPE:
                            case REACT_FRAGMENT_TYPE:
                            case REACT_PROFILER_TYPE:
                            case REACT_STRICT_MODE_TYPE:
                            case REACT_SUSPENSE_TYPE:
                                return type;
                            default:
                                var $$typeofType = type && type.$$typeof;
                                switch($$typeofType){
                                    case REACT_CONTEXT_TYPE:
                                    case REACT_FORWARD_REF_TYPE:
                                    case REACT_LAZY_TYPE:
                                    case REACT_MEMO_TYPE:
                                    case REACT_PROVIDER_TYPE:
                                        return $$typeofType;
                                    default:
                                        return $$typeof;
                                }
                        }
                    case REACT_PORTAL_TYPE:
                        return $$typeof;
                }
            }
            return undefined;
        } // AsyncMode is deprecated along with isAsyncMode
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated
        function isAsyncMode(object) {
            {
                if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                    hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint
                    console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
                }
            }
            return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
            return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
            return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
            return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
            return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
    })();
}
}),
"[project]/node_modules/react-is/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/react-is/cjs/react-is.development.js [app-client] (ecmascript)");
}
}),
"[project]/node_modules/prop-types/lib/ReactPropTypesSecret.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
module.exports = ReactPropTypesSecret;
}),
"[project]/node_modules/prop-types/lib/has.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
}),
"[project]/node_modules/prop-types/checkPropTypes.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
var printWarning = function() {};
if ("TURBOPACK compile-time truthy", 1) {
    var ReactPropTypesSecret = __turbopack_context__.r("[project]/node_modules/prop-types/lib/ReactPropTypesSecret.js [app-client] (ecmascript)");
    var loggedTypeFailures = {};
    var has = __turbopack_context__.r("[project]/node_modules/prop-types/lib/has.js [app-client] (ecmascript)");
    printWarning = function(text) {
        var message = 'Warning: ' + text;
        if (typeof console !== 'undefined') {
            console.error(message);
        }
        try {
            // --- Welcome to debugging React ---
            // This error was thrown as a convenience so that you can use this stack
            // to find the callsite that caused this warning to fire.
            throw new Error(message);
        } catch (x) {}
    };
}
/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */ function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
    if ("TURBOPACK compile-time truthy", 1) {
        for(var typeSpecName in typeSpecs){
            if (has(typeSpecs, typeSpecName)) {
                var error;
                // Prop type validation may throw. In case they do, we don't want to
                // fail the render phase where it didn't fail before. So we log it.
                // After these have been cleaned up, we'll let them throw.
                try {
                    // This is intentionally an invariant that gets caught. It's the same
                    // behavior as without this statement except with a better message.
                    if (typeof typeSpecs[typeSpecName] !== 'function') {
                        var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                        err.name = 'Invariant Violation';
                        throw err;
                    }
                    error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
                } catch (ex) {
                    error = ex;
                }
                if (error && !(error instanceof Error)) {
                    printWarning((componentName || 'React class') + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + typeof error + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).');
                }
                if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                    // Only monitor this failure once because there tends to be a lot of the
                    // same error.
                    loggedTypeFailures[error.message] = true;
                    var stack = getStack ? getStack() : '';
                    printWarning('Failed ' + location + ' type: ' + error.message + (stack != null ? stack : ''));
                }
            }
        }
    }
}
/**
 * Resets warning cache when testing.
 *
 * @private
 */ checkPropTypes.resetWarningCache = function() {
    if (("TURBOPACK compile-time value", "development") !== 'production') {
        loggedTypeFailures = {};
    }
};
module.exports = checkPropTypes;
}),
"[project]/node_modules/prop-types/factoryWithTypeCheckers.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
var ReactIs = __turbopack_context__.r("[project]/node_modules/react-is/index.js [app-client] (ecmascript)");
var assign = __turbopack_context__.r("[project]/node_modules/next/dist/build/polyfills/object-assign.js [app-client] (ecmascript)");
var ReactPropTypesSecret = __turbopack_context__.r("[project]/node_modules/prop-types/lib/ReactPropTypesSecret.js [app-client] (ecmascript)");
var has = __turbopack_context__.r("[project]/node_modules/prop-types/lib/has.js [app-client] (ecmascript)");
var checkPropTypes = __turbopack_context__.r("[project]/node_modules/prop-types/checkPropTypes.js [app-client] (ecmascript)");
var printWarning = function() {};
if ("TURBOPACK compile-time truthy", 1) {
    printWarning = function(text) {
        var message = 'Warning: ' + text;
        if (typeof console !== 'undefined') {
            console.error(message);
        }
        try {
            // --- Welcome to debugging React ---
            // This error was thrown as a convenience so that you can use this stack
            // to find the callsite that caused this warning to fire.
            throw new Error(message);
        } catch (x) {}
    };
}
function emptyFunctionThatReturnsNull() {
    return null;
}
module.exports = function(isValidElement, throwOnDirectAccess) {
    /* global Symbol */ var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
    /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */ function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === 'function') {
            return iteratorFn;
        }
    }
    /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */ var ANONYMOUS = '<<anonymous>>';
    // Important!
    // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
    var ReactPropTypes = {
        array: createPrimitiveTypeChecker('array'),
        bigint: createPrimitiveTypeChecker('bigint'),
        bool: createPrimitiveTypeChecker('boolean'),
        func: createPrimitiveTypeChecker('function'),
        number: createPrimitiveTypeChecker('number'),
        object: createPrimitiveTypeChecker('object'),
        string: createPrimitiveTypeChecker('string'),
        symbol: createPrimitiveTypeChecker('symbol'),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
    };
    /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */ /*eslint-disable no-self-compare*/ function is(x, y) {
        // SameValue algorithm
        if (x === y) {
            // Steps 1-5, 7-10
            // Steps 6.b-6.e: +0 != -0
            return x !== 0 || 1 / x === 1 / y;
        } else {
            // Step 6.a: NaN == NaN
            return x !== x && y !== y;
        }
    }
    /*eslint-enable no-self-compare*/ /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */ function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === 'object' ? data : {};
        this.stack = '';
    }
    // Make `instanceof Error` still work for returned errors.
    PropTypeError.prototype = Error.prototype;
    function createChainableTypeChecker(validate) {
        if (("TURBOPACK compile-time value", "development") !== 'production') {
            var manualPropTypeCallCache = {};
            var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
            componentName = componentName || ANONYMOUS;
            propFullName = propFullName || propName;
            if (secret !== ReactPropTypesSecret) {
                if (throwOnDirectAccess) {
                    // New behavior only for users of `prop-types` package
                    var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
                    err.name = 'Invariant Violation';
                    throw err;
                } else if (("TURBOPACK compile-time value", "development") !== 'production' && typeof console !== 'undefined') {
                    // Old behavior for people using React.PropTypes
                    var cacheKey = componentName + ':' + propName;
                    if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
                    manualPropTypeWarningCount < 3) {
                        printWarning('You are manually calling a React.PropTypes validation ' + 'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.');
                        manualPropTypeCallCache[cacheKey] = true;
                        manualPropTypeWarningCount++;
                    }
                }
            }
            if (props[propName] == null) {
                if (isRequired) {
                    if (props[propName] === null) {
                        return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
                    }
                    return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
                }
                return null;
            } else {
                return validate(props, propName, componentName, location, propFullName);
            }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
    }
    function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== expectedType) {
                // `propValue` being instance of, say, date/regexp, pass the 'object'
                // check, but we can offer a more precise error message here rather than
                // 'of type `object`'.
                var preciseType = getPreciseType(propValue);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'), {
                    expectedType: expectedType
                });
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
    }
    function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== 'function') {
                return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
            }
            var propValue = props[propName];
            if (!Array.isArray(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
            }
            for(var i = 0; i < propValue.length; i++){
                var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
                if (error instanceof Error) {
                    return error;
                }
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!isValidElement(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!ReactIs.isValidElementType(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
            if (!(props[propName] instanceof expectedClass)) {
                var expectedClassName = expectedClass.name || ANONYMOUS;
                var actualClassName = getClassName(props[propName]);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
            if ("TURBOPACK compile-time truthy", 1) {
                if (arguments.length > 1) {
                    printWarning('Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' + 'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).');
                } else {
                    printWarning('Invalid argument supplied to oneOf, expected an array.');
                }
            }
            return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            for(var i = 0; i < expectedValues.length; i++){
                if (is(propValue, expectedValues[i])) {
                    return null;
                }
            }
            var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
                var type = getPreciseType(value);
                if (type === 'symbol') {
                    return String(value);
                }
                return value;
            });
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
        }
        return createChainableTypeChecker(validate);
    }
    function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== 'function') {
                return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
            }
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== 'object') {
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
            }
            for(var key in propValue){
                if (has(propValue, key)) {
                    var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
                    if (error instanceof Error) {
                        return error;
                    }
                }
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
            ("TURBOPACK compile-time truthy", 1) ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : "TURBOPACK unreachable";
            return emptyFunctionThatReturnsNull;
        }
        for(var i = 0; i < arrayOfTypeCheckers.length; i++){
            var checker = arrayOfTypeCheckers[i];
            if (typeof checker !== 'function') {
                printWarning('Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.');
                return emptyFunctionThatReturnsNull;
            }
        }
        function validate(props, propName, componentName, location, propFullName) {
            var expectedTypes = [];
            for(var i = 0; i < arrayOfTypeCheckers.length; i++){
                var checker = arrayOfTypeCheckers[i];
                var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
                if (checkerResult == null) {
                    return null;
                }
                if (checkerResult.data && has(checkerResult.data, 'expectedType')) {
                    expectedTypes.push(checkerResult.data.expectedType);
                }
            }
            var expectedTypesMessage = expectedTypes.length > 0 ? ', expected one of type [' + expectedTypes.join(', ') + ']' : '';
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));
        }
        return createChainableTypeChecker(validate);
    }
    function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
            if (!isNode(props[propName])) {
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError((componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + type + '`.');
    }
    function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== 'object') {
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
            }
            for(var key in shapeTypes){
                var checker = shapeTypes[key];
                if (typeof checker !== 'function') {
                    return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
                }
                var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
                if (error) {
                    return error;
                }
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== 'object') {
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
            }
            // We need to check all keys in case some are required but missing from props.
            var allKeys = assign({}, props[propName], shapeTypes);
            for(var key in allKeys){
                var checker = shapeTypes[key];
                if (has(shapeTypes, key) && typeof checker !== 'function') {
                    return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
                }
                if (!checker) {
                    return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
                }
                var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
                if (error) {
                    return error;
                }
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function isNode(propValue) {
        switch(typeof propValue){
            case 'number':
            case 'string':
            case 'undefined':
                return true;
            case 'boolean':
                return !propValue;
            case 'object':
                if (Array.isArray(propValue)) {
                    return propValue.every(isNode);
                }
                if (propValue === null || isValidElement(propValue)) {
                    return true;
                }
                var iteratorFn = getIteratorFn(propValue);
                if (iteratorFn) {
                    var iterator = iteratorFn.call(propValue);
                    var step;
                    if (iteratorFn !== propValue.entries) {
                        while(!(step = iterator.next()).done){
                            if (!isNode(step.value)) {
                                return false;
                            }
                        }
                    } else {
                        // Iterator will provide entry [k,v] tuples rather than values.
                        while(!(step = iterator.next()).done){
                            var entry = step.value;
                            if (entry) {
                                if (!isNode(entry[1])) {
                                    return false;
                                }
                            }
                        }
                    }
                } else {
                    return false;
                }
                return true;
            default:
                return false;
        }
    }
    function isSymbol(propType, propValue) {
        // Native Symbol.
        if (propType === 'symbol') {
            return true;
        }
        // falsy value can't be a Symbol
        if (!propValue) {
            return false;
        }
        // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
        if (propValue['@@toStringTag'] === 'Symbol') {
            return true;
        }
        // Fallback for non-spec compliant Symbols which are polyfilled.
        if (typeof Symbol === 'function' && propValue instanceof Symbol) {
            return true;
        }
        return false;
    }
    // Equivalent of `typeof` but with special handling for array and regexp.
    function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
            return 'array';
        }
        if (propValue instanceof RegExp) {
            // Old webkits (at least until Android 4.0) return 'function' rather than
            // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
            // passes PropTypes.object.
            return 'object';
        }
        if (isSymbol(propType, propValue)) {
            return 'symbol';
        }
        return propType;
    }
    // This handles more types than `getPropType`. Only used for error messages.
    // See `createPrimitiveTypeChecker`.
    function getPreciseType(propValue) {
        if (typeof propValue === 'undefined' || propValue === null) {
            return '' + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === 'object') {
            if (propValue instanceof Date) {
                return 'date';
            } else if (propValue instanceof RegExp) {
                return 'regexp';
            }
        }
        return propType;
    }
    // Returns a string that is postfixed to a warning about an invalid type.
    // For example, "undefined" or "of type array"
    function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch(type){
            case 'array':
            case 'object':
                return 'an ' + type;
            case 'boolean':
            case 'date':
            case 'regexp':
                return 'a ' + type;
            default:
                return type;
        }
    }
    // Returns class name of the object, if any.
    function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
            return ANONYMOUS;
        }
        return propValue.constructor.name;
    }
    ReactPropTypes.checkPropTypes = checkPropTypes;
    ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
};
}),
"[project]/node_modules/prop-types/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
if ("TURBOPACK compile-time truthy", 1) {
    var ReactIs = __turbopack_context__.r("[project]/node_modules/react-is/index.js [app-client] (ecmascript)");
    // By explicitly using `prop-types` you are opting into new development behavior.
    // http://fb.me/prop-types-in-prod
    var throwOnDirectAccess = true;
    module.exports = __turbopack_context__.r("[project]/node_modules/prop-types/factoryWithTypeCheckers.js [app-client] (ecmascript)")(ReactIs.isElement, throwOnDirectAccess);
} else //TURBOPACK unreachable
;
}),
"[project]/node_modules/js-yaml/dist/js-yaml.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */ __turbopack_context__.s([
    "CORE_SCHEMA",
    ()=>CORE_SCHEMA,
    "DEFAULT_SCHEMA",
    ()=>DEFAULT_SCHEMA,
    "FAILSAFE_SCHEMA",
    ()=>FAILSAFE_SCHEMA,
    "JSON_SCHEMA",
    ()=>JSON_SCHEMA,
    "Schema",
    ()=>Schema,
    "Type",
    ()=>Type,
    "YAMLException",
    ()=>YAMLException,
    "default",
    ()=>__TURBOPACK__default__export__,
    "dump",
    ()=>dump,
    "load",
    ()=>load,
    "loadAll",
    ()=>loadAll,
    "safeDump",
    ()=>safeDump,
    "safeLoad",
    ()=>safeLoad,
    "safeLoadAll",
    ()=>safeLoadAll,
    "types",
    ()=>types
]);
function isNothing(subject) {
    return typeof subject === 'undefined' || subject === null;
}
function isObject(subject) {
    return typeof subject === 'object' && subject !== null;
}
function toArray(sequence) {
    if (Array.isArray(sequence)) return sequence;
    else if (isNothing(sequence)) return [];
    return [
        sequence
    ];
}
function extend(target, source) {
    var index, length, key, sourceKeys;
    if (source) {
        sourceKeys = Object.keys(source);
        for(index = 0, length = sourceKeys.length; index < length; index += 1){
            key = sourceKeys[index];
            target[key] = source[key];
        }
    }
    return target;
}
function repeat(string, count) {
    var result = '', cycle;
    for(cycle = 0; cycle < count; cycle += 1){
        result += string;
    }
    return result;
}
function isNegativeZero(number) {
    return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
    isNothing: isNothing_1,
    isObject: isObject_1,
    toArray: toArray_1,
    repeat: repeat_1,
    isNegativeZero: isNegativeZero_1,
    extend: extend_1
};
// YAML error class. http://stackoverflow.com/questions/8458984
function formatError(exception, compact) {
    var where = '', message = exception.reason || '(unknown reason)';
    if (!exception.mark) return message;
    if (exception.mark.name) {
        where += 'in "' + exception.mark.name + '" ';
    }
    where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';
    if (!compact && exception.mark.snippet) {
        where += '\n\n' + exception.mark.snippet;
    }
    return message + ' ' + where;
}
function YAMLException$1(reason, mark) {
    // Super constructor
    Error.call(this);
    this.name = 'YAMLException';
    this.reason = reason;
    this.mark = mark;
    this.message = formatError(this, false);
    // Include stack trace in error object
    if (Error.captureStackTrace) {
        // Chrome and NodeJS
        Error.captureStackTrace(this, this.constructor);
    } else {
        // FF, IE 10+ and Safari 6+. Fallback for others
        this.stack = new Error().stack || '';
    }
}
// Inherit from Error
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString(compact) {
    return this.name + ': ' + formatError(this, compact);
};
var exception = YAMLException$1;
// get snippet for a single line, respecting maxLength
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
    var head = '';
    var tail = '';
    var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
    if (position - lineStart > maxHalfLength) {
        head = ' ... ';
        lineStart = position - maxHalfLength + head.length;
    }
    if (lineEnd - position > maxHalfLength) {
        tail = ' ...';
        lineEnd = position + maxHalfLength - tail.length;
    }
    return {
        str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, '') + tail,
        pos: position - lineStart + head.length // relative position
    };
}
function padStart(string, max) {
    return common.repeat(' ', max - string.length) + string;
}
function makeSnippet(mark, options) {
    options = Object.create(options || null);
    if (!mark.buffer) return null;
    if (!options.maxLength) options.maxLength = 79;
    if (typeof options.indent !== 'number') options.indent = 1;
    if (typeof options.linesBefore !== 'number') options.linesBefore = 3;
    if (typeof options.linesAfter !== 'number') options.linesAfter = 2;
    var re = /\r?\n|\r|\0/g;
    var lineStarts = [
        0
    ];
    var lineEnds = [];
    var match;
    var foundLineNo = -1;
    while(match = re.exec(mark.buffer)){
        lineEnds.push(match.index);
        lineStarts.push(match.index + match[0].length);
        if (mark.position <= match.index && foundLineNo < 0) {
            foundLineNo = lineStarts.length - 2;
        }
    }
    if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
    var result = '', i, line;
    var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
    var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
    for(i = 1; i <= options.linesBefore; i++){
        if (foundLineNo - i < 0) break;
        line = getLine(mark.buffer, lineStarts[foundLineNo - i], lineEnds[foundLineNo - i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]), maxLineLength);
        result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + ' | ' + line.str + '\n' + result;
    }
    line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
    result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + ' | ' + line.str + '\n';
    result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\n';
    for(i = 1; i <= options.linesAfter; i++){
        if (foundLineNo + i >= lineEnds.length) break;
        line = getLine(mark.buffer, lineStarts[foundLineNo + i], lineEnds[foundLineNo + i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]), maxLineLength);
        result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + ' | ' + line.str + '\n';
    }
    return result.replace(/\n$/, '');
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
    'kind',
    'multi',
    'resolve',
    'construct',
    'instanceOf',
    'predicate',
    'represent',
    'representName',
    'defaultStyle',
    'styleAliases'
];
var YAML_NODE_KINDS = [
    'scalar',
    'sequence',
    'mapping'
];
function compileStyleAliases(map) {
    var result = {};
    if (map !== null) {
        Object.keys(map).forEach(function(style) {
            map[style].forEach(function(alias) {
                result[String(alias)] = style;
            });
        });
    }
    return result;
}
function Type$1(tag, options) {
    options = options || {};
    Object.keys(options).forEach(function(name) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
            throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
        }
    });
    // TODO: Add tag format check.
    this.options = options; // keep original options in case user wants to extend this type later
    this.tag = tag;
    this.kind = options['kind'] || null;
    this.resolve = options['resolve'] || function() {
        return true;
    };
    this.construct = options['construct'] || function(data) {
        return data;
    };
    this.instanceOf = options['instanceOf'] || null;
    this.predicate = options['predicate'] || null;
    this.represent = options['represent'] || null;
    this.representName = options['representName'] || null;
    this.defaultStyle = options['defaultStyle'] || null;
    this.multi = options['multi'] || false;
    this.styleAliases = compileStyleAliases(options['styleAliases'] || null);
    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
        throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
}
var type = Type$1;
/*eslint-disable max-len*/ function compileList(schema, name) {
    var result = [];
    schema[name].forEach(function(currentType) {
        var newIndex = result.length;
        result.forEach(function(previousType, previousIndex) {
            if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
                newIndex = previousIndex;
            }
        });
        result[newIndex] = currentType;
    });
    return result;
}
function compileMap() {
    var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {},
        multi: {
            scalar: [],
            sequence: [],
            mapping: [],
            fallback: []
        }
    }, index, length;
    function collectType(type) {
        if (type.multi) {
            result.multi[type.kind].push(type);
            result.multi['fallback'].push(type);
        } else {
            result[type.kind][type.tag] = result['fallback'][type.tag] = type;
        }
    }
    for(index = 0, length = arguments.length; index < length; index += 1){
        arguments[index].forEach(collectType);
    }
    return result;
}
function Schema$1(definition) {
    return this.extend(definition);
}
Schema$1.prototype.extend = function extend(definition) {
    var implicit = [];
    var explicit = [];
    if (definition instanceof type) {
        // Schema.extend(type)
        explicit.push(definition);
    } else if (Array.isArray(definition)) {
        // Schema.extend([ type1, type2, ... ])
        explicit = explicit.concat(definition);
    } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
        // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })
        if (definition.implicit) implicit = implicit.concat(definition.implicit);
        if (definition.explicit) explicit = explicit.concat(definition.explicit);
    } else {
        throw new exception('Schema.extend argument should be a Type, [ Type ], ' + 'or a schema definition ({ implicit: [...], explicit: [...] })');
    }
    implicit.forEach(function(type$1) {
        if (!(type$1 instanceof type)) {
            throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
        }
        if (type$1.loadKind && type$1.loadKind !== 'scalar') {
            throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
        }
        if (type$1.multi) {
            throw new exception('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');
        }
    });
    explicit.forEach(function(type$1) {
        if (!(type$1 instanceof type)) {
            throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
        }
    });
    var result = Object.create(Schema$1.prototype);
    result.implicit = (this.implicit || []).concat(implicit);
    result.explicit = (this.explicit || []).concat(explicit);
    result.compiledImplicit = compileList(result, 'implicit');
    result.compiledExplicit = compileList(result, 'explicit');
    result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
    return result;
};
var schema = Schema$1;
var str = new type('tag:yaml.org,2002:str', {
    kind: 'scalar',
    construct: function(data) {
        return data !== null ? data : '';
    }
});
var seq = new type('tag:yaml.org,2002:seq', {
    kind: 'sequence',
    construct: function(data) {
        return data !== null ? data : [];
    }
});
var map = new type('tag:yaml.org,2002:map', {
    kind: 'mapping',
    construct: function(data) {
        return data !== null ? data : {};
    }
});
var failsafe = new schema({
    explicit: [
        str,
        seq,
        map
    ]
});
function resolveYamlNull(data) {
    if (data === null) return true;
    var max = data.length;
    return max === 1 && data === '~' || max === 4 && (data === 'null' || data === 'Null' || data === 'NULL');
}
function constructYamlNull() {
    return null;
}
function isNull(object) {
    return object === null;
}
var _null = new type('tag:yaml.org,2002:null', {
    kind: 'scalar',
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
        canonical: function() {
            return '~';
        },
        lowercase: function() {
            return 'null';
        },
        uppercase: function() {
            return 'NULL';
        },
        camelcase: function() {
            return 'Null';
        },
        empty: function() {
            return '';
        }
    },
    defaultStyle: 'lowercase'
});
function resolveYamlBoolean(data) {
    if (data === null) return false;
    var max = data.length;
    return max === 4 && (data === 'true' || data === 'True' || data === 'TRUE') || max === 5 && (data === 'false' || data === 'False' || data === 'FALSE');
}
function constructYamlBoolean(data) {
    return data === 'true' || data === 'True' || data === 'TRUE';
}
function isBoolean(object) {
    return Object.prototype.toString.call(object) === '[object Boolean]';
}
var bool = new type('tag:yaml.org,2002:bool', {
    kind: 'scalar',
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
        lowercase: function(object) {
            return object ? 'true' : 'false';
        },
        uppercase: function(object) {
            return object ? 'TRUE' : 'FALSE';
        },
        camelcase: function(object) {
            return object ? 'True' : 'False';
        }
    },
    defaultStyle: 'lowercase'
});
function isHexCode(c) {
    return 0x30 /* 0 */  <= c && c <= 0x39 /* 9 */  || 0x41 /* A */  <= c && c <= 0x46 /* F */  || 0x61 /* a */  <= c && c <= 0x66 /* f */ ;
}
function isOctCode(c) {
    return 0x30 /* 0 */  <= c && c <= 0x37 /* 7 */ ;
}
function isDecCode(c) {
    return 0x30 /* 0 */  <= c && c <= 0x39 /* 9 */ ;
}
function resolveYamlInteger(data) {
    if (data === null) return false;
    var max = data.length, index = 0, hasDigits = false, ch;
    if (!max) return false;
    ch = data[index];
    // sign
    if (ch === '-' || ch === '+') {
        ch = data[++index];
    }
    if (ch === '0') {
        // 0
        if (index + 1 === max) return true;
        ch = data[++index];
        // base 2, base 8, base 16
        if (ch === 'b') {
            // base 2
            index++;
            for(; index < max; index++){
                ch = data[index];
                if (ch === '_') continue;
                if (ch !== '0' && ch !== '1') return false;
                hasDigits = true;
            }
            return hasDigits && ch !== '_';
        }
        if (ch === 'x') {
            // base 16
            index++;
            for(; index < max; index++){
                ch = data[index];
                if (ch === '_') continue;
                if (!isHexCode(data.charCodeAt(index))) return false;
                hasDigits = true;
            }
            return hasDigits && ch !== '_';
        }
        if (ch === 'o') {
            // base 8
            index++;
            for(; index < max; index++){
                ch = data[index];
                if (ch === '_') continue;
                if (!isOctCode(data.charCodeAt(index))) return false;
                hasDigits = true;
            }
            return hasDigits && ch !== '_';
        }
    }
    // base 10 (except 0)
    // value should not start with `_`;
    if (ch === '_') return false;
    for(; index < max; index++){
        ch = data[index];
        if (ch === '_') continue;
        if (!isDecCode(data.charCodeAt(index))) {
            return false;
        }
        hasDigits = true;
    }
    // Should have digits and should not end with `_`
    if (!hasDigits || ch === '_') return false;
    return true;
}
function constructYamlInteger(data) {
    var value = data, sign = 1, ch;
    if (value.indexOf('_') !== -1) {
        value = value.replace(/_/g, '');
    }
    ch = value[0];
    if (ch === '-' || ch === '+') {
        if (ch === '-') sign = -1;
        value = value.slice(1);
        ch = value[0];
    }
    if (value === '0') return 0;
    if (ch === '0') {
        if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
        if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);
        if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);
    }
    return sign * parseInt(value, 10);
}
function isInteger(object) {
    return Object.prototype.toString.call(object) === '[object Number]' && object % 1 === 0 && !common.isNegativeZero(object);
}
var int = new type('tag:yaml.org,2002:int', {
    kind: 'scalar',
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
        binary: function(obj) {
            return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1);
        },
        octal: function(obj) {
            return obj >= 0 ? '0o' + obj.toString(8) : '-0o' + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
            return obj.toString(10);
        },
        /* eslint-disable max-len */ hexadecimal: function(obj) {
            return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() : '-0x' + obj.toString(16).toUpperCase().slice(1);
        }
    },
    defaultStyle: 'decimal',
    styleAliases: {
        binary: [
            2,
            'bin'
        ],
        octal: [
            8,
            'oct'
        ],
        decimal: [
            10,
            'dec'
        ],
        hexadecimal: [
            16,
            'hex'
        ]
    }
});
var YAML_FLOAT_PATTERN = new RegExp(// 2.5e4, 2.5 and integers
'^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' + // .2e4, .2
// special case, seems not from spec
'|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' + // .inf
'|[-+]?\\.(?:inf|Inf|INF)' + // .nan
'|\\.(?:nan|NaN|NAN))$');
function resolveYamlFloat(data) {
    if (data === null) return false;
    if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    data[data.length - 1] === '_') {
        return false;
    }
    return true;
}
function constructYamlFloat(data) {
    var value, sign;
    value = data.replace(/_/g, '').toLowerCase();
    sign = value[0] === '-' ? -1 : 1;
    if ('+-'.indexOf(value[0]) >= 0) {
        value = value.slice(1);
    }
    if (value === '.inf') {
        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    } else if (value === '.nan') {
        return NaN;
    }
    return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
    var res;
    if (isNaN(object)) {
        switch(style){
            case 'lowercase':
                return '.nan';
            case 'uppercase':
                return '.NAN';
            case 'camelcase':
                return '.NaN';
        }
    } else if (Number.POSITIVE_INFINITY === object) {
        switch(style){
            case 'lowercase':
                return '.inf';
            case 'uppercase':
                return '.INF';
            case 'camelcase':
                return '.Inf';
        }
    } else if (Number.NEGATIVE_INFINITY === object) {
        switch(style){
            case 'lowercase':
                return '-.inf';
            case 'uppercase':
                return '-.INF';
            case 'camelcase':
                return '-.Inf';
        }
    } else if (common.isNegativeZero(object)) {
        return '-0.0';
    }
    res = object.toString(10);
    // JS stringifier can build scientific format without dots: 5e-100,
    // while YAML requres dot: 5.e-100. Fix it with simple hack
    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}
function isFloat(object) {
    return Object.prototype.toString.call(object) === '[object Number]' && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float = new type('tag:yaml.org,2002:float', {
    kind: 'scalar',
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: 'lowercase'
});
var json = failsafe.extend({
    implicit: [
        _null,
        bool,
        int,
        float
    ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year
'-([0-9][0-9])' + // [2] month
'-([0-9][0-9])$'); // [3] day
var YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year
'-([0-9][0-9]?)' + // [2] month
'-([0-9][0-9]?)' + // [3] day
'(?:[Tt]|[ \\t]+)' + // ...
'([0-9][0-9]?)' + // [4] hour
':([0-9][0-9])' + // [5] minute
':([0-9][0-9])' + // [6] second
'(?:\\.([0-9]*))?' + // [7] fraction
'(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
'(?::([0-9][0-9]))?))?$'); // [11] tz_minute
function resolveYamlTimestamp(data) {
    if (data === null) return false;
    if (YAML_DATE_REGEXP.exec(data) !== null) return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
    return false;
}
function constructYamlTimestamp(data) {
    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    match = YAML_DATE_REGEXP.exec(data);
    if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
    if (match === null) throw new Error('Date resolve error');
    // match: [1] year [2] month [3] day
    year = +match[1];
    month = +match[2] - 1; // JS month starts with 0
    day = +match[3];
    if (!match[4]) {
        return new Date(Date.UTC(year, month, day));
    }
    // match: [4] hour [5] minute [6] second [7] fraction
    hour = +match[4];
    minute = +match[5];
    second = +match[6];
    if (match[7]) {
        fraction = match[7].slice(0, 3);
        while(fraction.length < 3){
            fraction += '0';
        }
        fraction = +fraction;
    }
    // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute
    if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
        if (match[9] === '-') delta = -delta;
    }
    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (delta) date.setTime(date.getTime() - delta);
    return date;
}
function representYamlTimestamp(object /*, style*/ ) {
    return object.toISOString();
}
var timestamp = new type('tag:yaml.org,2002:timestamp', {
    kind: 'scalar',
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
    return data === '<<' || data === null;
}
var merge = new type('tag:yaml.org,2002:merge', {
    kind: 'scalar',
    resolve: resolveYamlMerge
});
/*eslint-disable no-bitwise*/ // [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';
function resolveYamlBinary(data) {
    if (data === null) return false;
    var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
    // Convert one by one.
    for(idx = 0; idx < max; idx++){
        code = map.indexOf(data.charAt(idx));
        // Skip CR/LF
        if (code > 64) continue;
        // Fail on illegal characters
        if (code < 0) return false;
        bitlen += 6;
    }
    // If there are any bits left, source was corrupted
    return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
    var idx, tailbits, input = data.replace(/[\r\n=]/g, ''), max = input.length, map = BASE64_MAP, bits = 0, result = [];
    // Collect by 6*4 bits (3 bytes)
    for(idx = 0; idx < max; idx++){
        if (idx % 4 === 0 && idx) {
            result.push(bits >> 16 & 0xFF);
            result.push(bits >> 8 & 0xFF);
            result.push(bits & 0xFF);
        }
        bits = bits << 6 | map.indexOf(input.charAt(idx));
    }
    // Dump tail
    tailbits = max % 4 * 6;
    if (tailbits === 0) {
        result.push(bits >> 16 & 0xFF);
        result.push(bits >> 8 & 0xFF);
        result.push(bits & 0xFF);
    } else if (tailbits === 18) {
        result.push(bits >> 10 & 0xFF);
        result.push(bits >> 2 & 0xFF);
    } else if (tailbits === 12) {
        result.push(bits >> 4 & 0xFF);
    }
    return new Uint8Array(result);
}
function representYamlBinary(object /*, style*/ ) {
    var result = '', bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
    // Convert every three bytes to 4 ASCII characters.
    for(idx = 0; idx < max; idx++){
        if (idx % 3 === 0 && idx) {
            result += map[bits >> 18 & 0x3F];
            result += map[bits >> 12 & 0x3F];
            result += map[bits >> 6 & 0x3F];
            result += map[bits & 0x3F];
        }
        bits = (bits << 8) + object[idx];
    }
    // Dump tail
    tail = max % 3;
    if (tail === 0) {
        result += map[bits >> 18 & 0x3F];
        result += map[bits >> 12 & 0x3F];
        result += map[bits >> 6 & 0x3F];
        result += map[bits & 0x3F];
    } else if (tail === 2) {
        result += map[bits >> 10 & 0x3F];
        result += map[bits >> 4 & 0x3F];
        result += map[bits << 2 & 0x3F];
        result += map[64];
    } else if (tail === 1) {
        result += map[bits >> 2 & 0x3F];
        result += map[bits << 4 & 0x3F];
        result += map[64];
        result += map[64];
    }
    return result;
}
function isBinary(obj) {
    return Object.prototype.toString.call(obj) === '[object Uint8Array]';
}
var binary = new type('tag:yaml.org,2002:binary', {
    kind: 'scalar',
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
    if (data === null) return true;
    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
    for(index = 0, length = object.length; index < length; index += 1){
        pair = object[index];
        pairHasKey = false;
        if (_toString$2.call(pair) !== '[object Object]') return false;
        for(pairKey in pair){
            if (_hasOwnProperty$3.call(pair, pairKey)) {
                if (!pairHasKey) pairHasKey = true;
                else return false;
            }
        }
        if (!pairHasKey) return false;
        if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
        else return false;
    }
    return true;
}
function constructYamlOmap(data) {
    return data !== null ? data : [];
}
var omap = new type('tag:yaml.org,2002:omap', {
    kind: 'sequence',
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
    if (data === null) return true;
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for(index = 0, length = object.length; index < length; index += 1){
        pair = object[index];
        if (_toString$1.call(pair) !== '[object Object]') return false;
        keys = Object.keys(pair);
        if (keys.length !== 1) return false;
        result[index] = [
            keys[0],
            pair[keys[0]]
        ];
    }
    return true;
}
function constructYamlPairs(data) {
    if (data === null) return [];
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for(index = 0, length = object.length; index < length; index += 1){
        pair = object[index];
        keys = Object.keys(pair);
        result[index] = [
            keys[0],
            pair[keys[0]]
        ];
    }
    return result;
}
var pairs = new type('tag:yaml.org,2002:pairs', {
    kind: 'sequence',
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
    if (data === null) return true;
    var key, object = data;
    for(key in object){
        if (_hasOwnProperty$2.call(object, key)) {
            if (object[key] !== null) return false;
        }
    }
    return true;
}
function constructYamlSet(data) {
    return data !== null ? data : {};
}
var set = new type('tag:yaml.org,2002:set', {
    kind: 'mapping',
    resolve: resolveYamlSet,
    construct: constructYamlSet
});
var _default = core.extend({
    implicit: [
        timestamp,
        merge
    ],
    explicit: [
        binary,
        omap,
        pairs,
        set
    ]
});
/*eslint-disable max-len,no-use-before-define*/ var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
    return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
    return c === 0x0A /* LF */  || c === 0x0D /* CR */ ;
}
function is_WHITE_SPACE(c) {
    return c === 0x09 /* Tab */  || c === 0x20 /* Space */ ;
}
function is_WS_OR_EOL(c) {
    return c === 0x09 /* Tab */  || c === 0x20 /* Space */  || c === 0x0A /* LF */  || c === 0x0D /* CR */ ;
}
function is_FLOW_INDICATOR(c) {
    return c === 0x2C /* , */  || c === 0x5B /* [ */  || c === 0x5D /* ] */  || c === 0x7B /* { */  || c === 0x7D /* } */ ;
}
function fromHexCode(c) {
    var lc;
    if (0x30 /* 0 */  <= c && c <= 0x39 /* 9 */ ) {
        return c - 0x30;
    }
    /*eslint-disable no-bitwise*/ lc = c | 0x20;
    if (0x61 /* a */  <= lc && lc <= 0x66 /* f */ ) {
        return lc - 0x61 + 10;
    }
    return -1;
}
function escapedHexLen(c) {
    if (c === 0x78 /* x */ ) {
        return 2;
    }
    if (c === 0x75 /* u */ ) {
        return 4;
    }
    if (c === 0x55 /* U */ ) {
        return 8;
    }
    return 0;
}
function fromDecimalCode(c) {
    if (0x30 /* 0 */  <= c && c <= 0x39 /* 9 */ ) {
        return c - 0x30;
    }
    return -1;
}
function simpleEscapeSequence(c) {
    /* eslint-disable indent */ return c === 0x30 /* 0 */  ? '\x00' : c === 0x61 /* a */  ? '\x07' : c === 0x62 /* b */  ? '\x08' : c === 0x74 /* t */  ? '\x09' : c === 0x09 /* Tab */  ? '\x09' : c === 0x6E /* n */  ? '\x0A' : c === 0x76 /* v */  ? '\x0B' : c === 0x66 /* f */  ? '\x0C' : c === 0x72 /* r */  ? '\x0D' : c === 0x65 /* e */  ? '\x1B' : c === 0x20 /* Space */  ? ' ' : c === 0x22 /* " */  ? '\x22' : c === 0x2F /* / */  ? '/' : c === 0x5C /* \ */  ? '\x5C' : c === 0x4E /* N */  ? '\x85' : c === 0x5F /* _ */  ? '\xA0' : c === 0x4C /* L */  ? '\u2028' : c === 0x50 /* P */  ? '\u2029' : '';
}
function charFromCodepoint(c) {
    if (c <= 0xFFFF) {
        return String.fromCharCode(c);
    }
    // Encode UTF-16 surrogate pair
    // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
    return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);
}
var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for(var i = 0; i < 256; i++){
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
    simpleEscapeMap[i] = simpleEscapeSequence(i);
}
function State$1(input, options) {
    this.input = input;
    this.filename = options['filename'] || null;
    this.schema = options['schema'] || _default;
    this.onWarning = options['onWarning'] || null;
    // (Hidden) Remove? makes the loader to expect YAML 1.1 documents
    // if such documents have no explicit %YAML directive
    this.legacy = options['legacy'] || false;
    this.json = options['json'] || false;
    this.listener = options['listener'] || null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap = this.schema.compiledTypeMap;
    this.length = input.length;
    this.position = 0;
    this.line = 0;
    this.lineStart = 0;
    this.lineIndent = 0;
    // position of first leading tab in the current line,
    // used to make sure there are no tabs in the indentation
    this.firstTabInLine = -1;
    this.documents = [];
/*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/ }
function generateError(state, message) {
    var mark = {
        name: state.filename,
        buffer: state.input.slice(0, -1),
        position: state.position,
        line: state.line,
        column: state.position - state.lineStart
    };
    mark.snippet = snippet(mark);
    return new exception(message, mark);
}
function throwError(state, message) {
    throw generateError(state, message);
}
function throwWarning(state, message) {
    if (state.onWarning) {
        state.onWarning.call(null, generateError(state, message));
    }
}
var directiveHandlers = {
    YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) {
            throwError(state, 'duplication of %YAML directive');
        }
        if (args.length !== 1) {
            throwError(state, 'YAML directive accepts exactly one argument');
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
            throwError(state, 'ill-formed argument of the YAML directive');
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
            throwError(state, 'unacceptable YAML version of the document');
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
            throwWarning(state, 'unsupported YAML version of the document');
        }
    },
    TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) {
            throwError(state, 'TAG directive accepts exactly two arguments');
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
            throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
        }
        if (_hasOwnProperty$1.call(state.tagMap, handle)) {
            throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
            throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
        }
        try {
            prefix = decodeURIComponent(prefix);
        } catch (err) {
            throwError(state, 'tag prefix is malformed: ' + prefix);
        }
        state.tagMap[handle] = prefix;
    }
};
function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;
    if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
            for(_position = 0, _length = _result.length; _position < _length; _position += 1){
                _character = _result.charCodeAt(_position);
                if (!(_character === 0x09 || 0x20 <= _character && _character <= 0x10FFFF)) {
                    throwError(state, 'expected valid JSON character');
                }
            }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
            throwError(state, 'the stream contains non-printable characters');
        }
        state.result += _result;
    }
}
function mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys, key, index, quantity;
    if (!common.isObject(source)) {
        throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
    }
    sourceKeys = Object.keys(source);
    for(index = 0, quantity = sourceKeys.length; index < quantity; index += 1){
        key = sourceKeys[index];
        if (!_hasOwnProperty$1.call(destination, key)) {
            destination[key] = source[key];
            overridableKeys[key] = true;
        }
    }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
    var index, quantity;
    // The output is a plain object here, so keys can only be strings.
    // We need to convert keyNode to a string, but doing so can hang the process
    // (deeply nested arrays that explode exponentially using aliases).
    if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for(index = 0, quantity = keyNode.length; index < quantity; index += 1){
            if (Array.isArray(keyNode[index])) {
                throwError(state, 'nested arrays are not supported inside keys');
            }
            if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
                keyNode[index] = '[object Object]';
            }
        }
    }
    // Avoid code execution in load() via toString property
    // (still use its own toString for arrays, timestamps,
    // and whatever user schema extensions happen to have @@toStringTag)
    if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
        keyNode = '[object Object]';
    }
    keyNode = String(keyNode);
    if (_result === null) {
        _result = {};
    }
    if (keyTag === 'tag:yaml.org,2002:merge') {
        if (Array.isArray(valueNode)) {
            for(index = 0, quantity = valueNode.length; index < quantity; index += 1){
                mergeMappings(state, _result, valueNode[index], overridableKeys);
            }
        } else {
            mergeMappings(state, _result, valueNode, overridableKeys);
        }
    } else {
        if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
            state.line = startLine || state.line;
            state.lineStart = startLineStart || state.lineStart;
            state.position = startPos || state.position;
            throwError(state, 'duplicated mapping key');
        }
        // used for this specific key only because Object.defineProperty is slow
        if (keyNode === '__proto__') {
            Object.defineProperty(_result, keyNode, {
                configurable: true,
                enumerable: true,
                writable: true,
                value: valueNode
            });
        } else {
            _result[keyNode] = valueNode;
        }
        delete overridableKeys[keyNode];
    }
    return _result;
}
function readLineBreak(state) {
    var ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 0x0A /* LF */ ) {
        state.position++;
    } else if (ch === 0x0D /* CR */ ) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 0x0A /* LF */ ) {
            state.position++;
        }
    } else {
        throwError(state, 'a line break is expected');
    }
    state.line += 1;
    state.lineStart = state.position;
    state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
    while(ch !== 0){
        while(is_WHITE_SPACE(ch)){
            if (ch === 0x09 /* Tab */  && state.firstTabInLine === -1) {
                state.firstTabInLine = state.position;
            }
            ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 0x23 /* # */ ) {
            do {
                ch = state.input.charCodeAt(++state.position);
            }while (ch !== 0x0A /* LF */  && ch !== 0x0D /* CR */  && ch !== 0)
        }
        if (is_EOL(ch)) {
            readLineBreak(state);
            ch = state.input.charCodeAt(state.position);
            lineBreaks++;
            state.lineIndent = 0;
            while(ch === 0x20 /* Space */ ){
                state.lineIndent++;
                ch = state.input.charCodeAt(++state.position);
            }
        } else {
            break;
        }
    }
    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning(state, 'deficient indentation');
    }
    return lineBreaks;
}
function testDocumentSeparator(state) {
    var _position = state.position, ch;
    ch = state.input.charCodeAt(_position);
    // Condition state.position === state.lineStart is tested
    // in parent on each call, for efficiency. No needs to test here again.
    if ((ch === 0x2D /* - */  || ch === 0x2E /* . */ ) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
            return true;
        }
    }
    return false;
}
function writeFoldedLines(state, count) {
    if (count === 1) {
        state.result += ' ';
    } else if (count > 1) {
        state.result += common.repeat('\n', count - 1);
    }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
    ch = state.input.charCodeAt(state.position);
    if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 0x23 /* # */  || ch === 0x26 /* & */  || ch === 0x2A /* * */  || ch === 0x21 /* ! */  || ch === 0x7C /* | */  || ch === 0x3E /* > */  || ch === 0x27 /* ' */  || ch === 0x22 /* " */  || ch === 0x25 /* % */  || ch === 0x40 /* @ */  || ch === 0x60 /* ` */ ) {
        return false;
    }
    if (ch === 0x3F /* ? */  || ch === 0x2D /* - */ ) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            return false;
        }
    }
    state.kind = 'scalar';
    state.result = '';
    captureStart = captureEnd = state.position;
    hasPendingContent = false;
    while(ch !== 0){
        if (ch === 0x3A /* : */ ) {
            following = state.input.charCodeAt(state.position + 1);
            if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
                break;
            }
        } else if (ch === 0x23 /* # */ ) {
            preceding = state.input.charCodeAt(state.position - 1);
            if (is_WS_OR_EOL(preceding)) {
                break;
            }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
            break;
        } else if (is_EOL(ch)) {
            _line = state.line;
            _lineStart = state.lineStart;
            _lineIndent = state.lineIndent;
            skipSeparationSpace(state, false, -1);
            if (state.lineIndent >= nodeIndent) {
                hasPendingContent = true;
                ch = state.input.charCodeAt(state.position);
                continue;
            } else {
                state.position = captureEnd;
                state.line = _line;
                state.lineStart = _lineStart;
                state.lineIndent = _lineIndent;
                break;
            }
        }
        if (hasPendingContent) {
            captureSegment(state, captureStart, captureEnd, false);
            writeFoldedLines(state, state.line - _line);
            captureStart = captureEnd = state.position;
            hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
            captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, captureEnd, false);
    if (state.result) {
        return true;
    }
    state.kind = _kind;
    state.result = _result;
    return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
    var ch, captureStart, captureEnd;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x27 /* ' */ ) {
        return false;
    }
    state.kind = 'scalar';
    state.result = '';
    state.position++;
    captureStart = captureEnd = state.position;
    while((ch = state.input.charCodeAt(state.position)) !== 0){
        if (ch === 0x27 /* ' */ ) {
            captureSegment(state, captureStart, state.position, true);
            ch = state.input.charCodeAt(++state.position);
            if (ch === 0x27 /* ' */ ) {
                captureStart = state.position;
                state.position++;
                captureEnd = state.position;
            } else {
                return true;
            }
        } else if (is_EOL(ch)) {
            captureSegment(state, captureStart, captureEnd, true);
            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
            captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
            throwError(state, 'unexpected end of the document within a single quoted scalar');
        } else {
            state.position++;
            captureEnd = state.position;
        }
    }
    throwError(state, 'unexpected end of the stream within a single quoted scalar');
}
function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x22 /* " */ ) {
        return false;
    }
    state.kind = 'scalar';
    state.result = '';
    state.position++;
    captureStart = captureEnd = state.position;
    while((ch = state.input.charCodeAt(state.position)) !== 0){
        if (ch === 0x22 /* " */ ) {
            captureSegment(state, captureStart, state.position, true);
            state.position++;
            return true;
        } else if (ch === 0x5C /* \ */ ) {
            captureSegment(state, captureStart, state.position, true);
            ch = state.input.charCodeAt(++state.position);
            if (is_EOL(ch)) {
                skipSeparationSpace(state, false, nodeIndent);
            // TODO: rework to inline fn with no type cast?
            } else if (ch < 256 && simpleEscapeCheck[ch]) {
                state.result += simpleEscapeMap[ch];
                state.position++;
            } else if ((tmp = escapedHexLen(ch)) > 0) {
                hexLength = tmp;
                hexResult = 0;
                for(; hexLength > 0; hexLength--){
                    ch = state.input.charCodeAt(++state.position);
                    if ((tmp = fromHexCode(ch)) >= 0) {
                        hexResult = (hexResult << 4) + tmp;
                    } else {
                        throwError(state, 'expected hexadecimal character');
                    }
                }
                state.result += charFromCodepoint(hexResult);
                state.position++;
            } else {
                throwError(state, 'unknown escape sequence');
            }
            captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
            captureSegment(state, captureStart, captureEnd, true);
            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
            captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
            throwError(state, 'unexpected end of the document within a double quoted scalar');
        } else {
            state.position++;
            captureEnd = state.position;
        }
    }
    throwError(state, 'unexpected end of the stream within a double quoted scalar');
}
function readFlowCollection(state, nodeIndent) {
    var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = Object.create(null), keyNode, keyTag, valueNode, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 0x5B /* [ */ ) {
        terminator = 0x5D; /* ] */ 
        isMapping = false;
        _result = [];
    } else if (ch === 0x7B /* { */ ) {
        terminator = 0x7D; /* } */ 
        isMapping = true;
        _result = {};
    } else {
        return false;
    }
    if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(++state.position);
    while(ch !== 0){
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
            state.position++;
            state.tag = _tag;
            state.anchor = _anchor;
            state.kind = isMapping ? 'mapping' : 'sequence';
            state.result = _result;
            return true;
        } else if (!readNext) {
            throwError(state, 'missed comma between flow collection entries');
        } else if (ch === 0x2C /* , */ ) {
            // "flow collection entries can never be completely empty", as per YAML 1.2, section 7.4
            throwError(state, "expected the node content, but found ','");
        }
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 0x3F /* ? */ ) {
            following = state.input.charCodeAt(state.position + 1);
            if (is_WS_OR_EOL(following)) {
                isPair = isExplicitPair = true;
                state.position++;
                skipSeparationSpace(state, true, nodeIndent);
            }
        }
        _line = state.line; // Save the current line.
        _lineStart = state.lineStart;
        _pos = state.position;
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 0x3A /* : */ ) {
            isPair = true;
            ch = state.input.charCodeAt(++state.position);
            skipSeparationSpace(state, true, nodeIndent);
            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
            valueNode = state.result;
        }
        if (isMapping) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
        } else if (isPair) {
            _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
        } else {
            _result.push(keyNode);
        }
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 0x2C /* , */ ) {
            readNext = true;
            ch = state.input.charCodeAt(++state.position);
        } else {
            readNext = false;
        }
    }
    throwError(state, 'unexpected end of the stream within a flow collection');
}
function readBlockScalar(state, nodeIndent) {
    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 0x7C /* | */ ) {
        folding = false;
    } else if (ch === 0x3E /* > */ ) {
        folding = true;
    } else {
        return false;
    }
    state.kind = 'scalar';
    state.result = '';
    while(ch !== 0){
        ch = state.input.charCodeAt(++state.position);
        if (ch === 0x2B /* + */  || ch === 0x2D /* - */ ) {
            if (CHOMPING_CLIP === chomping) {
                chomping = ch === 0x2B /* + */  ? CHOMPING_KEEP : CHOMPING_STRIP;
            } else {
                throwError(state, 'repeat of a chomping mode identifier');
            }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
            if (tmp === 0) {
                throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
            } else if (!detectedIndent) {
                textIndent = nodeIndent + tmp - 1;
                detectedIndent = true;
            } else {
                throwError(state, 'repeat of an indentation width identifier');
            }
        } else {
            break;
        }
    }
    if (is_WHITE_SPACE(ch)) {
        do {
            ch = state.input.charCodeAt(++state.position);
        }while (is_WHITE_SPACE(ch))
        if (ch === 0x23 /* # */ ) {
            do {
                ch = state.input.charCodeAt(++state.position);
            }while (!is_EOL(ch) && ch !== 0)
        }
    }
    while(ch !== 0){
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20 /* Space */ ){
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
            textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
            emptyLines++;
            continue;
        }
        // End of the scalar.
        if (state.lineIndent < textIndent) {
            // Perform the chomping.
            if (chomping === CHOMPING_KEEP) {
                state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
            } else if (chomping === CHOMPING_CLIP) {
                if (didReadContent) {
                    state.result += '\n';
                }
            }
            break;
        }
        // Folded style: use fancy rules to handle line breaks.
        if (folding) {
            // Lines starting with white space characters (more-indented lines) are not folded.
            if (is_WHITE_SPACE(ch)) {
                atMoreIndented = true;
                // except for the first content line (cf. Example 8.1)
                state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
            // End of more-indented block.
            } else if (atMoreIndented) {
                atMoreIndented = false;
                state.result += common.repeat('\n', emptyLines + 1);
            // Just one line break - perceive as the same line.
            } else if (emptyLines === 0) {
                if (didReadContent) {
                    state.result += ' ';
                }
            // Several line breaks - perceive as different lines.
            } else {
                state.result += common.repeat('\n', emptyLines);
            }
        // Literal style: just add exact number of line breaks between content lines.
        } else {
            // Keep all line breaks except the header line break.
            state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while(!is_EOL(ch) && ch !== 0){
            ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
    }
    return true;
}
function readBlockSequence(state, nodeIndent) {
    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
    // there is a leading tab before this token, so it can't be a block sequence/mapping;
    // it can still be flow sequence/mapping or a scalar
    if (state.firstTabInLine !== -1) return false;
    if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while(ch !== 0){
        if (state.firstTabInLine !== -1) {
            state.position = state.firstTabInLine;
            throwError(state, 'tab characters must not be used in indentation');
        }
        if (ch !== 0x2D /* - */ ) {
            break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
            break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
            if (state.lineIndent <= nodeIndent) {
                _result.push(null);
                ch = state.input.charCodeAt(state.position);
                continue;
            }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
            throwError(state, 'bad indentation of a sequence entry');
        } else if (state.lineIndent < nodeIndent) {
            break;
        }
    }
    if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = 'sequence';
        state.result = _result;
        return true;
    }
    return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
    // there is a leading tab before this token, so it can't be a block sequence/mapping;
    // it can still be flow sequence/mapping or a scalar
    if (state.firstTabInLine !== -1) return false;
    if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while(ch !== 0){
        if (!atExplicitKey && state.firstTabInLine !== -1) {
            state.position = state.firstTabInLine;
            throwError(state, 'tab characters must not be used in indentation');
        }
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line; // Save the current line.
        //
        // Explicit notation case. There are two separate blocks:
        // first for the key (denoted by "?") and second for the value (denoted by ":")
        //
        if ((ch === 0x3F /* ? */  || ch === 0x3A /* : */ ) && is_WS_OR_EOL(following)) {
            if (ch === 0x3F /* ? */ ) {
                if (atExplicitKey) {
                    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                    keyTag = keyNode = valueNode = null;
                }
                detected = true;
                atExplicitKey = true;
                allowCompact = true;
            } else if (atExplicitKey) {
                // i.e. 0x3A/* : */ === character after the explicit key.
                atExplicitKey = false;
                allowCompact = true;
            } else {
                throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
            }
            state.position += 1;
            ch = following;
        //
        // Implicit notation case. Flow-style node as the key first, then ":", and the value.
        //
        } else {
            _keyLine = state.line;
            _keyLineStart = state.lineStart;
            _keyPos = state.position;
            if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
                break;
            }
            if (state.line === _line) {
                ch = state.input.charCodeAt(state.position);
                while(is_WHITE_SPACE(ch)){
                    ch = state.input.charCodeAt(++state.position);
                }
                if (ch === 0x3A /* : */ ) {
                    ch = state.input.charCodeAt(++state.position);
                    if (!is_WS_OR_EOL(ch)) {
                        throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
                    }
                    if (atExplicitKey) {
                        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                        keyTag = keyNode = valueNode = null;
                    }
                    detected = true;
                    atExplicitKey = false;
                    allowCompact = false;
                    keyTag = state.tag;
                    keyNode = state.result;
                } else if (detected) {
                    throwError(state, 'can not read an implicit mapping pair; a colon is missed');
                } else {
                    state.tag = _tag;
                    state.anchor = _anchor;
                    return true; // Keep the result of `composeNode`.
                }
            } else if (detected) {
                throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');
            } else {
                state.tag = _tag;
                state.anchor = _anchor;
                return true; // Keep the result of `composeNode`.
            }
        }
        //
        // Common reading code for both explicit and implicit notations.
        //
        if (state.line === _line || state.lineIndent > nodeIndent) {
            if (atExplicitKey) {
                _keyLine = state.line;
                _keyLineStart = state.lineStart;
                _keyPos = state.position;
            }
            if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
                if (atExplicitKey) {
                    keyNode = state.result;
                } else {
                    valueNode = state.result;
                }
            }
            if (!atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
                keyTag = keyNode = valueNode = null;
            }
            skipSeparationSpace(state, true, -1);
            ch = state.input.charCodeAt(state.position);
        }
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
            throwError(state, 'bad indentation of a mapping entry');
        } else if (state.lineIndent < nodeIndent) {
            break;
        }
    }
    //
    // Epilogue.
    //
    // Special case: last mapping's node contains only the key in explicit notation.
    if (atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
    }
    // Expose the resulting mapping.
    if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = 'mapping';
        state.result = _result;
    }
    return detected;
}
function readTagProperty(state) {
    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x21 /* ! */ ) return false;
    if (state.tag !== null) {
        throwError(state, 'duplication of a tag property');
    }
    ch = state.input.charCodeAt(++state.position);
    if (ch === 0x3C /* < */ ) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
    } else if (ch === 0x21 /* ! */ ) {
        isNamed = true;
        tagHandle = '!!';
        ch = state.input.charCodeAt(++state.position);
    } else {
        tagHandle = '!';
    }
    _position = state.position;
    if (isVerbatim) {
        do {
            ch = state.input.charCodeAt(++state.position);
        }while (ch !== 0 && ch !== 0x3E /* > */ )
        if (state.position < state.length) {
            tagName = state.input.slice(_position, state.position);
            ch = state.input.charCodeAt(++state.position);
        } else {
            throwError(state, 'unexpected end of the stream within a verbatim tag');
        }
    } else {
        while(ch !== 0 && !is_WS_OR_EOL(ch)){
            if (ch === 0x21 /* ! */ ) {
                if (!isNamed) {
                    tagHandle = state.input.slice(_position - 1, state.position + 1);
                    if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                        throwError(state, 'named tag handle cannot contain such characters');
                    }
                    isNamed = true;
                    _position = state.position + 1;
                } else {
                    throwError(state, 'tag suffix cannot contain exclamation marks');
                }
            }
            ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
            throwError(state, 'tag suffix cannot contain flow indicator characters');
        }
    }
    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, 'tag name cannot contain such characters: ' + tagName);
    }
    try {
        tagName = decodeURIComponent(tagName);
    } catch (err) {
        throwError(state, 'tag name is malformed: ' + tagName);
    }
    if (isVerbatim) {
        state.tag = tagName;
    } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
    } else if (tagHandle === '!') {
        state.tag = '!' + tagName;
    } else if (tagHandle === '!!') {
        state.tag = 'tag:yaml.org,2002:' + tagName;
    } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
    }
    return true;
}
function readAnchorProperty(state) {
    var _position, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x26 /* & */ ) return false;
    if (state.anchor !== null) {
        throwError(state, 'duplication of an anchor property');
    }
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while(ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)){
        ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
        throwError(state, 'name of an anchor node must contain at least one character');
    }
    state.anchor = state.input.slice(_position, state.position);
    return true;
}
function readAlias(state) {
    var _position, alias, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x2A /* * */ ) return false;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while(ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)){
        ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
        throwError(state, 'name of an alias node must contain at least one character');
    }
    alias = state.input.slice(_position, state.position);
    if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
    }
    state.result = state.anchorMap[alias];
    skipSeparationSpace(state, true, -1);
    return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type, flowIndent, blockIndent;
    if (state.listener !== null) {
        state.listener('open', state);
    }
    state.tag = null;
    state.anchor = null;
    state.kind = null;
    state.result = null;
    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
    if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            if (state.lineIndent > parentIndent) {
                indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
                indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
                indentStatus = -1;
            }
        }
    }
    if (indentStatus === 1) {
        while(readTagProperty(state) || readAnchorProperty(state)){
            if (skipSeparationSpace(state, true, -1)) {
                atNewLine = true;
                allowBlockCollections = allowBlockStyles;
                if (state.lineIndent > parentIndent) {
                    indentStatus = 1;
                } else if (state.lineIndent === parentIndent) {
                    indentStatus = 0;
                } else if (state.lineIndent < parentIndent) {
                    indentStatus = -1;
                }
            } else {
                allowBlockCollections = false;
            }
        }
    }
    if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
    }
    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
            flowIndent = parentIndent;
        } else {
            flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
            if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
                hasContent = true;
            } else {
                if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
                    hasContent = true;
                } else if (readAlias(state)) {
                    hasContent = true;
                    if (state.tag !== null || state.anchor !== null) {
                        throwError(state, 'alias node should not have any properties');
                    }
                } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
                    hasContent = true;
                    if (state.tag === null) {
                        state.tag = '?';
                    }
                }
                if (state.anchor !== null) {
                    state.anchorMap[state.anchor] = state.result;
                }
            }
        } else if (indentStatus === 0) {
            // Special case: block sequences are allowed to have same indentation level as the parent.
            // http://www.yaml.org/spec/1.2/spec.html#id2799784
            hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
    }
    if (state.tag === null) {
        if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
        }
    } else if (state.tag === '?') {
        // Implicit resolving is not allowed for non-scalar types, and '?'
        // non-specific tag is only automatically assigned to plain scalars.
        //
        // We only need to check kind conformity in case user explicitly assigns '?'
        // tag, for example like this: "!<?> [0]"
        //
        if (state.result !== null && state.kind !== 'scalar') {
            throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
        }
        for(typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1){
            type = state.implicitTypes[typeIndex];
            if (type.resolve(state.result)) {
                state.result = type.construct(state.result);
                state.tag = type.tag;
                if (state.anchor !== null) {
                    state.anchorMap[state.anchor] = state.result;
                }
                break;
            }
        }
    } else if (state.tag !== '!') {
        if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
            type = state.typeMap[state.kind || 'fallback'][state.tag];
        } else {
            // looking for multi type
            type = null;
            typeList = state.typeMap.multi[state.kind || 'fallback'];
            for(typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1){
                if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
                    type = typeList[typeIndex];
                    break;
                }
            }
        }
        if (!type) {
            throwError(state, 'unknown tag !<' + state.tag + '>');
        }
        if (state.result !== null && type.kind !== state.kind) {
            throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
        }
        if (!type.resolve(state.result, state.tag)) {
            throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
        } else {
            state.result = type.construct(state.result, state.tag);
            if (state.anchor !== null) {
                state.anchorMap[state.anchor] = state.result;
            }
        }
    }
    if (state.listener !== null) {
        state.listener('close', state);
    }
    return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = Object.create(null);
    state.anchorMap = Object.create(null);
    while((ch = state.input.charCodeAt(state.position)) !== 0){
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 0x25 /* % */ ) {
            break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while(ch !== 0 && !is_WS_OR_EOL(ch)){
            ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
            throwError(state, 'directive name must not be less than one character in length');
        }
        while(ch !== 0){
            while(is_WHITE_SPACE(ch)){
                ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 0x23 /* # */ ) {
                do {
                    ch = state.input.charCodeAt(++state.position);
                }while (ch !== 0 && !is_EOL(ch))
                break;
            }
            if (is_EOL(ch)) break;
            _position = state.position;
            while(ch !== 0 && !is_WS_OR_EOL(ch)){
                ch = state.input.charCodeAt(++state.position);
            }
            directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0) readLineBreak(state);
        if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
            directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
            throwWarning(state, 'unknown document directive "' + directiveName + '"');
        }
    }
    skipSeparationSpace(state, true, -1);
    if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D /* - */  && state.input.charCodeAt(state.position + 1) === 0x2D /* - */  && state.input.charCodeAt(state.position + 2) === 0x2D /* - */ ) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
    } else if (hasDirectives) {
        throwError(state, 'directives end mark is expected');
    }
    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);
    if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, 'non-ASCII line breaks are interpreted as content');
    }
    state.documents.push(state.result);
    if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 0x2E /* . */ ) {
            state.position += 3;
            skipSeparationSpace(state, true, -1);
        }
        return;
    }
    if (state.position < state.length - 1) {
        throwError(state, 'end of the stream or a document separator is expected');
    } else {
        return;
    }
}
function loadDocuments(input, options) {
    input = String(input);
    options = options || {};
    if (input.length !== 0) {
        // Add tailing `\n` if not exists
        if (input.charCodeAt(input.length - 1) !== 0x0A /* LF */  && input.charCodeAt(input.length - 1) !== 0x0D /* CR */ ) {
            input += '\n';
        }
        // Strip BOM
        if (input.charCodeAt(0) === 0xFEFF) {
            input = input.slice(1);
        }
    }
    var state = new State$1(input, options);
    var nullpos = input.indexOf('\0');
    if (nullpos !== -1) {
        state.position = nullpos;
        throwError(state, 'null byte is not allowed in input');
    }
    // Use 0 as string terminator. That significantly simplifies bounds check.
    state.input += '\0';
    while(state.input.charCodeAt(state.position) === 0x20 /* Space */ ){
        state.lineIndent += 1;
        state.position += 1;
    }
    while(state.position < state.length - 1){
        readDocument(state);
    }
    return state.documents;
}
function loadAll$1(input, iterator, options) {
    if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
        options = iterator;
        iterator = null;
    }
    var documents = loadDocuments(input, options);
    if (typeof iterator !== 'function') {
        return documents;
    }
    for(var index = 0, length = documents.length; index < length; index += 1){
        iterator(documents[index]);
    }
}
function load$1(input, options) {
    var documents = loadDocuments(input, options);
    if (documents.length === 0) {
        /*eslint-disable no-undefined*/ return undefined;
    } else if (documents.length === 1) {
        return documents[0];
    }
    throw new exception('expected a single document in the stream, but found more');
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
    loadAll: loadAll_1,
    load: load_1
};
/*eslint-disable no-use-before-define*/ var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 0xFEFF;
var CHAR_TAB = 0x09; /* Tab */ 
var CHAR_LINE_FEED = 0x0A; /* LF */ 
var CHAR_CARRIAGE_RETURN = 0x0D; /* CR */ 
var CHAR_SPACE = 0x20; /* Space */ 
var CHAR_EXCLAMATION = 0x21; /* ! */ 
var CHAR_DOUBLE_QUOTE = 0x22; /* " */ 
var CHAR_SHARP = 0x23; /* # */ 
var CHAR_PERCENT = 0x25; /* % */ 
var CHAR_AMPERSAND = 0x26; /* & */ 
var CHAR_SINGLE_QUOTE = 0x27; /* ' */ 
var CHAR_ASTERISK = 0x2A; /* * */ 
var CHAR_COMMA = 0x2C; /* , */ 
var CHAR_MINUS = 0x2D; /* - */ 
var CHAR_COLON = 0x3A; /* : */ 
var CHAR_EQUALS = 0x3D; /* = */ 
var CHAR_GREATER_THAN = 0x3E; /* > */ 
var CHAR_QUESTION = 0x3F; /* ? */ 
var CHAR_COMMERCIAL_AT = 0x40; /* @ */ 
var CHAR_LEFT_SQUARE_BRACKET = 0x5B; /* [ */ 
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */ 
var CHAR_GRAVE_ACCENT = 0x60; /* ` */ 
var CHAR_LEFT_CURLY_BRACKET = 0x7B; /* { */ 
var CHAR_VERTICAL_LINE = 0x7C; /* | */ 
var CHAR_RIGHT_CURLY_BRACKET = 0x7D; /* } */ 
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0x00] = '\\0';
ESCAPE_SEQUENCES[0x07] = '\\a';
ESCAPE_SEQUENCES[0x08] = '\\b';
ESCAPE_SEQUENCES[0x09] = '\\t';
ESCAPE_SEQUENCES[0x0A] = '\\n';
ESCAPE_SEQUENCES[0x0B] = '\\v';
ESCAPE_SEQUENCES[0x0C] = '\\f';
ESCAPE_SEQUENCES[0x0D] = '\\r';
ESCAPE_SEQUENCES[0x1B] = '\\e';
ESCAPE_SEQUENCES[0x22] = '\\"';
ESCAPE_SEQUENCES[0x5C] = '\\\\';
ESCAPE_SEQUENCES[0x85] = '\\N';
ESCAPE_SEQUENCES[0xA0] = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';
var DEPRECATED_BOOLEANS_SYNTAX = [
    'y',
    'Y',
    'yes',
    'Yes',
    'YES',
    'on',
    'On',
    'ON',
    'n',
    'N',
    'no',
    'No',
    'NO',
    'off',
    'Off',
    'OFF'
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema, map) {
    var result, keys, index, length, tag, style, type;
    if (map === null) return {};
    result = {};
    keys = Object.keys(map);
    for(index = 0, length = keys.length; index < length; index += 1){
        tag = keys[index];
        style = String(map[tag]);
        if (tag.slice(0, 2) === '!!') {
            tag = 'tag:yaml.org,2002:' + tag.slice(2);
        }
        type = schema.compiledTypeMap['fallback'][tag];
        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
            style = type.styleAliases[style];
        }
        result[tag] = style;
    }
    return result;
}
function encodeHex(character) {
    var string, handle, length;
    string = character.toString(16).toUpperCase();
    if (character <= 0xFF) {
        handle = 'x';
        length = 2;
    } else if (character <= 0xFFFF) {
        handle = 'u';
        length = 4;
    } else if (character <= 0xFFFFFFFF) {
        handle = 'U';
        length = 8;
    } else {
        throw new exception('code point within a string may not be greater than 0xFFFFFFFF');
    }
    return '\\' + handle + common.repeat('0', length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1, QUOTING_TYPE_DOUBLE = 2;
function State(options) {
    this.schema = options['schema'] || _default;
    this.indent = Math.max(1, options['indent'] || 2);
    this.noArrayIndent = options['noArrayIndent'] || false;
    this.skipInvalid = options['skipInvalid'] || false;
    this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];
    this.styleMap = compileStyleMap(this.schema, options['styles'] || null);
    this.sortKeys = options['sortKeys'] || false;
    this.lineWidth = options['lineWidth'] || 80;
    this.noRefs = options['noRefs'] || false;
    this.noCompatMode = options['noCompatMode'] || false;
    this.condenseFlow = options['condenseFlow'] || false;
    this.quotingType = options['quotingType'] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
    this.forceQuotes = options['forceQuotes'] || false;
    this.replacer = typeof options['replacer'] === 'function' ? options['replacer'] : null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;
    this.tag = null;
    this.result = '';
    this.duplicates = [];
    this.usedDuplicates = null;
}
// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
    var ind = common.repeat(' ', spaces), position = 0, next = -1, result = '', line, length = string.length;
    while(position < length){
        next = string.indexOf('\n', position);
        if (next === -1) {
            line = string.slice(position);
            position = length;
        } else {
            line = string.slice(position, next + 1);
            position = next + 1;
        }
        if (line.length && line !== '\n') result += ind;
        result += line;
    }
    return result;
}
function generateNextLine(state, level) {
    return '\n' + common.repeat(' ', state.indent * level);
}
function testImplicitResolving(state, str) {
    var index, length, type;
    for(index = 0, length = state.implicitTypes.length; index < length; index += 1){
        type = state.implicitTypes[index];
        if (type.resolve(str)) {
            return true;
        }
    }
    return false;
}
// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
    return c === CHAR_SPACE || c === CHAR_TAB;
}
// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isnt mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
    return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== CHAR_BOM || 0x10000 <= c && c <= 0x10FFFF;
}
// [34] ns-char ::= nb-char - s-white
// [27] nb-char ::= c-printable - b-char - c-byte-order-mark
// [26] b-char  ::= b-line-feed | b-carriage-return
// Including s-white (for some reason, examples doesn't match specs in this aspect)
// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark
function isNsCharOrWhitespace(c) {
    return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
// [127]  ns-plain-safe(c) ::= c = flow-out   ns-plain-safe-out
//                             c = flow-in    ns-plain-safe-in
//                             c = block-key  ns-plain-safe-out
//                             c = flow-key   ns-plain-safe-in
// [128] ns-plain-safe-out ::= ns-char
// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator
// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - : - # )
//                            | ( /* An ns-char preceding */ # )
//                            | ( : /* Followed by an ns-plain-safe(c) */ )
function isPlainSafe(c, prev, inblock) {
    var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
    var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
    return (// ns-plain-safe
    inblock ? cIsNsCharOrWhitespace : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP // false on '#'
     && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '
     || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar; // change to true on ':[^ ]'
}
// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
    // Uses a subset of ns-char - c-indicator
    // where ns-char = nb-char - s-white.
    // No support of ( ( ? | : | - ) /* Followed by an ns-plain-safe(c)) */ ) part
    return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) // - s-white
     && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
// Simplified test for values allowed as the last character in plain style.
function isPlainSafeLast(c) {
    // just not whitespace or colon, it will be checked to be plain character later
    return !isWhitespace(c) && c !== CHAR_COLON;
}
// Same as 'string'.codePointAt(pos), but works in older browsers.
function codePointAt(string, pos) {
    var first = string.charCodeAt(pos), second;
    if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {
        second = string.charCodeAt(pos + 1);
        if (second >= 0xDC00 && second <= 0xDFFF) {
            // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
        }
    }
    return first;
}
// Determines whether block indentation indicator is required.
function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
    var i;
    var char = 0;
    var prevChar = null;
    var hasLineBreak = false;
    var hasFoldableLine = false; // only checked if shouldTrackWidth
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1; // count the first line correctly
    var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
    if (singleLineOnly || forceQuotes) {
        // Case: no block styles.
        // Check for disallowed characters to rule out plain and single.
        for(i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++){
            char = codePointAt(string, i);
            if (!isPrintable(char)) {
                return STYLE_DOUBLE;
            }
            plain = plain && isPlainSafe(char, prevChar, inblock);
            prevChar = char;
        }
    } else {
        // Case: block styles permitted.
        for(i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++){
            char = codePointAt(string, i);
            if (char === CHAR_LINE_FEED) {
                hasLineBreak = true;
                // Check if any line can be folded.
                if (shouldTrackWidth) {
                    hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
                    previousLineBreak = i;
                }
            } else if (!isPrintable(char)) {
                return STYLE_DOUBLE;
            }
            plain = plain && isPlainSafe(char, prevChar, inblock);
            prevChar = char;
        }
        // in case the end is missing a \n
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
    }
    // Although every style can represent \n without escaping, prefer block styles
    // for multiline, since they're more readable and they don't add empty lines.
    // Also prefer folding a super-long line.
    if (!hasLineBreak && !hasFoldableLine) {
        // Strings interpretable as another type have to be quoted;
        // e.g. the string 'true' vs. the boolean true.
        if (plain && !forceQuotes && !testAmbiguousType(string)) {
            return STYLE_PLAIN;
        }
        return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    // Edge case: block indentation indicator can only have one digit.
    if (indentPerLevel > 9 && needIndentIndicator(string)) {
        return STYLE_DOUBLE;
    }
    // At this point we know block styles are valid.
    // Prefer literal style unless we want to fold.
    if (!forceQuotes) {
        return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//     No ending newline => unaffected; already using strip "-" chomping.
//     Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey, inblock) {
    state.dump = function() {
        if (string.length === 0) {
            return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
        }
        if (!state.noCompatMode) {
            if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
                return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
            }
        }
        var indent = state.indent * Math.max(1, level); // no 0-indent scalars
        // As indentation gets deeper, let the width decrease monotonically
        // to the lower bound min(state.lineWidth, 40).
        // Note that this implies
        //  state.lineWidth  40 + state.indent: width is fixed at the lower bound.
        //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
        // This behaves better than a constant minimum width which disallows narrower options,
        // or an indent threshold which causes the width to suddenly increase.
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        // Without knowing if keys are implicit/explicit, assume implicit for safety.
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string) {
            return testImplicitResolving(state, string);
        }
        switch(chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)){
            case STYLE_PLAIN:
                return string;
            case STYLE_SINGLE:
                return "'" + string.replace(/'/g, "''") + "'";
            case STYLE_LITERAL:
                return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
            case STYLE_FOLDED:
                return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
            case STYLE_DOUBLE:
                return '"' + escapeString(string) + '"';
            default:
                throw new exception('impossible error: invalid scalar style');
        }
    }();
}
// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';
    // note the special case: the string '\n' counts as a "trailing" empty line.
    var clip = string[string.length - 1] === '\n';
    var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
    var chomp = keep ? '+' : clip ? '' : '-';
    return indentIndicator + chomp + '\n';
}
// (See the note for writeScalar.)
function dropEndingNewline(string) {
    return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
}
// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
    // In folded style, $k$ consecutive newlines output as $k+1$ newlines
    // unless they're before or after a more-indented line, or at the very
    // beginning or end, in which case $k$ maps to $k$.
    // Therefore, parse each chunk as newline(s) followed by a content line.
    var lineRe = /(\n+)([^\n]*)/g;
    // first line (possibly an empty line)
    var result = function() {
        var nextLF = string.indexOf('\n');
        nextLF = nextLF !== -1 ? nextLF : string.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string.slice(0, nextLF), width);
    }();
    // If we haven't reached the first content line yet, don't add an extra \n.
    var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
    var moreIndented;
    // rest of the lines
    var match;
    while(match = lineRe.exec(string)){
        var prefix = match[1], line = match[2];
        moreIndented = line[0] === ' ';
        result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\n' : '') + foldLine(line, width);
        prevMoreIndented = moreIndented;
    }
    return result;
}
// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
    if (line === '' || line[0] === ' ') return line;
    // Since a more-indented line adds a \n, breaks can't be followed by a space.
    var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
    var match;
    // start is an inclusive index. end, curr, and next are exclusive.
    var start = 0, end, curr = 0, next = 0;
    var result = '';
    // Invariants: 0 <= start <= length-1.
    //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
    // Inside the loop:
    //   A match implies length >= 2, so curr and next are <= length-2.
    while(match = breakRe.exec(line)){
        next = match.index;
        // maintain invariant: curr - start <= width
        if (next - start > width) {
            end = curr > start ? curr : next; // derive end <= length-2
            result += '\n' + line.slice(start, end);
            // skip the space that was output as \n
            start = end + 1; // derive start <= length-1
        }
        curr = next;
    }
    // By the invariants, start <= length-1, so there is something left over.
    // It is either the whole string or a part starting from non-whitespace.
    result += '\n';
    // Insert a break if the remainder is too long and there is a break available.
    if (line.length - start > width && curr > start) {
        result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
    } else {
        result += line.slice(start);
    }
    return result.slice(1); // drop extra \n joiner
}
// Escapes a double-quoted string.
function escapeString(string) {
    var result = '';
    var char = 0;
    var escapeSeq;
    for(var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++){
        char = codePointAt(string, i);
        escapeSeq = ESCAPE_SEQUENCES[char];
        if (!escapeSeq && isPrintable(char)) {
            result += string[i];
            if (char >= 0x10000) result += string[i + 1];
        } else {
            result += escapeSeq || encodeHex(char);
        }
    }
    return result;
}
function writeFlowSequence(state, level, object) {
    var _result = '', _tag = state.tag, index, length, value;
    for(index = 0, length = object.length; index < length; index += 1){
        value = object[index];
        if (state.replacer) {
            value = state.replacer.call(object, String(index), value);
        }
        // Write only valid elements, put null instead of invalid elements.
        if (writeNode(state, level, value, false, false) || typeof value === 'undefined' && writeNode(state, level, null, false, false)) {
            if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');
            _result += state.dump;
        }
    }
    state.tag = _tag;
    state.dump = '[' + _result + ']';
}
function writeBlockSequence(state, level, object, compact) {
    var _result = '', _tag = state.tag, index, length, value;
    for(index = 0, length = object.length; index < length; index += 1){
        value = object[index];
        if (state.replacer) {
            value = state.replacer.call(object, String(index), value);
        }
        // Write only valid elements, put null instead of invalid elements.
        if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === 'undefined' && writeNode(state, level + 1, null, true, true, false, true)) {
            if (!compact || _result !== '') {
                _result += generateNextLine(state, level);
            }
            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                _result += '-';
            } else {
                _result += '- ';
            }
            _result += state.dump;
        }
    }
    state.tag = _tag;
    state.dump = _result || '[]'; // Empty sequence if no valid values.
}
function writeFlowMapping(state, level, object) {
    var _result = '', _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
    for(index = 0, length = objectKeyList.length; index < length; index += 1){
        pairBuffer = '';
        if (_result !== '') pairBuffer += ', ';
        if (state.condenseFlow) pairBuffer += '"';
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (state.replacer) {
            objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode(state, level, objectKey, false, false)) {
            continue; // Skip this pair because of invalid key;
        }
        if (state.dump.length > 1024) pairBuffer += '? ';
        pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');
        if (!writeNode(state, level, objectValue, false, false)) {
            continue; // Skip this pair because of invalid value.
        }
        pairBuffer += state.dump;
        // Both key and value are valid.
        _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = '{' + _result + '}';
}
function writeBlockMapping(state, level, object, compact) {
    var _result = '', _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
    // Allow sorting keys so that the output file is deterministic
    if (state.sortKeys === true) {
        // Default sorting
        objectKeyList.sort();
    } else if (typeof state.sortKeys === 'function') {
        // Custom sort function
        objectKeyList.sort(state.sortKeys);
    } else if (state.sortKeys) {
        // Something is wrong
        throw new exception('sortKeys must be a boolean or a function');
    }
    for(index = 0, length = objectKeyList.length; index < length; index += 1){
        pairBuffer = '';
        if (!compact || _result !== '') {
            pairBuffer += generateNextLine(state, level);
        }
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (state.replacer) {
            objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode(state, level + 1, objectKey, true, true, true)) {
            continue; // Skip this pair because of invalid key.
        }
        explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;
        if (explicitPair) {
            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                pairBuffer += '?';
            } else {
                pairBuffer += '? ';
            }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
            pairBuffer += generateNextLine(state, level);
        }
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
            continue; // Skip this pair because of invalid value.
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += ':';
        } else {
            pairBuffer += ': ';
        }
        pairBuffer += state.dump;
        // Both key and value are valid.
        _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}
function detectType(state, object, explicit) {
    var _result, typeList, index, length, type, style;
    typeList = explicit ? state.explicitTypes : state.implicitTypes;
    for(index = 0, length = typeList.length; index < length; index += 1){
        type = typeList[index];
        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
            if (explicit) {
                if (type.multi && type.representName) {
                    state.tag = type.representName(object);
                } else {
                    state.tag = type.tag;
                }
            } else {
                state.tag = '?';
            }
            if (type.represent) {
                style = state.styleMap[type.tag] || type.defaultStyle;
                if (_toString.call(type.represent) === '[object Function]') {
                    _result = type.represent(object, style);
                } else if (_hasOwnProperty.call(type.represent, style)) {
                    _result = type.represent[style](object, style);
                } else {
                    throw new exception('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
                }
                state.dump = _result;
            }
            return true;
        }
    }
    return false;
}
// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
    state.tag = null;
    state.dump = object;
    if (!detectType(state, object, false)) {
        detectType(state, object, true);
    }
    var type = _toString.call(state.dump);
    var inblock = block;
    var tagStr;
    if (block) {
        block = state.flowLevel < 0 || state.flowLevel > level;
    }
    var objectOrArray = type === '[object Object]' || type === '[object Array]', duplicateIndex, duplicate;
    if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
    }
    if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {
        compact = false;
    }
    if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = '*ref_' + duplicateIndex;
    } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
            state.usedDuplicates[duplicateIndex] = true;
        }
        if (type === '[object Object]') {
            if (block && Object.keys(state.dump).length !== 0) {
                writeBlockMapping(state, level, state.dump, compact);
                if (duplicate) {
                    state.dump = '&ref_' + duplicateIndex + state.dump;
                }
            } else {
                writeFlowMapping(state, level, state.dump);
                if (duplicate) {
                    state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
                }
            }
        } else if (type === '[object Array]') {
            if (block && state.dump.length !== 0) {
                if (state.noArrayIndent && !isblockseq && level > 0) {
                    writeBlockSequence(state, level - 1, state.dump, compact);
                } else {
                    writeBlockSequence(state, level, state.dump, compact);
                }
                if (duplicate) {
                    state.dump = '&ref_' + duplicateIndex + state.dump;
                }
            } else {
                writeFlowSequence(state, level, state.dump);
                if (duplicate) {
                    state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
                }
            }
        } else if (type === '[object String]') {
            if (state.tag !== '?') {
                writeScalar(state, state.dump, level, iskey, inblock);
            }
        } else if (type === '[object Undefined]') {
            return false;
        } else {
            if (state.skipInvalid) return false;
            throw new exception('unacceptable kind of an object to dump ' + type);
        }
        if (state.tag !== null && state.tag !== '?') {
            // Need to encode all characters except those allowed by the spec:
            //
            // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */
            // [36] ns-hex-digit    ::=  ns-dec-digit
            //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */
            // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */
            // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | -
            // [39] ns-uri-char     ::=  % ns-hex-digit ns-hex-digit | ns-word-char | #
            //                         | ; | / | ? | : | @ | & | = | + | $ | ,
            //                         | _ | . | ! | ~ | * | ' | ( | ) | [ | ]
            //
            // Also need to encode '!' because it has special meaning (end of tag prefix).
            //
            tagStr = encodeURI(state.tag[0] === '!' ? state.tag.slice(1) : state.tag).replace(/!/g, '%21');
            if (state.tag[0] === '!') {
                tagStr = '!' + tagStr;
            } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {
                tagStr = '!!' + tagStr.slice(18);
            } else {
                tagStr = '!<' + tagStr + '>';
            }
            state.dump = tagStr + ' ' + state.dump;
        }
    }
    return true;
}
function getDuplicateReferences(object, state) {
    var objects = [], duplicatesIndexes = [], index, length;
    inspectNode(object, objects, duplicatesIndexes);
    for(index = 0, length = duplicatesIndexes.length; index < length; index += 1){
        state.duplicates.push(objects[duplicatesIndexes[index]]);
    }
    state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList, index, length;
    if (object !== null && typeof object === 'object') {
        index = objects.indexOf(object);
        if (index !== -1) {
            if (duplicatesIndexes.indexOf(index) === -1) {
                duplicatesIndexes.push(index);
            }
        } else {
            objects.push(object);
            if (Array.isArray(object)) {
                for(index = 0, length = object.length; index < length; index += 1){
                    inspectNode(object[index], objects, duplicatesIndexes);
                }
            } else {
                objectKeyList = Object.keys(object);
                for(index = 0, length = objectKeyList.length; index < length; index += 1){
                    inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
                }
            }
        }
    }
}
function dump$1(input, options) {
    options = options || {};
    var state = new State(options);
    if (!state.noRefs) getDuplicateReferences(input, state);
    var value = input;
    if (state.replacer) {
        value = state.replacer.call({
            '': value
        }, '', value);
    }
    if (writeNode(state, 0, value, true, true)) return state.dump + '\n';
    return '';
}
var dump_1 = dump$1;
var dumper = {
    dump: dump_1
};
function renamed(from, to) {
    return function() {
        throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' + 'Use yaml.' + to + ' instead, which is now safe by default.');
    };
}
var Type = type;
var Schema = schema;
var FAILSAFE_SCHEMA = failsafe;
var JSON_SCHEMA = json;
var CORE_SCHEMA = core;
var DEFAULT_SCHEMA = _default;
var load = loader.load;
var loadAll = loader.loadAll;
var dump = dumper.dump;
var YAMLException = exception;
// Re-export all types in case user wants to create custom schema
var types = {
    binary: binary,
    float: float,
    map: map,
    null: _null,
    pairs: pairs,
    set: set,
    timestamp: timestamp,
    bool: bool,
    int: int,
    merge: merge,
    omap: omap,
    seq: seq,
    str: str
};
// Removed functions from JS-YAML 3.0.x
var safeLoad = renamed('safeLoad', 'load');
var safeLoadAll = renamed('safeLoadAll', 'loadAll');
var safeDump = renamed('safeDump', 'dump');
var jsYaml = {
    Type: Type,
    Schema: Schema,
    FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,
    JSON_SCHEMA: JSON_SCHEMA,
    CORE_SCHEMA: CORE_SCHEMA,
    DEFAULT_SCHEMA: DEFAULT_SCHEMA,
    load: load,
    loadAll: loadAll,
    dump: dump,
    YAMLException: YAMLException,
    types: types,
    safeLoad: safeLoad,
    safeLoadAll: safeLoadAll,
    safeDump: safeDump
};
const __TURBOPACK__default__export__ = jsYaml;
;
}),
"[project]/node_modules/zenscroll/zenscroll.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Zenscroll 4.0.2
 * https://github.com/zengabor/zenscroll/
 *
 * Copyright 20152018 Gabor Lenard
 *
 * This is free and unencumbered software released into the public domain.
 * 
 * Anyone is free to copy, modify, publish, use, compile, sell, or
 * distribute this software, either in source code form or as a compiled
 * binary, for any purpose, commercial or non-commercial, and by any
 * means.
 * 
 * In jurisdictions that recognize copyright laws, the author or authors
 * of this software dedicate any and all copyright interest in the
 * software to the public domain. We make this dedication for the benefit
 * of the public at large and to the detriment of our heirs and
 * successors. We intend this dedication to be an overt act of
 * relinquishment in perpetuity of all present and future rights to this
 * software under copyright law.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 * 
 * For more information, please refer to <http://unlicense.org>
 * 
 */ /*jshint devel:true, asi:true */ /*global define, module */ (function(root, factory) {
    if (typeof define === "function" && define.amd) {
        ((r)=>r !== undefined && __turbopack_context__.v(r))(factory()());
    } else if (("TURBOPACK compile-time value", "object") === "object" && module.exports) {
        module.exports = factory();
    } else {
        (function install() {
            // To make sure Zenscroll can be referenced from the header, before `body` is available
            if (document && document.body) {
                root.zenscroll = factory();
            } else {
                // retry 9ms later
                setTimeout(install, 9);
            }
        })();
    }
})(/*TURBOPACK member replacement*/ __turbopack_context__.e, function() {
    "use strict";
    // Detect if the browser already supports native smooth scrolling (e.g., Firefox 36+ and Chrome 49+) and it is enabled:
    var isNativeSmoothScrollEnabledOn = function(elem) {
        return elem && "getComputedStyle" in window && window.getComputedStyle(elem)["scroll-behavior"] === "smooth";
    };
    // Exit if its not a browser environment:
    if (typeof window === "undefined" || !("document" in window)) {
        return {};
    }
    var makeScroller = function(container, defaultDuration, edgeOffset) {
        // Use defaults if not provided
        defaultDuration = defaultDuration || 999; //ms
        if (!edgeOffset && edgeOffset !== 0) {
            // When scrolling, this amount of distance is kept from the edges of the container:
            edgeOffset = 9; //px
        }
        // Handling the life-cycle of the scroller
        var scrollTimeoutId;
        var setScrollTimeoutId = function(newValue) {
            scrollTimeoutId = newValue;
        };
        /**
		 * Stop the current smooth scroll operation immediately
		 */ var stopScroll = function() {
            clearTimeout(scrollTimeoutId);
            setScrollTimeoutId(0);
        };
        var getTopWithEdgeOffset = function(elem) {
            return Math.max(0, container.getTopOf(elem) - edgeOffset);
        };
        /**
		 * Scrolls to a specific vertical position in the document.
		 *
		 * @param {targetY} The vertical position within the document.
		 * @param {duration} Optionally the duration of the scroll operation.
		 *        If not provided the default duration is used.
		 * @param {onDone} An optional callback function to be invoked once the scroll finished.
		 */ var scrollToY = function(targetY, duration, onDone) {
            stopScroll();
            if (duration === 0 || duration && duration < 0 || isNativeSmoothScrollEnabledOn(container.body)) {
                container.toY(targetY);
                if (onDone) {
                    onDone();
                }
            } else {
                var startY = container.getY();
                var distance = Math.max(0, targetY) - startY;
                var startTime = new Date().getTime();
                duration = duration || Math.min(Math.abs(distance), defaultDuration);
                (function loopScroll() {
                    setScrollTimeoutId(setTimeout(function() {
                        // Calculate percentage:
                        var p = Math.min(1, (new Date().getTime() - startTime) / duration);
                        // Calculate the absolute vertical position:
                        var y = Math.max(0, Math.floor(startY + distance * (p < 0.5 ? 2 * p * p : p * (4 - p * 2) - 1)));
                        container.toY(y);
                        if (p < 1 && container.getHeight() + y < container.body.scrollHeight) {
                            loopScroll();
                        } else {
                            setTimeout(stopScroll, 99); // with cooldown time
                            if (onDone) {
                                onDone();
                            }
                        }
                    }, 9));
                })();
            }
        };
        /**
		 * Scrolls to the top of a specific element.
		 *
		 * @param {elem} The element to scroll to.
		 * @param {duration} Optionally the duration of the scroll operation.
		 * @param {onDone} An optional callback function to be invoked once the scroll finished.
		 */ var scrollToElem = function(elem, duration, onDone) {
            scrollToY(getTopWithEdgeOffset(elem), duration, onDone);
        };
        /**
		 * Scrolls an element into view if necessary.
		 *
		 * @param {elem} The element.
		 * @param {duration} Optionally the duration of the scroll operation.
		 * @param {onDone} An optional callback function to be invoked once the scroll finished.
		 */ var scrollIntoView = function(elem, duration, onDone) {
            var elemHeight = elem.getBoundingClientRect().height;
            var elemBottom = container.getTopOf(elem) + elemHeight;
            var containerHeight = container.getHeight();
            var y = container.getY();
            var containerBottom = y + containerHeight;
            if (getTopWithEdgeOffset(elem) < y || elemHeight + edgeOffset > containerHeight) {
                // Element is clipped at top or is higher than screen.
                scrollToElem(elem, duration, onDone);
            } else if (elemBottom + edgeOffset > containerBottom) {
                // Element is clipped at the bottom.
                scrollToY(elemBottom - containerHeight + edgeOffset, duration, onDone);
            } else if (onDone) {
                onDone();
            }
        };
        /**
		 * Scrolls to the center of an element.
		 *
		 * @param {elem} The element.
		 * @param {duration} Optionally the duration of the scroll operation.
		 * @param {offset} Optionally the offset of the top of the element from the center of the screen.
		 *        A value of 0 is ignored.
		 * @param {onDone} An optional callback function to be invoked once the scroll finished.
		 */ var scrollToCenterOf = function(elem, duration, offset, onDone) {
            scrollToY(Math.max(0, container.getTopOf(elem) - container.getHeight() / 2 + (offset || elem.getBoundingClientRect().height / 2)), duration, onDone);
        };
        /**
		 * Changes default settings for this scroller.
		 *
		 * @param {newDefaultDuration} Optionally a new value for default duration, used for each scroll method by default.
		 *        Ignored if null or undefined.
		 * @param {newEdgeOffset} Optionally a new value for the edge offset, used by each scroll method by default. Ignored if null or undefined.
		 * @returns An object with the current values.
		 */ var setup = function(newDefaultDuration, newEdgeOffset) {
            if (newDefaultDuration === 0 || newDefaultDuration) {
                defaultDuration = newDefaultDuration;
            }
            if (newEdgeOffset === 0 || newEdgeOffset) {
                edgeOffset = newEdgeOffset;
            }
            return {
                defaultDuration: defaultDuration,
                edgeOffset: edgeOffset
            };
        };
        return {
            setup: setup,
            to: scrollToElem,
            toY: scrollToY,
            intoView: scrollIntoView,
            center: scrollToCenterOf,
            stop: stopScroll,
            moving: function() {
                return !!scrollTimeoutId;
            },
            getY: container.getY,
            getTopOf: container.getTopOf
        };
    };
    var docElem = document.documentElement;
    var getDocY = function() {
        return window.scrollY || docElem.scrollTop;
    };
    // Create a scroller for the document:
    var zenscroll = makeScroller({
        body: document.scrollingElement || document.body,
        toY: function(y) {
            window.scrollTo(0, y);
        },
        getY: getDocY,
        getHeight: function() {
            return window.innerHeight || docElem.clientHeight;
        },
        getTopOf: function(elem) {
            return elem.getBoundingClientRect().top + getDocY() - docElem.offsetTop;
        }
    });
    /**
	 * Creates a scroller from the provided container element (e.g., a DIV)
	 *
	 * @param {scrollContainer} The vertical position within the document.
	 * @param {defaultDuration} Optionally a value for default duration, used for each scroll method by default.
	 *        Ignored if 0 or null or undefined.
	 * @param {edgeOffset} Optionally a value for the edge offset, used by each scroll method by default. 
	 *        Ignored if null or undefined.
	 * @returns A scroller object, similar to `zenscroll` but controlling the provided element.
	 */ zenscroll.createScroller = function(scrollContainer, defaultDuration, edgeOffset) {
        return makeScroller({
            body: scrollContainer,
            toY: function(y) {
                scrollContainer.scrollTop = y;
            },
            getY: function() {
                return scrollContainer.scrollTop;
            },
            getHeight: function() {
                return Math.min(scrollContainer.clientHeight, window.innerHeight || docElem.clientHeight);
            },
            getTopOf: function(elem) {
                return elem.offsetTop;
            }
        }, defaultDuration, edgeOffset);
    };
    // Automatic link-smoothing on achors
    // Exclude IE8- or when native is enabled or Zenscroll auto- is disabled
    if ("addEventListener" in window && !window.noZensmooth && !isNativeSmoothScrollEnabledOn(document.body)) {
        var isHistorySupported = "history" in window && "pushState" in history;
        var isScrollRestorationSupported = isHistorySupported && "scrollRestoration" in history;
        // On first load & refresh make sure the browser restores the position first
        if (isScrollRestorationSupported) {
            history.scrollRestoration = "auto";
        }
        window.addEventListener("load", function() {
            if (isScrollRestorationSupported) {
                // Set it to manual
                setTimeout(function() {
                    history.scrollRestoration = "manual";
                }, 9);
                window.addEventListener("popstate", function(event) {
                    if (event.state && "zenscrollY" in event.state) {
                        zenscroll.toY(event.state.zenscrollY);
                    }
                }, false);
            }
            // Add edge offset on first load if necessary
            // This may not work on IE (or older computer?) as it requires more timeout, around 100 ms
            if (window.location.hash) {
                setTimeout(function() {
                    // Adjustment is only needed if there is an edge offset:
                    var edgeOffset = zenscroll.setup().edgeOffset;
                    if (edgeOffset) {
                        var targetElem = document.getElementById(window.location.href.split("#")[1]);
                        if (targetElem) {
                            var targetY = Math.max(0, zenscroll.getTopOf(targetElem) - edgeOffset);
                            var diff = zenscroll.getY() - targetY;
                            // Only do the adjustment if the browser is very close to the element:
                            if (0 <= diff && diff < 9) {
                                window.scrollTo(0, targetY);
                            }
                        }
                    }
                }, 9);
            }
        }, false);
        // Handling clicks on anchors
        var RE_noZensmooth = new RegExp("(^|\\s)noZensmooth(\\s|$)");
        window.addEventListener("click", function(event) {
            var anchor = event.target;
            while(anchor && anchor.tagName !== "A"){
                anchor = anchor.parentNode;
            }
            // Let the browser handle the click if it wasn't with the primary button, or with some modifier keys:
            if (!anchor || event.which !== 1 || event.shiftKey || event.metaKey || event.ctrlKey || event.altKey) {
                return;
            }
            // Save the current scrolling position so it can be used for scroll restoration:
            if (isScrollRestorationSupported) {
                var historyState = history.state && typeof history.state === "object" ? history.state : {};
                historyState.zenscrollY = zenscroll.getY();
                try {
                    history.replaceState(historyState, "");
                } catch (e) {
                // Avoid the Chrome Security exception on file protocol, e.g., file://index.html
                }
            }
            // Find the referenced ID:
            var href = anchor.getAttribute("href") || "";
            if (href.indexOf("#") === 0 && !RE_noZensmooth.test(anchor.className)) {
                var targetY = 0;
                var targetElem = document.getElementById(href.substring(1));
                if (href !== "#") {
                    if (!targetElem) {
                        // Let the browser handle the click if the target ID is not found.
                        return;
                    }
                    targetY = zenscroll.getTopOf(targetElem);
                }
                event.preventDefault();
                // By default trigger the browser's `hashchange` event...
                var onDone = function() {
                    window.location = href;
                };
                // ...unless there is an edge offset specified
                var edgeOffset = zenscroll.setup().edgeOffset;
                if (edgeOffset) {
                    targetY = Math.max(0, targetY - edgeOffset);
                    if (isHistorySupported) {
                        onDone = function() {
                            history.pushState({}, "", href);
                        };
                    }
                }
                zenscroll.toY(targetY, null, onDone);
            }
        }, false);
    }
    return zenscroll;
});
}),
"[project]/node_modules/react-immutable-proptypes/dist/ImmutablePropTypes.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * This is a straight rip-off of the React.js ReactPropTypes.js proptype validators,
 * modified to make it possible to validate Immutable.js data.
 *     ImmutableTypes.listOf is patterned after React.PropTypes.arrayOf, but for Immutable.List
 *     ImmutableTypes.shape  is based on React.PropTypes.shape, but for any Immutable.Iterable
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
var Immutable = __turbopack_context__.r("[project]/node_modules/immutable/dist/immutable.js [app-client] (ecmascript)");
var ANONYMOUS = "<<anonymous>>";
var ImmutablePropTypes;
if ("TURBOPACK compile-time truthy", 1) {
    ImmutablePropTypes = {
        listOf: createListOfTypeChecker,
        mapOf: createMapOfTypeChecker,
        orderedMapOf: createOrderedMapOfTypeChecker,
        setOf: createSetOfTypeChecker,
        orderedSetOf: createOrderedSetOfTypeChecker,
        stackOf: createStackOfTypeChecker,
        iterableOf: createIterableOfTypeChecker,
        recordOf: createRecordOfTypeChecker,
        shape: createShapeChecker,
        contains: createShapeChecker,
        mapContains: createMapContainsChecker,
        orderedMapContains: createOrderedMapContainsChecker,
        // Primitive Types
        list: createImmutableTypeChecker("List", Immutable.List.isList),
        map: createImmutableTypeChecker("Map", Immutable.Map.isMap),
        orderedMap: createImmutableTypeChecker("OrderedMap", Immutable.OrderedMap.isOrderedMap),
        set: createImmutableTypeChecker("Set", Immutable.Set.isSet),
        orderedSet: createImmutableTypeChecker("OrderedSet", Immutable.OrderedSet.isOrderedSet),
        stack: createImmutableTypeChecker("Stack", Immutable.Stack.isStack),
        seq: createImmutableTypeChecker("Seq", Immutable.Seq.isSeq),
        record: createImmutableTypeChecker("Record", function(isRecord) {
            return isRecord instanceof Immutable.Record;
        }),
        iterable: createImmutableTypeChecker("Iterable", Immutable.Iterable.isIterable)
    };
} else //TURBOPACK unreachable
{
    var productionTypeChecker;
    var getProductionTypeChecker;
/*TURBOPACK member replacement*/ }
ImmutablePropTypes.iterable.indexed = createIterableSubclassTypeChecker("Indexed", Immutable.Iterable.isIndexed);
ImmutablePropTypes.iterable.keyed = createIterableSubclassTypeChecker("Keyed", Immutable.Iterable.isKeyed);
function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
        return "array";
    }
    if (propValue instanceof RegExp) {
        // Old webkits (at least until Android 4.0) return 'function' rather than
        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
        // passes PropTypes.object.
        return "object";
    }
    if (propValue instanceof Immutable.Iterable) {
        return "Immutable." + propValue.toSource().split(" ")[0];
    }
    return propType;
}
function createChainableTypeChecker(validate) {
    function checkType(isRequired, props, propName, componentName, location, propFullName) {
        for(var _len = arguments.length, rest = Array(_len > 6 ? _len - 6 : 0), _key = 6; _key < _len; _key++){
            rest[_key - 6] = arguments[_key];
        }
        propFullName = propFullName || propName;
        componentName = componentName || ANONYMOUS;
        if (props[propName] == null) {
            var locationName = location;
            if (isRequired) {
                return new Error("Required " + locationName + " `" + propFullName + "` was not specified in " + ("`" + componentName + "`."));
            }
        } else {
            return validate.apply(undefined, [
                props,
                propName,
                componentName,
                location,
                propFullName
            ].concat(rest));
        }
    }
    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);
    return chainedCheckType;
}
function createImmutableTypeChecker(immutableClassName, immutableClassTypeValidator) {
    function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        if (!immutableClassTypeValidator(propValue)) {
            var propType = getPropType(propValue);
            return new Error("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `" + immutableClassName + "`."));
        }
        return null;
    }
    return createChainableTypeChecker(validate);
}
function createIterableSubclassTypeChecker(subclassName, validator) {
    return createImmutableTypeChecker("Iterable." + subclassName, function(propValue) {
        return Immutable.Iterable.isIterable(propValue) && validator(propValue);
    });
}
function createIterableTypeChecker(typeChecker, immutableClassName, immutableClassTypeValidator) {
    function validate(props, propName, componentName, location, propFullName) {
        for(var _len = arguments.length, rest = Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++){
            rest[_key - 5] = arguments[_key];
        }
        var propValue = props[propName];
        if (!immutableClassTypeValidator(propValue)) {
            var locationName = location;
            var propType = getPropType(propValue);
            return new Error("Invalid " + locationName + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an Immutable.js " + immutableClassName + "."));
        }
        if (typeof typeChecker !== "function") {
            return new Error("Invalid typeChecker supplied to `" + componentName + "` " + ("for propType `" + propFullName + "`, expected a function."));
        }
        var propValues = propValue.valueSeq().toArray();
        for(var i = 0, len = propValues.length; i < len; i++){
            var error = typeChecker.apply(undefined, [
                propValues,
                i,
                componentName,
                location,
                "" + propFullName + "[" + i + "]"
            ].concat(rest));
            if (error instanceof Error) {
                return error;
            }
        }
    }
    return createChainableTypeChecker(validate);
}
function createKeysTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
        for(var _len = arguments.length, rest = Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++){
            rest[_key - 5] = arguments[_key];
        }
        var propValue = props[propName];
        if (typeof typeChecker !== "function") {
            return new Error("Invalid keysTypeChecker (optional second argument) supplied to `" + componentName + "` " + ("for propType `" + propFullName + "`, expected a function."));
        }
        var keys = propValue.keySeq().toArray();
        for(var i = 0, len = keys.length; i < len; i++){
            var error = typeChecker.apply(undefined, [
                keys,
                i,
                componentName,
                location,
                "" + propFullName + " -> key(" + keys[i] + ")"
            ].concat(rest));
            if (error instanceof Error) {
                return error;
            }
        }
    }
    return createChainableTypeChecker(validate);
}
function createListOfTypeChecker(typeChecker) {
    return createIterableTypeChecker(typeChecker, "List", Immutable.List.isList);
}
function createMapOfTypeCheckerFactory(valuesTypeChecker, keysTypeChecker, immutableClassName, immutableClassTypeValidator) {
    function validate() {
        for(var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        return createIterableTypeChecker(valuesTypeChecker, immutableClassName, immutableClassTypeValidator).apply(undefined, args) || keysTypeChecker && createKeysTypeChecker(keysTypeChecker).apply(undefined, args);
    }
    return createChainableTypeChecker(validate);
}
function createMapOfTypeChecker(valuesTypeChecker, keysTypeChecker) {
    return createMapOfTypeCheckerFactory(valuesTypeChecker, keysTypeChecker, "Map", Immutable.Map.isMap);
}
function createOrderedMapOfTypeChecker(valuesTypeChecker, keysTypeChecker) {
    return createMapOfTypeCheckerFactory(valuesTypeChecker, keysTypeChecker, "OrderedMap", Immutable.OrderedMap.isOrderedMap);
}
function createSetOfTypeChecker(typeChecker) {
    return createIterableTypeChecker(typeChecker, "Set", Immutable.Set.isSet);
}
function createOrderedSetOfTypeChecker(typeChecker) {
    return createIterableTypeChecker(typeChecker, "OrderedSet", Immutable.OrderedSet.isOrderedSet);
}
function createStackOfTypeChecker(typeChecker) {
    return createIterableTypeChecker(typeChecker, "Stack", Immutable.Stack.isStack);
}
function createIterableOfTypeChecker(typeChecker) {
    return createIterableTypeChecker(typeChecker, "Iterable", Immutable.Iterable.isIterable);
}
function createRecordOfTypeChecker(recordKeys) {
    function validate(props, propName, componentName, location, propFullName) {
        for(var _len = arguments.length, rest = Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++){
            rest[_key - 5] = arguments[_key];
        }
        var propValue = props[propName];
        if (!(propValue instanceof Immutable.Record)) {
            var propType = getPropType(propValue);
            var locationName = location;
            return new Error("Invalid " + locationName + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected an Immutable.js Record."));
        }
        for(var key in recordKeys){
            var checker = recordKeys[key];
            if (!checker) {
                continue;
            }
            var mutablePropValue = propValue.toObject();
            var error = checker.apply(undefined, [
                mutablePropValue,
                key,
                componentName,
                location,
                "" + propFullName + "." + key
            ].concat(rest));
            if (error) {
                return error;
            }
        }
    }
    return createChainableTypeChecker(validate);
}
// there is some irony in the fact that shapeTypes is a standard hash and not an immutable collection
function createShapeTypeChecker(shapeTypes) {
    var immutableClassName = arguments[1] === undefined ? "Iterable" : arguments[1];
    var immutableClassTypeValidator = arguments[2] === undefined ? Immutable.Iterable.isIterable : arguments[2];
    function validate(props, propName, componentName, location, propFullName) {
        for(var _len = arguments.length, rest = Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++){
            rest[_key - 5] = arguments[_key];
        }
        var propValue = props[propName];
        if (!immutableClassTypeValidator(propValue)) {
            var propType = getPropType(propValue);
            var locationName = location;
            return new Error("Invalid " + locationName + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected an Immutable.js " + immutableClassName + "."));
        }
        var mutablePropValue = propValue.toObject();
        for(var key in shapeTypes){
            var checker = shapeTypes[key];
            if (!checker) {
                continue;
            }
            var error = checker.apply(undefined, [
                mutablePropValue,
                key,
                componentName,
                location,
                "" + propFullName + "." + key
            ].concat(rest));
            if (error) {
                return error;
            }
        }
    }
    return createChainableTypeChecker(validate);
}
function createShapeChecker(shapeTypes) {
    return createShapeTypeChecker(shapeTypes);
}
function createMapContainsChecker(shapeTypes) {
    return createShapeTypeChecker(shapeTypes, "Map", Immutable.Map.isMap);
}
function createOrderedMapContainsChecker(shapeTypes) {
    return createShapeTypeChecker(shapeTypes, "OrderedMap", Immutable.OrderedMap.isOrderedMap);
}
module.exports = ImmutablePropTypes;
}),
"[project]/node_modules/core-js-pure/internals/global-this.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var check = function(it) {
    return it && it.Math === Math && it;
};
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports = // eslint-disable-next-line es/no-global-this -- safe
check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || // eslint-disable-next-line no-restricted-globals -- safe
check(typeof self == 'object' && self) || check(("TURBOPACK compile-time value", "object") == 'object' && /*TURBOPACK member replacement*/ __turbopack_context__.g) || check(typeof /*TURBOPACK member replacement*/ __turbopack_context__.e == 'object' && /*TURBOPACK member replacement*/ __turbopack_context__.e) || // eslint-disable-next-line no-new-func -- fallback
function() {
    return this;
}() || Function('return this')();
}),
"[project]/node_modules/core-js-pure/internals/fails.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function(exec) {
    try {
        return !!exec();
    } catch (error) {
        return true;
    }
};
}),
"[project]/node_modules/core-js-pure/internals/function-bind-native.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var fails = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/fails.js [app-client] (ecmascript)");
module.exports = !fails(function() {
    // eslint-disable-next-line es/no-function-prototype-bind -- safe
    var test = (function() {}).bind();
    // eslint-disable-next-line no-prototype-builtins -- safe
    return typeof test != 'function' || test.hasOwnProperty('prototype');
});
}),
"[project]/node_modules/core-js-pure/internals/function-apply.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var NATIVE_BIND = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-bind-native.js [app-client] (ecmascript)");
var FunctionPrototype = Function.prototype;
var apply = FunctionPrototype.apply;
var call = FunctionPrototype.call;
// eslint-disable-next-line es/no-function-prototype-bind, es/no-reflect -- safe
module.exports = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
    return call.apply(apply, arguments);
});
}),
"[project]/node_modules/core-js-pure/internals/function-uncurry-this.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var NATIVE_BIND = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-bind-native.js [app-client] (ecmascript)");
var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
// eslint-disable-next-line es/no-function-prototype-bind -- safe
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
module.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
    return function() {
        return call.apply(fn, arguments);
    };
};
}),
"[project]/node_modules/core-js-pure/internals/classof-raw.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var uncurryThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-uncurry-this.js [app-client] (ecmascript)");
var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);
module.exports = function(it) {
    return stringSlice(toString(it), 8, -1);
};
}),
"[project]/node_modules/core-js-pure/internals/function-uncurry-this-clause.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var classofRaw = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/classof-raw.js [app-client] (ecmascript)");
var uncurryThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-uncurry-this.js [app-client] (ecmascript)");
module.exports = function(fn) {
    // Nashorn bug:
    //   https://github.com/zloirock/core-js/issues/1128
    //   https://github.com/zloirock/core-js/issues/1130
    if (classofRaw(fn) === 'Function') return uncurryThis(fn);
};
}),
"[project]/node_modules/core-js-pure/internals/is-callable.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
var documentAll = typeof document == 'object' && document.all;
// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
module.exports = typeof documentAll == 'undefined' && documentAll !== undefined ? function(argument) {
    return typeof argument == 'function' || argument === documentAll;
} : function(argument) {
    return typeof argument == 'function';
};
}),
"[project]/node_modules/core-js-pure/internals/descriptors.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var fails = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/fails.js [app-client] (ecmascript)");
// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function() {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty({}, 1, {
        get: function() {
            return 7;
        }
    })[1] !== 7;
});
}),
"[project]/node_modules/core-js-pure/internals/function-call.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var NATIVE_BIND = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-bind-native.js [app-client] (ecmascript)");
var call = Function.prototype.call;
// eslint-disable-next-line es/no-function-prototype-bind -- safe
module.exports = NATIVE_BIND ? call.bind(call) : function() {
    return call.apply(call, arguments);
};
}),
"[project]/node_modules/core-js-pure/internals/object-property-is-enumerable.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({
    1: 2
}, 1);
// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
    var descriptor = getOwnPropertyDescriptor(this, V);
    return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;
}),
"[project]/node_modules/core-js-pure/internals/create-property-descriptor.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function(bitmap, value) {
    return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value: value
    };
};
}),
"[project]/node_modules/core-js-pure/internals/indexed-object.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var uncurryThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-uncurry-this.js [app-client] (ecmascript)");
var fails = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/fails.js [app-client] (ecmascript)");
var classof = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/classof-raw.js [app-client] (ecmascript)");
var $Object = Object;
var split = uncurryThis(''.split);
// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function() {
    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
    // eslint-disable-next-line no-prototype-builtins -- safe
    return !$Object('z').propertyIsEnumerable(0);
}) ? function(it) {
    return classof(it) === 'String' ? split(it, '') : $Object(it);
} : $Object;
}),
"[project]/node_modules/core-js-pure/internals/is-null-or-undefined.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function(it) {
    return it === null || it === undefined;
};
}),
"[project]/node_modules/core-js-pure/internals/require-object-coercible.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var isNullOrUndefined = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-null-or-undefined.js [app-client] (ecmascript)");
var $TypeError = TypeError;
// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function(it) {
    if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
    return it;
};
}),
"[project]/node_modules/core-js-pure/internals/to-indexed-object.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/indexed-object.js [app-client] (ecmascript)");
var requireObjectCoercible = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/require-object-coercible.js [app-client] (ecmascript)");
module.exports = function(it) {
    return IndexedObject(requireObjectCoercible(it));
};
}),
"[project]/node_modules/core-js-pure/internals/is-object.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var isCallable = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-callable.js [app-client] (ecmascript)");
module.exports = function(it) {
    return typeof it == 'object' ? it !== null : isCallable(it);
};
}),
"[project]/node_modules/core-js-pure/internals/path.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = {};
}),
"[project]/node_modules/core-js-pure/internals/get-built-in.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var path = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/path.js [app-client] (ecmascript)");
var globalThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/global-this.js [app-client] (ecmascript)");
var isCallable = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-callable.js [app-client] (ecmascript)");
var aFunction = function(variable) {
    return isCallable(variable) ? variable : undefined;
};
module.exports = function(namespace, method) {
    return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(globalThis[namespace]) : path[namespace] && path[namespace][method] || globalThis[namespace] && globalThis[namespace][method];
};
}),
"[project]/node_modules/core-js-pure/internals/object-is-prototype-of.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var uncurryThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-uncurry-this.js [app-client] (ecmascript)");
module.exports = uncurryThis({}.isPrototypeOf);
}),
"[project]/node_modules/core-js-pure/internals/environment-user-agent.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var globalThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/global-this.js [app-client] (ecmascript)");
var navigator = globalThis.navigator;
var userAgent = navigator && navigator.userAgent;
module.exports = userAgent ? String(userAgent) : '';
}),
"[project]/node_modules/core-js-pure/internals/environment-v8-version.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var globalThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/global-this.js [app-client] (ecmascript)");
var userAgent = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/environment-user-agent.js [app-client] (ecmascript)");
var process = globalThis.process;
var Deno = globalThis.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;
if (v8) {
    match = v8.split('.');
    // in old Chrome, versions of V8 isn't V8 = Chrome / 10
    // but their correct versions are not interesting for us
    version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}
// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
    match = userAgent.match(/Edge\/(\d+)/);
    if (!match || match[1] >= 74) {
        match = userAgent.match(/Chrome\/(\d+)/);
        if (match) version = +match[1];
    }
}
module.exports = version;
}),
"[project]/node_modules/core-js-pure/internals/symbol-constructor-detection.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint-disable es/no-symbol -- required for testing */ var V8_VERSION = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/environment-v8-version.js [app-client] (ecmascript)");
var fails = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/fails.js [app-client] (ecmascript)");
var globalThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/global-this.js [app-client] (ecmascript)");
var $String = globalThis.String;
// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function() {
    var symbol = Symbol('symbol detection');
    // Chrome 38 Symbol has incorrect toString conversion
    // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
    // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
    // of course, fail.
    return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});
}),
"[project]/node_modules/core-js-pure/internals/use-symbol-as-uid.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint-disable es/no-symbol -- required for testing */ var NATIVE_SYMBOL = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/symbol-constructor-detection.js [app-client] (ecmascript)");
module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == 'symbol';
}),
"[project]/node_modules/core-js-pure/internals/is-symbol.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var getBuiltIn = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/get-built-in.js [app-client] (ecmascript)");
var isCallable = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-callable.js [app-client] (ecmascript)");
var isPrototypeOf = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-is-prototype-of.js [app-client] (ecmascript)");
var USE_SYMBOL_AS_UID = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/use-symbol-as-uid.js [app-client] (ecmascript)");
var $Object = Object;
module.exports = USE_SYMBOL_AS_UID ? function(it) {
    return typeof it == 'symbol';
} : function(it) {
    var $Symbol = getBuiltIn('Symbol');
    return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};
}),
"[project]/node_modules/core-js-pure/internals/try-to-string.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $String = String;
module.exports = function(argument) {
    try {
        return $String(argument);
    } catch (error) {
        return 'Object';
    }
};
}),
"[project]/node_modules/core-js-pure/internals/a-callable.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var isCallable = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-callable.js [app-client] (ecmascript)");
var tryToString = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/try-to-string.js [app-client] (ecmascript)");
var $TypeError = TypeError;
// `Assert: IsCallable(argument) is true`
module.exports = function(argument) {
    if (isCallable(argument)) return argument;
    throw new $TypeError(tryToString(argument) + ' is not a function');
};
}),
"[project]/node_modules/core-js-pure/internals/get-method.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var aCallable = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/a-callable.js [app-client] (ecmascript)");
var isNullOrUndefined = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-null-or-undefined.js [app-client] (ecmascript)");
// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function(V, P) {
    var func = V[P];
    return isNullOrUndefined(func) ? undefined : aCallable(func);
};
}),
"[project]/node_modules/core-js-pure/internals/ordinary-to-primitive.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var call = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-call.js [app-client] (ecmascript)");
var isCallable = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-callable.js [app-client] (ecmascript)");
var isObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-object.js [app-client] (ecmascript)");
var $TypeError = TypeError;
// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function(input, pref) {
    var fn, val;
    if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
    if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
    if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
    throw new $TypeError("Can't convert object to primitive value");
};
}),
"[project]/node_modules/core-js-pure/internals/is-pure.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = true;
}),
"[project]/node_modules/core-js-pure/internals/define-global-property.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var globalThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/global-this.js [app-client] (ecmascript)");
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;
module.exports = function(key, value) {
    try {
        defineProperty(globalThis, key, {
            value: value,
            configurable: true,
            writable: true
        });
    } catch (error) {
        globalThis[key] = value;
    }
    return value;
};
}),
"[project]/node_modules/core-js-pure/internals/shared-store.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var IS_PURE = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-pure.js [app-client] (ecmascript)");
var globalThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/global-this.js [app-client] (ecmascript)");
var defineGlobalProperty = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/define-global-property.js [app-client] (ecmascript)");
var SHARED = '__core-js_shared__';
var store = module.exports = globalThis[SHARED] || defineGlobalProperty(SHARED, {});
(store.versions || (store.versions = [])).push({
    version: '3.46.0',
    mode: IS_PURE ? 'pure' : 'global',
    copyright: ' 2014-2025 Denis Pushkarev (zloirock.ru), 2025 CoreJS Company (core-js.io)',
    license: 'https://github.com/zloirock/core-js/blob/v3.46.0/LICENSE',
    source: 'https://github.com/zloirock/core-js'
});
}),
"[project]/node_modules/core-js-pure/internals/shared.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var store = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/shared-store.js [app-client] (ecmascript)");
module.exports = function(key, value) {
    return store[key] || (store[key] = value || {});
};
}),
"[project]/node_modules/core-js-pure/internals/to-object.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var requireObjectCoercible = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/require-object-coercible.js [app-client] (ecmascript)");
var $Object = Object;
// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function(argument) {
    return $Object(requireObjectCoercible(argument));
};
}),
"[project]/node_modules/core-js-pure/internals/has-own-property.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var uncurryThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-uncurry-this.js [app-client] (ecmascript)");
var toObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/to-object.js [app-client] (ecmascript)");
var hasOwnProperty = uncurryThis({}.hasOwnProperty);
// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
    return hasOwnProperty(toObject(it), key);
};
}),
"[project]/node_modules/core-js-pure/internals/uid.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var uncurryThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-uncurry-this.js [app-client] (ecmascript)");
var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.1.toString);
module.exports = function(key) {
    return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};
}),
"[project]/node_modules/core-js-pure/internals/well-known-symbol.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var globalThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/global-this.js [app-client] (ecmascript)");
var shared = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/shared.js [app-client] (ecmascript)");
var hasOwn = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/has-own-property.js [app-client] (ecmascript)");
var uid = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/uid.js [app-client] (ecmascript)");
var NATIVE_SYMBOL = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/symbol-constructor-detection.js [app-client] (ecmascript)");
var USE_SYMBOL_AS_UID = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/use-symbol-as-uid.js [app-client] (ecmascript)");
var Symbol = globalThis.Symbol;
var WellKnownSymbolsStore = shared('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;
module.exports = function(name) {
    if (!hasOwn(WellKnownSymbolsStore, name)) {
        WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name) ? Symbol[name] : createWellKnownSymbol('Symbol.' + name);
    }
    return WellKnownSymbolsStore[name];
};
}),
"[project]/node_modules/core-js-pure/internals/to-primitive.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var call = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-call.js [app-client] (ecmascript)");
var isObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-object.js [app-client] (ecmascript)");
var isSymbol = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-symbol.js [app-client] (ecmascript)");
var getMethod = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/get-method.js [app-client] (ecmascript)");
var ordinaryToPrimitive = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/ordinary-to-primitive.js [app-client] (ecmascript)");
var wellKnownSymbol = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/well-known-symbol.js [app-client] (ecmascript)");
var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function(input, pref) {
    if (!isObject(input) || isSymbol(input)) return input;
    var exoticToPrim = getMethod(input, TO_PRIMITIVE);
    var result;
    if (exoticToPrim) {
        if (pref === undefined) pref = 'default';
        result = call(exoticToPrim, input, pref);
        if (!isObject(result) || isSymbol(result)) return result;
        throw new $TypeError("Can't convert object to primitive value");
    }
    if (pref === undefined) pref = 'number';
    return ordinaryToPrimitive(input, pref);
};
}),
"[project]/node_modules/core-js-pure/internals/to-property-key.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var toPrimitive = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/to-primitive.js [app-client] (ecmascript)");
var isSymbol = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-symbol.js [app-client] (ecmascript)");
// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function(argument) {
    var key = toPrimitive(argument, 'string');
    return isSymbol(key) ? key : key + '';
};
}),
"[project]/node_modules/core-js-pure/internals/document-create-element.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var globalThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/global-this.js [app-client] (ecmascript)");
var isObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-object.js [app-client] (ecmascript)");
var document = globalThis.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);
module.exports = function(it) {
    return EXISTS ? document.createElement(it) : {};
};
}),
"[project]/node_modules/core-js-pure/internals/ie8-dom-define.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var DESCRIPTORS = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/descriptors.js [app-client] (ecmascript)");
var fails = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/fails.js [app-client] (ecmascript)");
var createElement = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/document-create-element.js [app-client] (ecmascript)");
// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function() {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty(createElement('div'), 'a', {
        get: function() {
            return 7;
        }
    }).a !== 7;
});
}),
"[project]/node_modules/core-js-pure/internals/object-get-own-property-descriptor.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var DESCRIPTORS = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/descriptors.js [app-client] (ecmascript)");
var call = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-call.js [app-client] (ecmascript)");
var propertyIsEnumerableModule = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-property-is-enumerable.js [app-client] (ecmascript)");
var createPropertyDescriptor = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/create-property-descriptor.js [app-client] (ecmascript)");
var toIndexedObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/to-indexed-object.js [app-client] (ecmascript)");
var toPropertyKey = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/to-property-key.js [app-client] (ecmascript)");
var hasOwn = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/has-own-property.js [app-client] (ecmascript)");
var IE8_DOM_DEFINE = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/ie8-dom-define.js [app-client] (ecmascript)");
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
    O = toIndexedObject(O);
    P = toPropertyKey(P);
    if (IE8_DOM_DEFINE) try {
        return $getOwnPropertyDescriptor(O, P);
    } catch (error) {}
    if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};
}),
"[project]/node_modules/core-js-pure/internals/is-forced.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var fails = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/fails.js [app-client] (ecmascript)");
var isCallable = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-callable.js [app-client] (ecmascript)");
var replacement = /#|\.prototype\./;
var isForced = function(feature, detection) {
    var value = data[normalize(feature)];
    return value === POLYFILL ? true : value === NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
};
var normalize = isForced.normalize = function(string) {
    return String(string).replace(replacement, '.').toLowerCase();
};
var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';
module.exports = isForced;
}),
"[project]/node_modules/core-js-pure/internals/function-bind-context.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var uncurryThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-uncurry-this-clause.js [app-client] (ecmascript)");
var aCallable = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/a-callable.js [app-client] (ecmascript)");
var NATIVE_BIND = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-bind-native.js [app-client] (ecmascript)");
var bind = uncurryThis(uncurryThis.bind);
// optional / simple context binding
module.exports = function(fn, that) {
    aCallable(fn);
    return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function() {
        return fn.apply(that, arguments);
    };
};
}),
"[project]/node_modules/core-js-pure/internals/v8-prototype-define-bug.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var DESCRIPTORS = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/descriptors.js [app-client] (ecmascript)");
var fails = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/fails.js [app-client] (ecmascript)");
// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function() {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty(function() {}, 'prototype', {
        value: 42,
        writable: false
    }).prototype !== 42;
});
}),
"[project]/node_modules/core-js-pure/internals/an-object.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var isObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-object.js [app-client] (ecmascript)");
var $String = String;
var $TypeError = TypeError;
// `Assert: Type(argument) is Object`
module.exports = function(argument) {
    if (isObject(argument)) return argument;
    throw new $TypeError($String(argument) + ' is not an object');
};
}),
"[project]/node_modules/core-js-pure/internals/object-define-property.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var DESCRIPTORS = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/descriptors.js [app-client] (ecmascript)");
var IE8_DOM_DEFINE = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/ie8-dom-define.js [app-client] (ecmascript)");
var V8_PROTOTYPE_DEFINE_BUG = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/v8-prototype-define-bug.js [app-client] (ecmascript)");
var anObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/an-object.js [app-client] (ecmascript)");
var toPropertyKey = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/to-property-key.js [app-client] (ecmascript)");
var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';
// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPropertyKey(P);
    anObject(Attributes);
    if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
        var current = $getOwnPropertyDescriptor(O, P);
        if (current && current[WRITABLE]) {
            O[P] = Attributes.value;
            Attributes = {
                configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
                enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
                writable: false
            };
        }
    }
    return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPropertyKey(P);
    anObject(Attributes);
    if (IE8_DOM_DEFINE) try {
        return $defineProperty(O, P, Attributes);
    } catch (error) {}
    if ('get' in Attributes || 'set' in Attributes) throw new $TypeError('Accessors not supported');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
};
}),
"[project]/node_modules/core-js-pure/internals/create-non-enumerable-property.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var DESCRIPTORS = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/descriptors.js [app-client] (ecmascript)");
var definePropertyModule = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-define-property.js [app-client] (ecmascript)");
var createPropertyDescriptor = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/create-property-descriptor.js [app-client] (ecmascript)");
module.exports = DESCRIPTORS ? function(object, key, value) {
    return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function(object, key, value) {
    object[key] = value;
    return object;
};
}),
"[project]/node_modules/core-js-pure/internals/export.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var globalThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/global-this.js [app-client] (ecmascript)");
var apply = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-apply.js [app-client] (ecmascript)");
var uncurryThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-uncurry-this-clause.js [app-client] (ecmascript)");
var isCallable = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-callable.js [app-client] (ecmascript)");
var getOwnPropertyDescriptor = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-get-own-property-descriptor.js [app-client] (ecmascript)").f;
var isForced = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-forced.js [app-client] (ecmascript)");
var path = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/path.js [app-client] (ecmascript)");
var bind = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-bind-context.js [app-client] (ecmascript)");
var createNonEnumerableProperty = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/create-non-enumerable-property.js [app-client] (ecmascript)");
var hasOwn = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/has-own-property.js [app-client] (ecmascript)");
// add debugging info
__turbopack_context__.r("[project]/node_modules/core-js-pure/internals/shared-store.js [app-client] (ecmascript)");
var wrapConstructor = function(NativeConstructor) {
    var Wrapper = function(a, b, c) {
        if (this instanceof Wrapper) {
            switch(arguments.length){
                case 0:
                    return new NativeConstructor();
                case 1:
                    return new NativeConstructor(a);
                case 2:
                    return new NativeConstructor(a, b);
            }
            return new NativeConstructor(a, b, c);
        }
        return apply(NativeConstructor, this, arguments);
    };
    Wrapper.prototype = NativeConstructor.prototype;
    return Wrapper;
};
/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/ module.exports = function(options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var PROTO = options.proto;
    var nativeSource = GLOBAL ? globalThis : STATIC ? globalThis[TARGET] : globalThis[TARGET] && globalThis[TARGET].prototype;
    var target = GLOBAL ? path : path[TARGET] || createNonEnumerableProperty(path, TARGET, {})[TARGET];
    var targetPrototype = target.prototype;
    var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
    var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;
    for(key in source){
        FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
        // contains in native
        USE_NATIVE = !FORCED && nativeSource && hasOwn(nativeSource, key);
        targetProperty = target[key];
        if (USE_NATIVE) if (options.dontCallGetSet) {
            descriptor = getOwnPropertyDescriptor(nativeSource, key);
            nativeProperty = descriptor && descriptor.value;
        } else nativeProperty = nativeSource[key];
        // export native or implementation
        sourceProperty = USE_NATIVE && nativeProperty ? nativeProperty : source[key];
        if (!FORCED && !PROTO && typeof targetProperty == typeof sourceProperty) continue;
        // bind methods to global for calling from export context
        if (options.bind && USE_NATIVE) resultProperty = bind(sourceProperty, globalThis);
        else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);
        else if (PROTO && isCallable(sourceProperty)) resultProperty = uncurryThis(sourceProperty);
        else resultProperty = sourceProperty;
        // add a flag to not completely full polyfills
        if (options.sham || sourceProperty && sourceProperty.sham || targetProperty && targetProperty.sham) {
            createNonEnumerableProperty(resultProperty, 'sham', true);
        }
        createNonEnumerableProperty(target, key, resultProperty);
        if (PROTO) {
            VIRTUAL_PROTOTYPE = TARGET + 'Prototype';
            if (!hasOwn(path, VIRTUAL_PROTOTYPE)) {
                createNonEnumerableProperty(path, VIRTUAL_PROTOTYPE, {});
            }
            // export virtual prototype methods
            createNonEnumerableProperty(path[VIRTUAL_PROTOTYPE], key, sourceProperty);
            // export real prototype methods
            if (options.real && targetPrototype && (FORCED || !targetPrototype[key])) {
                createNonEnumerableProperty(targetPrototype, key, sourceProperty);
            }
        }
    }
};
}),
"[project]/node_modules/core-js-pure/internals/math-trunc.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var ceil = Math.ceil;
var floor = Math.floor;
// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
    var n = +x;
    return (n > 0 ? floor : ceil)(n);
};
}),
"[project]/node_modules/core-js-pure/internals/to-integer-or-infinity.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var trunc = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/math-trunc.js [app-client] (ecmascript)");
// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function(argument) {
    var number = +argument;
    // eslint-disable-next-line no-self-compare -- NaN check
    return number !== number || number === 0 ? 0 : trunc(number);
};
}),
"[project]/node_modules/core-js-pure/internals/to-absolute-index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var toIntegerOrInfinity = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/to-integer-or-infinity.js [app-client] (ecmascript)");
var max = Math.max;
var min = Math.min;
// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function(index, length) {
    var integer = toIntegerOrInfinity(index);
    return integer < 0 ? max(integer + length, 0) : min(integer, length);
};
}),
"[project]/node_modules/core-js-pure/internals/to-length.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var toIntegerOrInfinity = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/to-integer-or-infinity.js [app-client] (ecmascript)");
var min = Math.min;
// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function(argument) {
    var len = toIntegerOrInfinity(argument);
    return len > 0 ? min(len, 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};
}),
"[project]/node_modules/core-js-pure/internals/length-of-array-like.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var toLength = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/to-length.js [app-client] (ecmascript)");
// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function(obj) {
    return toLength(obj.length);
};
}),
"[project]/node_modules/core-js-pure/internals/array-includes.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var toIndexedObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/to-indexed-object.js [app-client] (ecmascript)");
var toAbsoluteIndex = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/to-absolute-index.js [app-client] (ecmascript)");
var lengthOfArrayLike = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/length-of-array-like.js [app-client] (ecmascript)");
// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
        var O = toIndexedObject($this);
        var length = lengthOfArrayLike(O);
        if (length === 0) return !IS_INCLUDES && -1;
        var index = toAbsoluteIndex(fromIndex, length);
        var value;
        // Array#includes uses SameValueZero equality algorithm
        // eslint-disable-next-line no-self-compare -- NaN check
        if (IS_INCLUDES && el !== el) while(length > index){
            value = O[index++];
            // eslint-disable-next-line no-self-compare -- NaN check
            if (value !== value) return true;
        // Array#indexOf ignores holes, Array#includes - not
        }
        else for(; length > index; index++){
            if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
        }
        return !IS_INCLUDES && -1;
    };
};
module.exports = {
    // `Array.prototype.includes` method
    // https://tc39.es/ecma262/#sec-array.prototype.includes
    includes: createMethod(true),
    // `Array.prototype.indexOf` method
    // https://tc39.es/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod(false)
};
}),
"[project]/node_modules/core-js-pure/internals/hidden-keys.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = {};
}),
"[project]/node_modules/core-js-pure/internals/object-keys-internal.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var uncurryThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-uncurry-this.js [app-client] (ecmascript)");
var hasOwn = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/has-own-property.js [app-client] (ecmascript)");
var toIndexedObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/to-indexed-object.js [app-client] (ecmascript)");
var indexOf = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/array-includes.js [app-client] (ecmascript)").indexOf;
var hiddenKeys = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/hidden-keys.js [app-client] (ecmascript)");
var push = uncurryThis([].push);
module.exports = function(object, names) {
    var O = toIndexedObject(object);
    var i = 0;
    var result = [];
    var key;
    for(key in O)!hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
    // Don't enum bug & hidden keys
    while(names.length > i)if (hasOwn(O, key = names[i++])) {
        ~indexOf(result, key) || push(result, key);
    }
    return result;
};
}),
"[project]/node_modules/core-js-pure/internals/enum-bug-keys.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// IE8- don't enum bug keys
module.exports = [
    'constructor',
    'hasOwnProperty',
    'isPrototypeOf',
    'propertyIsEnumerable',
    'toLocaleString',
    'toString',
    'valueOf'
];
}),
"[project]/node_modules/core-js-pure/internals/object-keys.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var internalObjectKeys = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-keys-internal.js [app-client] (ecmascript)");
var enumBugKeys = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/enum-bug-keys.js [app-client] (ecmascript)");
// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
    return internalObjectKeys(O, enumBugKeys);
};
}),
"[project]/node_modules/core-js-pure/internals/object-get-own-property-symbols.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;
}),
"[project]/node_modules/core-js-pure/internals/object-assign.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var DESCRIPTORS = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/descriptors.js [app-client] (ecmascript)");
var uncurryThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-uncurry-this.js [app-client] (ecmascript)");
var call = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-call.js [app-client] (ecmascript)");
var fails = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/fails.js [app-client] (ecmascript)");
var objectKeys = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-keys.js [app-client] (ecmascript)");
var getOwnPropertySymbolsModule = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-get-own-property-symbols.js [app-client] (ecmascript)");
var propertyIsEnumerableModule = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-property-is-enumerable.js [app-client] (ecmascript)");
var toObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/to-object.js [app-client] (ecmascript)");
var IndexedObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/indexed-object.js [app-client] (ecmascript)");
// eslint-disable-next-line es/no-object-assign -- safe
var $assign = Object.assign;
// eslint-disable-next-line es/no-object-defineproperty -- required for testing
var defineProperty = Object.defineProperty;
var concat = uncurryThis([].concat);
// `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
module.exports = !$assign || fails(function() {
    // should have correct order of operations (Edge bug)
    if (DESCRIPTORS && $assign({
        b: 1
    }, $assign(defineProperty({}, 'a', {
        enumerable: true,
        get: function() {
            defineProperty(this, 'b', {
                value: 3,
                enumerable: false
            });
        }
    }), {
        b: 2
    })).b !== 1) return true;
    // should work with symbols and should have deterministic property order (V8 bug)
    var A = {};
    var B = {};
    // eslint-disable-next-line es/no-symbol -- safe
    var symbol = Symbol('assign detection');
    var alphabet = 'abcdefghijklmnopqrst';
    A[symbol] = 7;
    // eslint-disable-next-line es/no-array-prototype-foreach -- safe
    alphabet.split('').forEach(function(chr) {
        B[chr] = chr;
    });
    return $assign({}, A)[symbol] !== 7 || objectKeys($assign({}, B)).join('') !== alphabet;
}) ? function assign(target, source) {
    var T = toObject(target);
    var argumentsLength = arguments.length;
    var index = 1;
    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    var propertyIsEnumerable = propertyIsEnumerableModule.f;
    while(argumentsLength > index){
        var S = IndexedObject(arguments[index++]);
        var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);
        var length = keys.length;
        var j = 0;
        var key;
        while(length > j){
            key = keys[j++];
            if (!DESCRIPTORS || call(propertyIsEnumerable, S, key)) T[key] = S[key];
        }
    }
    return T;
} : $assign;
}),
"[project]/node_modules/core-js-pure/modules/es.object.assign.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $ = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/export.js [app-client] (ecmascript)");
var assign = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-assign.js [app-client] (ecmascript)");
// `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
// eslint-disable-next-line es/no-object-assign -- required for testing
$({
    target: 'Object',
    stat: true,
    arity: 2,
    forced: Object.assign !== assign
}, {
    assign: assign
});
}),
"[project]/node_modules/core-js-pure/es/object/assign.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

__turbopack_context__.r("[project]/node_modules/core-js-pure/modules/es.object.assign.js [app-client] (ecmascript)");
var path = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/path.js [app-client] (ecmascript)");
module.exports = path.Object.assign;
}),
"[project]/node_modules/core-js-pure/stable/object/assign.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var parent = __turbopack_context__.r("[project]/node_modules/core-js-pure/es/object/assign.js [app-client] (ecmascript)");
module.exports = parent;
}),
"[project]/node_modules/core-js-pure/actual/object/assign.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var parent = __turbopack_context__.r("[project]/node_modules/core-js-pure/stable/object/assign.js [app-client] (ecmascript)");
module.exports = parent;
}),
"[project]/node_modules/core-js-pure/full/object/assign.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var parent = __turbopack_context__.r("[project]/node_modules/core-js-pure/actual/object/assign.js [app-client] (ecmascript)");
module.exports = parent;
}),
"[project]/node_modules/core-js-pure/features/object/assign.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/core-js-pure/full/object/assign.js [app-client] (ecmascript)");
}),
"[project]/node_modules/core-js-pure/internals/array-slice.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var uncurryThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-uncurry-this.js [app-client] (ecmascript)");
module.exports = uncurryThis([].slice);
}),
"[project]/node_modules/core-js-pure/internals/function-bind.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var uncurryThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-uncurry-this.js [app-client] (ecmascript)");
var aCallable = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/a-callable.js [app-client] (ecmascript)");
var isObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-object.js [app-client] (ecmascript)");
var hasOwn = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/has-own-property.js [app-client] (ecmascript)");
var arraySlice = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/array-slice.js [app-client] (ecmascript)");
var NATIVE_BIND = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-bind-native.js [app-client] (ecmascript)");
var $Function = Function;
var concat = uncurryThis([].concat);
var join = uncurryThis([].join);
var factories = {};
var construct = function(C, argsLength, args) {
    if (!hasOwn(factories, argsLength)) {
        var list = [];
        var i = 0;
        for(; i < argsLength; i++)list[i] = 'a[' + i + ']';
        factories[argsLength] = $Function('C,a', 'return new C(' + join(list, ',') + ')');
    }
    return factories[argsLength](C, args);
};
// `Function.prototype.bind` method implementation
// https://tc39.es/ecma262/#sec-function.prototype.bind
// eslint-disable-next-line es/no-function-prototype-bind -- detection
module.exports = NATIVE_BIND ? $Function.bind : function bind(that /* , ...args */ ) {
    var F = aCallable(this);
    var Prototype = F.prototype;
    var partArgs = arraySlice(arguments, 1);
    var boundFunction = function bound() {
        var args = concat(partArgs, arraySlice(arguments));
        return this instanceof boundFunction ? construct(F, args.length, args) : F.apply(that, args);
    };
    if (isObject(Prototype)) boundFunction.prototype = Prototype;
    return boundFunction;
};
}),
"[project]/node_modules/core-js-pure/modules/es.function.bind.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// TODO: Remove from `core-js@4`
var $ = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/export.js [app-client] (ecmascript)");
var bind = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-bind.js [app-client] (ecmascript)");
// `Function.prototype.bind` method
// https://tc39.es/ecma262/#sec-function.prototype.bind
// eslint-disable-next-line es/no-function-prototype-bind -- detection
$({
    target: 'Function',
    proto: true,
    forced: Function.bind !== bind
}, {
    bind: bind
});
}),
"[project]/node_modules/core-js-pure/internals/get-built-in-prototype-method.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var globalThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/global-this.js [app-client] (ecmascript)");
var path = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/path.js [app-client] (ecmascript)");
module.exports = function(CONSTRUCTOR, METHOD) {
    var Namespace = path[CONSTRUCTOR + 'Prototype'];
    var pureMethod = Namespace && Namespace[METHOD];
    if (pureMethod) return pureMethod;
    var NativeConstructor = globalThis[CONSTRUCTOR];
    var NativePrototype = NativeConstructor && NativeConstructor.prototype;
    return NativePrototype && NativePrototype[METHOD];
};
}),
"[project]/node_modules/core-js-pure/es/function/virtual/bind.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

__turbopack_context__.r("[project]/node_modules/core-js-pure/modules/es.function.bind.js [app-client] (ecmascript)");
var getBuiltInPrototypeMethod = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/get-built-in-prototype-method.js [app-client] (ecmascript)");
module.exports = getBuiltInPrototypeMethod('Function', 'bind');
}),
"[project]/node_modules/core-js-pure/es/instance/bind.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var isPrototypeOf = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-is-prototype-of.js [app-client] (ecmascript)");
var method = __turbopack_context__.r("[project]/node_modules/core-js-pure/es/function/virtual/bind.js [app-client] (ecmascript)");
var FunctionPrototype = Function.prototype;
module.exports = function(it) {
    var own = it.bind;
    return it === FunctionPrototype || isPrototypeOf(FunctionPrototype, it) && own === FunctionPrototype.bind ? method : own;
};
}),
"[project]/node_modules/core-js-pure/stable/instance/bind.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var parent = __turbopack_context__.r("[project]/node_modules/core-js-pure/es/instance/bind.js [app-client] (ecmascript)");
module.exports = parent;
}),
"[project]/node_modules/core-js-pure/actual/instance/bind.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var parent = __turbopack_context__.r("[project]/node_modules/core-js-pure/stable/instance/bind.js [app-client] (ecmascript)");
module.exports = parent;
}),
"[project]/node_modules/core-js-pure/full/instance/bind.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var parent = __turbopack_context__.r("[project]/node_modules/core-js-pure/actual/instance/bind.js [app-client] (ecmascript)");
module.exports = parent;
}),
"[project]/node_modules/core-js-pure/features/instance/bind.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/core-js-pure/full/instance/bind.js [app-client] (ecmascript)");
}),
"[project]/node_modules/core-js-pure/internals/shared-key.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var shared = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/shared.js [app-client] (ecmascript)");
var uid = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/uid.js [app-client] (ecmascript)");
var keys = shared('keys');
module.exports = function(key) {
    return keys[key] || (keys[key] = uid(key));
};
}),
"[project]/node_modules/core-js-pure/internals/correct-prototype-getter.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var fails = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/fails.js [app-client] (ecmascript)");
module.exports = !fails(function() {
    function F() {}
    F.prototype.constructor = null;
    // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
    return Object.getPrototypeOf(new F()) !== F.prototype;
});
}),
"[project]/node_modules/core-js-pure/internals/object-get-prototype-of.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var hasOwn = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/has-own-property.js [app-client] (ecmascript)");
var isCallable = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-callable.js [app-client] (ecmascript)");
var toObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/to-object.js [app-client] (ecmascript)");
var sharedKey = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/shared-key.js [app-client] (ecmascript)");
var CORRECT_PROTOTYPE_GETTER = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/correct-prototype-getter.js [app-client] (ecmascript)");
var IE_PROTO = sharedKey('IE_PROTO');
var $Object = Object;
var ObjectPrototype = $Object.prototype;
// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es/no-object-getprototypeof -- safe
module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {
    var object = toObject(O);
    if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
    var constructor = object.constructor;
    if (isCallable(constructor) && object instanceof constructor) {
        return constructor.prototype;
    }
    return object instanceof $Object ? ObjectPrototype : null;
};
}),
"[project]/node_modules/core-js-pure/internals/function-uncurry-this-accessor.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var uncurryThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-uncurry-this.js [app-client] (ecmascript)");
var aCallable = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/a-callable.js [app-client] (ecmascript)");
module.exports = function(object, key, method) {
    try {
        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
        return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
    } catch (error) {}
};
}),
"[project]/node_modules/core-js-pure/internals/is-possible-prototype.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var isObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-object.js [app-client] (ecmascript)");
module.exports = function(argument) {
    return isObject(argument) || argument === null;
};
}),
"[project]/node_modules/core-js-pure/internals/a-possible-prototype.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var isPossiblePrototype = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-possible-prototype.js [app-client] (ecmascript)");
var $String = String;
var $TypeError = TypeError;
module.exports = function(argument) {
    if (isPossiblePrototype(argument)) return argument;
    throw new $TypeError("Can't set " + $String(argument) + ' as a prototype');
};
}),
"[project]/node_modules/core-js-pure/internals/object-set-prototype-of.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint-disable no-proto -- safe */ var uncurryThisAccessor = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-uncurry-this-accessor.js [app-client] (ecmascript)");
var isObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-object.js [app-client] (ecmascript)");
var requireObjectCoercible = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/require-object-coercible.js [app-client] (ecmascript)");
var aPossiblePrototype = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/a-possible-prototype.js [app-client] (ecmascript)");
// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function() {
    var CORRECT_SETTER = false;
    var test = {};
    var setter;
    try {
        setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');
        setter(test, []);
        CORRECT_SETTER = test instanceof Array;
    } catch (error) {}
    return function setPrototypeOf(O, proto) {
        requireObjectCoercible(O);
        aPossiblePrototype(proto);
        if (!isObject(O)) return O;
        if (CORRECT_SETTER) setter(O, proto);
        else O.__proto__ = proto;
        return O;
    };
}() : undefined);
}),
"[project]/node_modules/core-js-pure/internals/object-get-own-property-names.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var internalObjectKeys = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-keys-internal.js [app-client] (ecmascript)");
var enumBugKeys = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/enum-bug-keys.js [app-client] (ecmascript)");
var hiddenKeys = enumBugKeys.concat('length', 'prototype');
// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return internalObjectKeys(O, hiddenKeys);
};
}),
"[project]/node_modules/core-js-pure/internals/own-keys.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var getBuiltIn = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/get-built-in.js [app-client] (ecmascript)");
var uncurryThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-uncurry-this.js [app-client] (ecmascript)");
var getOwnPropertyNamesModule = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-get-own-property-names.js [app-client] (ecmascript)");
var getOwnPropertySymbolsModule = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-get-own-property-symbols.js [app-client] (ecmascript)");
var anObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/an-object.js [app-client] (ecmascript)");
var concat = uncurryThis([].concat);
// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
    var keys = getOwnPropertyNamesModule.f(anObject(it));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};
}),
"[project]/node_modules/core-js-pure/internals/copy-constructor-properties.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var hasOwn = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/has-own-property.js [app-client] (ecmascript)");
var ownKeys = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/own-keys.js [app-client] (ecmascript)");
var getOwnPropertyDescriptorModule = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-get-own-property-descriptor.js [app-client] (ecmascript)");
var definePropertyModule = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-define-property.js [app-client] (ecmascript)");
module.exports = function(target, source, exceptions) {
    var keys = ownKeys(source);
    var defineProperty = definePropertyModule.f;
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    for(var i = 0; i < keys.length; i++){
        var key = keys[i];
        if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
            defineProperty(target, key, getOwnPropertyDescriptor(source, key));
        }
    }
};
}),
"[project]/node_modules/core-js-pure/internals/object-define-properties.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var DESCRIPTORS = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/descriptors.js [app-client] (ecmascript)");
var V8_PROTOTYPE_DEFINE_BUG = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/v8-prototype-define-bug.js [app-client] (ecmascript)");
var definePropertyModule = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-define-property.js [app-client] (ecmascript)");
var anObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/an-object.js [app-client] (ecmascript)");
var toIndexedObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/to-indexed-object.js [app-client] (ecmascript)");
var objectKeys = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-keys.js [app-client] (ecmascript)");
// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject(O);
    var props = toIndexedObject(Properties);
    var keys = objectKeys(Properties);
    var length = keys.length;
    var index = 0;
    var key;
    while(length > index)definePropertyModule.f(O, key = keys[index++], props[key]);
    return O;
};
}),
"[project]/node_modules/core-js-pure/internals/html.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var getBuiltIn = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/get-built-in.js [app-client] (ecmascript)");
module.exports = getBuiltIn('document', 'documentElement');
}),
"[project]/node_modules/core-js-pure/internals/object-create.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* global ActiveXObject -- old IE, WSH */ var anObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/an-object.js [app-client] (ecmascript)");
var definePropertiesModule = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-define-properties.js [app-client] (ecmascript)");
var enumBugKeys = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/enum-bug-keys.js [app-client] (ecmascript)");
var hiddenKeys = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/hidden-keys.js [app-client] (ecmascript)");
var html = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/html.js [app-client] (ecmascript)");
var documentCreateElement = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/document-create-element.js [app-client] (ecmascript)");
var sharedKey = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/shared-key.js [app-client] (ecmascript)");
var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');
var EmptyConstructor = function() {};
var scriptTag = function(content) {
    return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};
// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function(activeXDocument) {
    activeXDocument.write(scriptTag(''));
    activeXDocument.close();
    var temp = activeXDocument.parentWindow.Object;
    // eslint-disable-next-line no-useless-assignment -- avoid memory leak
    activeXDocument = null;
    return temp;
};
// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function() {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = documentCreateElement('iframe');
    var JS = 'java' + SCRIPT + ':';
    var iframeDocument;
    iframe.style.display = 'none';
    html.appendChild(iframe);
    // https://github.com/zloirock/core-js/issues/475
    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag('document.F=Object'));
    iframeDocument.close();
    return iframeDocument.F;
};
// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function() {
    try {
        activeXDocument = new ActiveXObject('htmlfile');
    } catch (error) {}
    NullProtoObject = typeof document != 'undefined' ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) // old IE
     : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument); // WSH
    var length = enumBugKeys.length;
    while(length--)delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
    return NullProtoObject();
};
hiddenKeys[IE_PROTO] = true;
// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
// eslint-disable-next-line es/no-object-create -- safe
module.exports = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
        EmptyConstructor[PROTOTYPE] = anObject(O);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null;
        // add "__proto__" for Object.getPrototypeOf polyfill
        result[IE_PROTO] = O;
    } else result = NullProtoObject();
    return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};
}),
"[project]/node_modules/core-js-pure/internals/install-error-cause.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var isObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-object.js [app-client] (ecmascript)");
var createNonEnumerableProperty = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/create-non-enumerable-property.js [app-client] (ecmascript)");
// `InstallErrorCause` abstract operation
// https://tc39.es/ecma262/#sec-installerrorcause
module.exports = function(O, options) {
    if (isObject(options) && 'cause' in options) {
        createNonEnumerableProperty(O, 'cause', options.cause);
    }
};
}),
"[project]/node_modules/core-js-pure/internals/error-stack-clear.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var uncurryThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-uncurry-this.js [app-client] (ecmascript)");
var $Error = Error;
var replace = uncurryThis(''.replace);
var TEST = function(arg) {
    return String(new $Error(arg).stack);
}('zxcasd');
// eslint-disable-next-line redos/no-vulnerable, sonarjs/slow-regex -- safe
var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
module.exports = function(stack, dropEntries) {
    if (IS_V8_OR_CHAKRA_STACK && typeof stack == 'string' && !$Error.prepareStackTrace) {
        while(dropEntries--)stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, '');
    }
    return stack;
};
}),
"[project]/node_modules/core-js-pure/internals/error-stack-installable.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var fails = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/fails.js [app-client] (ecmascript)");
var createPropertyDescriptor = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/create-property-descriptor.js [app-client] (ecmascript)");
module.exports = !fails(function() {
    var error = new Error('a');
    if (!('stack' in error)) return true;
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty(error, 'stack', createPropertyDescriptor(1, 7));
    return error.stack !== 7;
});
}),
"[project]/node_modules/core-js-pure/internals/error-stack-install.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var createNonEnumerableProperty = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/create-non-enumerable-property.js [app-client] (ecmascript)");
var clearErrorStack = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/error-stack-clear.js [app-client] (ecmascript)");
var ERROR_STACK_INSTALLABLE = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/error-stack-installable.js [app-client] (ecmascript)");
// non-standard V8
// eslint-disable-next-line es/no-nonstandard-error-properties -- safe
var captureStackTrace = Error.captureStackTrace;
module.exports = function(error, C, stack, dropEntries) {
    if (ERROR_STACK_INSTALLABLE) {
        if (captureStackTrace) captureStackTrace(error, C);
        else createNonEnumerableProperty(error, 'stack', clearErrorStack(stack, dropEntries));
    }
};
}),
"[project]/node_modules/core-js-pure/internals/iterators.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = {};
}),
"[project]/node_modules/core-js-pure/internals/is-array-iterator-method.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var wellKnownSymbol = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/well-known-symbol.js [app-client] (ecmascript)");
var Iterators = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/iterators.js [app-client] (ecmascript)");
var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;
// check on default Array iterator
module.exports = function(it) {
    return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};
}),
"[project]/node_modules/core-js-pure/internals/to-string-tag-support.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var wellKnownSymbol = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/well-known-symbol.js [app-client] (ecmascript)");
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};
test[TO_STRING_TAG] = 'z';
module.exports = String(test) === '[object z]';
}),
"[project]/node_modules/core-js-pure/internals/classof.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var TO_STRING_TAG_SUPPORT = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/to-string-tag-support.js [app-client] (ecmascript)");
var isCallable = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-callable.js [app-client] (ecmascript)");
var classofRaw = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/classof-raw.js [app-client] (ecmascript)");
var wellKnownSymbol = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/well-known-symbol.js [app-client] (ecmascript)");
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function() {
    return arguments;
}()) === 'Arguments';
// fallback for IE11 Script Access Denied error
var tryGet = function(it, key) {
    try {
        return it[key];
    } catch (error) {}
};
// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
    var O, tag, result;
    return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) === 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};
}),
"[project]/node_modules/core-js-pure/internals/get-iterator-method.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var classof = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/classof.js [app-client] (ecmascript)");
var getMethod = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/get-method.js [app-client] (ecmascript)");
var isNullOrUndefined = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-null-or-undefined.js [app-client] (ecmascript)");
var Iterators = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/iterators.js [app-client] (ecmascript)");
var wellKnownSymbol = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/well-known-symbol.js [app-client] (ecmascript)");
var ITERATOR = wellKnownSymbol('iterator');
module.exports = function(it) {
    if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR) || getMethod(it, '@@iterator') || Iterators[classof(it)];
};
}),
"[project]/node_modules/core-js-pure/internals/get-iterator.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var call = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-call.js [app-client] (ecmascript)");
var aCallable = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/a-callable.js [app-client] (ecmascript)");
var anObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/an-object.js [app-client] (ecmascript)");
var tryToString = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/try-to-string.js [app-client] (ecmascript)");
var getIteratorMethod = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/get-iterator-method.js [app-client] (ecmascript)");
var $TypeError = TypeError;
module.exports = function(argument, usingIterator) {
    var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
    if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
    throw new $TypeError(tryToString(argument) + ' is not iterable');
};
}),
"[project]/node_modules/core-js-pure/internals/iterator-close.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var call = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-call.js [app-client] (ecmascript)");
var anObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/an-object.js [app-client] (ecmascript)");
var getMethod = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/get-method.js [app-client] (ecmascript)");
module.exports = function(iterator, kind, value) {
    var innerResult, innerError;
    anObject(iterator);
    try {
        innerResult = getMethod(iterator, 'return');
        if (!innerResult) {
            if (kind === 'throw') throw value;
            return value;
        }
        innerResult = call(innerResult, iterator);
    } catch (error) {
        innerError = true;
        innerResult = error;
    }
    if (kind === 'throw') throw value;
    if (innerError) throw innerResult;
    anObject(innerResult);
    return value;
};
}),
"[project]/node_modules/core-js-pure/internals/iterate.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var bind = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-bind-context.js [app-client] (ecmascript)");
var call = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-call.js [app-client] (ecmascript)");
var anObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/an-object.js [app-client] (ecmascript)");
var tryToString = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/try-to-string.js [app-client] (ecmascript)");
var isArrayIteratorMethod = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-array-iterator-method.js [app-client] (ecmascript)");
var lengthOfArrayLike = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/length-of-array-like.js [app-client] (ecmascript)");
var isPrototypeOf = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-is-prototype-of.js [app-client] (ecmascript)");
var getIterator = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/get-iterator.js [app-client] (ecmascript)");
var getIteratorMethod = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/get-iterator-method.js [app-client] (ecmascript)");
var iteratorClose = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/iterator-close.js [app-client] (ecmascript)");
var $TypeError = TypeError;
var Result = function(stopped, result) {
    this.stopped = stopped;
    this.result = result;
};
var ResultPrototype = Result.prototype;
module.exports = function(iterable, unboundFunction, options) {
    var that = options && options.that;
    var AS_ENTRIES = !!(options && options.AS_ENTRIES);
    var IS_RECORD = !!(options && options.IS_RECORD);
    var IS_ITERATOR = !!(options && options.IS_ITERATOR);
    var INTERRUPTED = !!(options && options.INTERRUPTED);
    var fn = bind(unboundFunction, that);
    var iterator, iterFn, index, length, result, next, step;
    var stop = function(condition) {
        if (iterator) iteratorClose(iterator, 'normal');
        return new Result(true, condition);
    };
    var callFn = function(value) {
        if (AS_ENTRIES) {
            anObject(value);
            return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
        }
        return INTERRUPTED ? fn(value, stop) : fn(value);
    };
    if (IS_RECORD) {
        iterator = iterable.iterator;
    } else if (IS_ITERATOR) {
        iterator = iterable;
    } else {
        iterFn = getIteratorMethod(iterable);
        if (!iterFn) throw new $TypeError(tryToString(iterable) + ' is not iterable');
        // optimisation for array iterators
        if (isArrayIteratorMethod(iterFn)) {
            for(index = 0, length = lengthOfArrayLike(iterable); length > index; index++){
                result = callFn(iterable[index]);
                if (result && isPrototypeOf(ResultPrototype, result)) return result;
            }
            return new Result(false);
        }
        iterator = getIterator(iterable, iterFn);
    }
    next = IS_RECORD ? iterable.next : iterator.next;
    while(!(step = call(next, iterator)).done){
        try {
            result = callFn(step.value);
        } catch (error) {
            iteratorClose(iterator, 'throw', error);
        }
        if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result)) return result;
    }
    return new Result(false);
};
}),
"[project]/node_modules/core-js-pure/internals/to-string.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var classof = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/classof.js [app-client] (ecmascript)");
var $String = String;
module.exports = function(argument) {
    if (classof(argument) === 'Symbol') throw new TypeError('Cannot convert a Symbol value to a string');
    return $String(argument);
};
}),
"[project]/node_modules/core-js-pure/internals/normalize-string-argument.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var toString = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/to-string.js [app-client] (ecmascript)");
module.exports = function(argument, $default) {
    return argument === undefined ? arguments.length < 2 ? '' : $default : toString(argument);
};
}),
"[project]/node_modules/core-js-pure/modules/es.aggregate-error.constructor.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $ = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/export.js [app-client] (ecmascript)");
var isPrototypeOf = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-is-prototype-of.js [app-client] (ecmascript)");
var getPrototypeOf = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-get-prototype-of.js [app-client] (ecmascript)");
var setPrototypeOf = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-set-prototype-of.js [app-client] (ecmascript)");
var copyConstructorProperties = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/copy-constructor-properties.js [app-client] (ecmascript)");
var create = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-create.js [app-client] (ecmascript)");
var createNonEnumerableProperty = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/create-non-enumerable-property.js [app-client] (ecmascript)");
var createPropertyDescriptor = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/create-property-descriptor.js [app-client] (ecmascript)");
var installErrorCause = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/install-error-cause.js [app-client] (ecmascript)");
var installErrorStack = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/error-stack-install.js [app-client] (ecmascript)");
var iterate = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/iterate.js [app-client] (ecmascript)");
var normalizeStringArgument = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/normalize-string-argument.js [app-client] (ecmascript)");
var wellKnownSymbol = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/well-known-symbol.js [app-client] (ecmascript)");
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Error = Error;
var push = [].push;
var $AggregateError = function AggregateError(errors, message /* , options */ ) {
    var isInstance = isPrototypeOf(AggregateErrorPrototype, this);
    var that;
    if (setPrototypeOf) {
        that = setPrototypeOf(new $Error(), isInstance ? getPrototypeOf(this) : AggregateErrorPrototype);
    } else {
        that = isInstance ? this : create(AggregateErrorPrototype);
        createNonEnumerableProperty(that, TO_STRING_TAG, 'Error');
    }
    if (message !== undefined) createNonEnumerableProperty(that, 'message', normalizeStringArgument(message));
    installErrorStack(that, $AggregateError, that.stack, 1);
    if (arguments.length > 2) installErrorCause(that, arguments[2]);
    var errorsArray = [];
    iterate(errors, push, {
        that: errorsArray
    });
    createNonEnumerableProperty(that, 'errors', errorsArray);
    return that;
};
if (setPrototypeOf) setPrototypeOf($AggregateError, $Error);
else copyConstructorProperties($AggregateError, $Error, {
    name: true
});
var AggregateErrorPrototype = $AggregateError.prototype = create($Error.prototype, {
    constructor: createPropertyDescriptor(1, $AggregateError),
    message: createPropertyDescriptor(1, ''),
    name: createPropertyDescriptor(1, 'AggregateError')
});
// `AggregateError` constructor
// https://tc39.es/ecma262/#sec-aggregate-error-constructor
$({
    global: true,
    constructor: true,
    arity: 2
}, {
    AggregateError: $AggregateError
});
}),
"[project]/node_modules/core-js-pure/modules/es.aggregate-error.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// TODO: Remove this module from `core-js@4` since it's replaced to module below
__turbopack_context__.r("[project]/node_modules/core-js-pure/modules/es.aggregate-error.constructor.js [app-client] (ecmascript)");
}),
"[project]/node_modules/core-js-pure/modules/esnext.aggregate-error.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// TODO: Remove from `core-js@4`
__turbopack_context__.r("[project]/node_modules/core-js-pure/modules/es.aggregate-error.js [app-client] (ecmascript)");
}),
"[project]/node_modules/core-js-pure/internals/proxy-accessor.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var defineProperty = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-define-property.js [app-client] (ecmascript)").f;
module.exports = function(Target, Source, key) {
    key in Target || defineProperty(Target, key, {
        configurable: true,
        get: function() {
            return Source[key];
        },
        set: function(it) {
            Source[key] = it;
        }
    });
};
}),
"[project]/node_modules/core-js-pure/internals/inherit-if-required.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var isCallable = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-callable.js [app-client] (ecmascript)");
var isObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-object.js [app-client] (ecmascript)");
var setPrototypeOf = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-set-prototype-of.js [app-client] (ecmascript)");
// makes subclassing work correct for wrapped built-ins
module.exports = function($this, dummy, Wrapper) {
    var NewTarget, NewTargetPrototype;
    if (// it can work only with native `setPrototypeOf`
    setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) setPrototypeOf($this, NewTargetPrototype);
    return $this;
};
}),
"[project]/node_modules/core-js-pure/internals/wrap-error-constructor-with-cause.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var getBuiltIn = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/get-built-in.js [app-client] (ecmascript)");
var hasOwn = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/has-own-property.js [app-client] (ecmascript)");
var createNonEnumerableProperty = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/create-non-enumerable-property.js [app-client] (ecmascript)");
var isPrototypeOf = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-is-prototype-of.js [app-client] (ecmascript)");
var setPrototypeOf = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-set-prototype-of.js [app-client] (ecmascript)");
var copyConstructorProperties = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/copy-constructor-properties.js [app-client] (ecmascript)");
var proxyAccessor = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/proxy-accessor.js [app-client] (ecmascript)");
var inheritIfRequired = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/inherit-if-required.js [app-client] (ecmascript)");
var normalizeStringArgument = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/normalize-string-argument.js [app-client] (ecmascript)");
var installErrorCause = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/install-error-cause.js [app-client] (ecmascript)");
var installErrorStack = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/error-stack-install.js [app-client] (ecmascript)");
var DESCRIPTORS = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/descriptors.js [app-client] (ecmascript)");
var IS_PURE = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-pure.js [app-client] (ecmascript)");
module.exports = function(FULL_NAME, wrapper, FORCED, IS_AGGREGATE_ERROR) {
    var STACK_TRACE_LIMIT = 'stackTraceLimit';
    var OPTIONS_POSITION = IS_AGGREGATE_ERROR ? 2 : 1;
    var path = FULL_NAME.split('.');
    var ERROR_NAME = path[path.length - 1];
    var OriginalError = getBuiltIn.apply(null, path);
    if (!OriginalError) return;
    var OriginalErrorPrototype = OriginalError.prototype;
    // V8 9.3- bug https://bugs.chromium.org/p/v8/issues/detail?id=12006
    if (!IS_PURE && hasOwn(OriginalErrorPrototype, 'cause')) delete OriginalErrorPrototype.cause;
    if (!FORCED) return OriginalError;
    var BaseError = getBuiltIn('Error');
    var WrappedError = wrapper(function(a, b) {
        var message = normalizeStringArgument(IS_AGGREGATE_ERROR ? b : a, undefined);
        var result = IS_AGGREGATE_ERROR ? new OriginalError(a) : new OriginalError();
        if (message !== undefined) createNonEnumerableProperty(result, 'message', message);
        installErrorStack(result, WrappedError, result.stack, 2);
        if (this && isPrototypeOf(OriginalErrorPrototype, this)) inheritIfRequired(result, this, WrappedError);
        if (arguments.length > OPTIONS_POSITION) installErrorCause(result, arguments[OPTIONS_POSITION]);
        return result;
    });
    WrappedError.prototype = OriginalErrorPrototype;
    if (ERROR_NAME !== 'Error') {
        if (setPrototypeOf) setPrototypeOf(WrappedError, BaseError);
        else copyConstructorProperties(WrappedError, BaseError, {
            name: true
        });
    } else if (DESCRIPTORS && STACK_TRACE_LIMIT in OriginalError) {
        proxyAccessor(WrappedError, OriginalError, STACK_TRACE_LIMIT);
        proxyAccessor(WrappedError, OriginalError, 'prepareStackTrace');
    }
    copyConstructorProperties(WrappedError, OriginalError);
    if (!IS_PURE) try {
        // Safari 13- bug: WebAssembly errors does not have a proper `.name`
        if (OriginalErrorPrototype.name !== ERROR_NAME) {
            createNonEnumerableProperty(OriginalErrorPrototype, 'name', ERROR_NAME);
        }
        OriginalErrorPrototype.constructor = WrappedError;
    } catch (error) {}
    return WrappedError;
};
}),
"[project]/node_modules/core-js-pure/modules/es.error.cause.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint-disable no-unused-vars -- required for functions `.length` */ var $ = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/export.js [app-client] (ecmascript)");
var globalThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/global-this.js [app-client] (ecmascript)");
var apply = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-apply.js [app-client] (ecmascript)");
var wrapErrorConstructorWithCause = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/wrap-error-constructor-with-cause.js [app-client] (ecmascript)");
var WEB_ASSEMBLY = 'WebAssembly';
var WebAssembly = globalThis[WEB_ASSEMBLY];
// eslint-disable-next-line es/no-error-cause -- feature detection
var FORCED = new Error('e', {
    cause: 7
}).cause !== 7;
var exportGlobalErrorCauseWrapper = function(ERROR_NAME, wrapper) {
    var O = {};
    O[ERROR_NAME] = wrapErrorConstructorWithCause(ERROR_NAME, wrapper, FORCED);
    $({
        global: true,
        constructor: true,
        arity: 1,
        forced: FORCED
    }, O);
};
var exportWebAssemblyErrorCauseWrapper = function(ERROR_NAME, wrapper) {
    if (WebAssembly && WebAssembly[ERROR_NAME]) {
        var O = {};
        O[ERROR_NAME] = wrapErrorConstructorWithCause(WEB_ASSEMBLY + '.' + ERROR_NAME, wrapper, FORCED);
        $({
            target: WEB_ASSEMBLY,
            stat: true,
            constructor: true,
            arity: 1,
            forced: FORCED
        }, O);
    }
};
// https://tc39.es/ecma262/#sec-nativeerror
exportGlobalErrorCauseWrapper('Error', function(init) {
    return function Error1(message) {
        return apply(init, this, arguments);
    };
});
exportGlobalErrorCauseWrapper('EvalError', function(init) {
    return function EvalError(message) {
        return apply(init, this, arguments);
    };
});
exportGlobalErrorCauseWrapper('RangeError', function(init) {
    return function RangeError(message) {
        return apply(init, this, arguments);
    };
});
exportGlobalErrorCauseWrapper('ReferenceError', function(init) {
    return function ReferenceError(message) {
        return apply(init, this, arguments);
    };
});
exportGlobalErrorCauseWrapper('SyntaxError', function(init) {
    return function SyntaxError(message) {
        return apply(init, this, arguments);
    };
});
exportGlobalErrorCauseWrapper('TypeError', function(init) {
    return function TypeError(message) {
        return apply(init, this, arguments);
    };
});
exportGlobalErrorCauseWrapper('URIError', function(init) {
    return function URIError(message) {
        return apply(init, this, arguments);
    };
});
exportWebAssemblyErrorCauseWrapper('CompileError', function(init) {
    return function CompileError(message) {
        return apply(init, this, arguments);
    };
});
exportWebAssemblyErrorCauseWrapper('LinkError', function(init) {
    return function LinkError(message) {
        return apply(init, this, arguments);
    };
});
exportWebAssemblyErrorCauseWrapper('RuntimeError', function(init) {
    return function RuntimeError(message) {
        return apply(init, this, arguments);
    };
});
}),
"[project]/node_modules/core-js-pure/modules/es.aggregate-error.cause.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $ = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/export.js [app-client] (ecmascript)");
var getBuiltIn = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/get-built-in.js [app-client] (ecmascript)");
var apply = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-apply.js [app-client] (ecmascript)");
var fails = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/fails.js [app-client] (ecmascript)");
var wrapErrorConstructorWithCause = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/wrap-error-constructor-with-cause.js [app-client] (ecmascript)");
var AGGREGATE_ERROR = 'AggregateError';
var $AggregateError = getBuiltIn(AGGREGATE_ERROR);
var FORCED = !fails(function() {
    return $AggregateError([
        1
    ]).errors[0] !== 1;
}) && fails(function() {
    return $AggregateError([
        1
    ], AGGREGATE_ERROR, {
        cause: 7
    }).cause !== 7;
});
// https://tc39.es/ecma262/#sec-aggregate-error
$({
    global: true,
    constructor: true,
    arity: 2,
    forced: FORCED
}, {
    AggregateError: wrapErrorConstructorWithCause(AGGREGATE_ERROR, function(init) {
        // eslint-disable-next-line no-unused-vars -- required for functions `.length`
        return function AggregateError(errors, message) {
            return apply(init, this, arguments);
        };
    }, FORCED, true)
});
}),
"[project]/node_modules/core-js-pure/internals/add-to-unscopables.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function() {};
}),
"[project]/node_modules/core-js-pure/internals/weak-map-basic-detection.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var globalThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/global-this.js [app-client] (ecmascript)");
var isCallable = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-callable.js [app-client] (ecmascript)");
var WeakMap = globalThis.WeakMap;
module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));
}),
"[project]/node_modules/core-js-pure/internals/internal-state.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var NATIVE_WEAK_MAP = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/weak-map-basic-detection.js [app-client] (ecmascript)");
var globalThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/global-this.js [app-client] (ecmascript)");
var isObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-object.js [app-client] (ecmascript)");
var createNonEnumerableProperty = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/create-non-enumerable-property.js [app-client] (ecmascript)");
var hasOwn = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/has-own-property.js [app-client] (ecmascript)");
var shared = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/shared-store.js [app-client] (ecmascript)");
var sharedKey = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/shared-key.js [app-client] (ecmascript)");
var hiddenKeys = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/hidden-keys.js [app-client] (ecmascript)");
var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = globalThis.TypeError;
var WeakMap = globalThis.WeakMap;
var set, get, has;
var enforce = function(it) {
    return has(it) ? get(it) : set(it, {});
};
var getterFor = function(TYPE) {
    return function(it) {
        var state;
        if (!isObject(it) || (state = get(it)).type !== TYPE) {
            throw new TypeError('Incompatible receiver, ' + TYPE + ' required');
        }
        return state;
    };
};
if (NATIVE_WEAK_MAP || shared.state) {
    var store = shared.state || (shared.state = new WeakMap());
    /* eslint-disable no-self-assign -- prototype methods protection */ store.get = store.get;
    store.has = store.has;
    store.set = store.set;
    /* eslint-enable no-self-assign -- prototype methods protection */ set = function(it, metadata) {
        if (store.has(it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        store.set(it, metadata);
        return metadata;
    };
    get = function(it) {
        return store.get(it) || {};
    };
    has = function(it) {
        return store.has(it);
    };
} else {
    var STATE = sharedKey('state');
    hiddenKeys[STATE] = true;
    set = function(it, metadata) {
        if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        createNonEnumerableProperty(it, STATE, metadata);
        return metadata;
    };
    get = function(it) {
        return hasOwn(it, STATE) ? it[STATE] : {};
    };
    has = function(it) {
        return hasOwn(it, STATE);
    };
}
module.exports = {
    set: set,
    get: get,
    has: has,
    enforce: enforce,
    getterFor: getterFor
};
}),
"[project]/node_modules/core-js-pure/internals/function-name.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var DESCRIPTORS = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/descriptors.js [app-client] (ecmascript)");
var hasOwn = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/has-own-property.js [app-client] (ecmascript)");
var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() {}).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable);
module.exports = {
    EXISTS: EXISTS,
    PROPER: PROPER,
    CONFIGURABLE: CONFIGURABLE
};
}),
"[project]/node_modules/core-js-pure/internals/define-built-in.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var createNonEnumerableProperty = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/create-non-enumerable-property.js [app-client] (ecmascript)");
module.exports = function(target, key, value, options) {
    if (options && options.enumerable) target[key] = value;
    else createNonEnumerableProperty(target, key, value);
    return target;
};
}),
"[project]/node_modules/core-js-pure/internals/iterators-core.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var fails = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/fails.js [app-client] (ecmascript)");
var isCallable = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-callable.js [app-client] (ecmascript)");
var isObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-object.js [app-client] (ecmascript)");
var create = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-create.js [app-client] (ecmascript)");
var getPrototypeOf = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-get-prototype-of.js [app-client] (ecmascript)");
var defineBuiltIn = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/define-built-in.js [app-client] (ecmascript)");
var wellKnownSymbol = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/well-known-symbol.js [app-client] (ecmascript)");
var IS_PURE = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-pure.js [app-client] (ecmascript)");
var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;
// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
/* eslint-disable es/no-array-prototype-keys -- safe */ if ([].keys) {
    arrayIterator = [].keys();
    // Safari 8 has buggy iterators w/o `next`
    if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
    else {
        PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
        if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
    }
}
var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function() {
    var test = {};
    // FF44- legacy iterators case
    return IteratorPrototype[ITERATOR].call(test) !== test;
});
if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);
// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable(IteratorPrototype[ITERATOR])) {
    defineBuiltIn(IteratorPrototype, ITERATOR, function() {
        return this;
    });
}
module.exports = {
    IteratorPrototype: IteratorPrototype,
    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};
}),
"[project]/node_modules/core-js-pure/internals/object-to-string.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var TO_STRING_TAG_SUPPORT = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/to-string-tag-support.js [app-client] (ecmascript)");
var classof = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/classof.js [app-client] (ecmascript)");
// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? ({}).toString : function toString() {
    return '[object ' + classof(this) + ']';
};
}),
"[project]/node_modules/core-js-pure/internals/set-to-string-tag.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var TO_STRING_TAG_SUPPORT = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/to-string-tag-support.js [app-client] (ecmascript)");
var defineProperty = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-define-property.js [app-client] (ecmascript)").f;
var createNonEnumerableProperty = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/create-non-enumerable-property.js [app-client] (ecmascript)");
var hasOwn = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/has-own-property.js [app-client] (ecmascript)");
var toString = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-to-string.js [app-client] (ecmascript)");
var wellKnownSymbol = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/well-known-symbol.js [app-client] (ecmascript)");
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
module.exports = function(it, TAG, STATIC, SET_METHOD) {
    var target = STATIC ? it : it && it.prototype;
    if (target) {
        if (!hasOwn(target, TO_STRING_TAG)) {
            defineProperty(target, TO_STRING_TAG, {
                configurable: true,
                value: TAG
            });
        }
        if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {
            createNonEnumerableProperty(target, 'toString', toString);
        }
    }
};
}),
"[project]/node_modules/core-js-pure/internals/iterator-create-constructor.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var IteratorPrototype = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/iterators-core.js [app-client] (ecmascript)").IteratorPrototype;
var create = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-create.js [app-client] (ecmascript)");
var createPropertyDescriptor = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/create-property-descriptor.js [app-client] (ecmascript)");
var setToStringTag = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/set-to-string-tag.js [app-client] (ecmascript)");
var Iterators = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/iterators.js [app-client] (ecmascript)");
var returnThis = function() {
    return this;
};
module.exports = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
    var TO_STRING_TAG = NAME + ' Iterator';
    IteratorConstructor.prototype = create(IteratorPrototype, {
        next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next)
    });
    setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
    Iterators[TO_STRING_TAG] = returnThis;
    return IteratorConstructor;
};
}),
"[project]/node_modules/core-js-pure/internals/iterator-define.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $ = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/export.js [app-client] (ecmascript)");
var call = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-call.js [app-client] (ecmascript)");
var IS_PURE = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-pure.js [app-client] (ecmascript)");
var FunctionName = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-name.js [app-client] (ecmascript)");
var isCallable = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-callable.js [app-client] (ecmascript)");
var createIteratorConstructor = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/iterator-create-constructor.js [app-client] (ecmascript)");
var getPrototypeOf = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-get-prototype-of.js [app-client] (ecmascript)");
var setPrototypeOf = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-set-prototype-of.js [app-client] (ecmascript)");
var setToStringTag = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/set-to-string-tag.js [app-client] (ecmascript)");
var createNonEnumerableProperty = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/create-non-enumerable-property.js [app-client] (ecmascript)");
var defineBuiltIn = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/define-built-in.js [app-client] (ecmascript)");
var wellKnownSymbol = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/well-known-symbol.js [app-client] (ecmascript)");
var Iterators = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/iterators.js [app-client] (ecmascript)");
var IteratorsCore = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/iterators-core.js [app-client] (ecmascript)");
var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';
var returnThis = function() {
    return this;
};
module.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
    createIteratorConstructor(IteratorConstructor, NAME, next);
    var getIterationMethod = function(KIND) {
        if (KIND === DEFAULT && defaultIterator) return defaultIterator;
        if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype) return IterablePrototype[KIND];
        switch(KIND){
            case KEYS:
                return function keys() {
                    return new IteratorConstructor(this, KIND);
                };
            case VALUES:
                return function values() {
                    return new IteratorConstructor(this, KIND);
                };
            case ENTRIES:
                return function entries() {
                    return new IteratorConstructor(this, KIND);
                };
        }
        return function() {
            return new IteratorConstructor(this);
        };
    };
    var TO_STRING_TAG = NAME + ' Iterator';
    var INCORRECT_VALUES_NAME = false;
    var IterablePrototype = Iterable.prototype;
    var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
    var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
    var anyNativeIterator = NAME === 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
    var CurrentIteratorPrototype, methods, KEY;
    // fix native
    if (anyNativeIterator) {
        CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
        if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
            if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                if (setPrototypeOf) {
                    setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
                    defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
                }
            }
            // Set @@toStringTag to native iterators
            setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
            if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
        }
    }
    // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
    if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
        if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
            createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
        } else {
            INCORRECT_VALUES_NAME = true;
            defaultIterator = function values() {
                return call(nativeIterator, this);
            };
        }
    }
    // export additional methods
    if (DEFAULT) {
        methods = {
            values: getIterationMethod(VALUES),
            keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
            entries: getIterationMethod(ENTRIES)
        };
        if (FORCED) for(KEY in methods){
            if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
            }
        }
        else $({
            target: NAME,
            proto: true,
            forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
        }, methods);
    }
    // define iterator
    if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
        defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, {
            name: DEFAULT
        });
    }
    Iterators[NAME] = defaultIterator;
    return methods;
};
}),
"[project]/node_modules/core-js-pure/internals/create-iter-result-object.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// `CreateIterResultObject` abstract operation
// https://tc39.es/ecma262/#sec-createiterresultobject
module.exports = function(value, done) {
    return {
        value: value,
        done: done
    };
};
}),
"[project]/node_modules/core-js-pure/modules/es.array.iterator.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var toIndexedObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/to-indexed-object.js [app-client] (ecmascript)");
var addToUnscopables = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/add-to-unscopables.js [app-client] (ecmascript)");
var Iterators = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/iterators.js [app-client] (ecmascript)");
var InternalStateModule = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/internal-state.js [app-client] (ecmascript)");
var defineProperty = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/object-define-property.js [app-client] (ecmascript)").f;
var defineIterator = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/iterator-define.js [app-client] (ecmascript)");
var createIterResultObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/create-iter-result-object.js [app-client] (ecmascript)");
var IS_PURE = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/is-pure.js [app-client] (ecmascript)");
var DESCRIPTORS = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/descriptors.js [app-client] (ecmascript)");
var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function(iterated, kind) {
    setInternalState(this, {
        type: ARRAY_ITERATOR,
        target: toIndexedObject(iterated),
        index: 0,
        kind: kind // kind
    });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function() {
    var state = getInternalState(this);
    var target = state.target;
    var index = state.index++;
    if (!target || index >= target.length) {
        state.target = null;
        return createIterResultObject(undefined, true);
    }
    switch(state.kind){
        case 'keys':
            return createIterResultObject(index, false);
        case 'values':
            return createIterResultObject(target[index], false);
    }
    return createIterResultObject([
        index,
        target[index]
    ], false);
}, 'values');
// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
var values = Iterators.Arguments = Iterators.Array;
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');
// V8 ~ Chrome 45- bug
if (!IS_PURE && DESCRIPTORS && values.name !== 'values') try {
    defineProperty(values, 'name', {
        value: 'values'
    });
} catch (error) {}
}),
"[project]/node_modules/core-js-pure/internals/string-multibyte.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var uncurryThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/function-uncurry-this.js [app-client] (ecmascript)");
var toIntegerOrInfinity = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/to-integer-or-infinity.js [app-client] (ecmascript)");
var toString = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/to-string.js [app-client] (ecmascript)");
var requireObjectCoercible = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/require-object-coercible.js [app-client] (ecmascript)");
var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var stringSlice = uncurryThis(''.slice);
var createMethod = function(CONVERT_TO_STRING) {
    return function($this, pos) {
        var S = toString(requireObjectCoercible($this));
        var position = toIntegerOrInfinity(pos);
        var size = S.length;
        var first, second;
        if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
        first = charCodeAt(S, position);
        return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? charAt(S, position) : first : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
    };
};
module.exports = {
    // `String.prototype.codePointAt` method
    // https://tc39.es/ecma262/#sec-string.prototype.codepointat
    codeAt: createMethod(false),
    // `String.prototype.at` method
    // https://github.com/mathiasbynens/String.prototype.at
    charAt: createMethod(true)
};
}),
"[project]/node_modules/core-js-pure/modules/es.string.iterator.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var charAt = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/string-multibyte.js [app-client] (ecmascript)").charAt;
var toString = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/to-string.js [app-client] (ecmascript)");
var InternalStateModule = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/internal-state.js [app-client] (ecmascript)");
var defineIterator = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/iterator-define.js [app-client] (ecmascript)");
var createIterResultObject = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/create-iter-result-object.js [app-client] (ecmascript)");
var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
// `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function(iterated) {
    setInternalState(this, {
        type: STRING_ITERATOR,
        string: toString(iterated),
        index: 0
    });
// `%StringIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
    var state = getInternalState(this);
    var string = state.string;
    var index = state.index;
    var point;
    if (index >= string.length) return createIterResultObject(undefined, true);
    point = charAt(string, index);
    state.index += point.length;
    return createIterResultObject(point, false);
});
}),
"[project]/node_modules/core-js-pure/es/aggregate-error.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

__turbopack_context__.r("[project]/node_modules/core-js-pure/modules/es.error.cause.js [app-client] (ecmascript)");
__turbopack_context__.r("[project]/node_modules/core-js-pure/modules/es.aggregate-error.js [app-client] (ecmascript)");
__turbopack_context__.r("[project]/node_modules/core-js-pure/modules/es.aggregate-error.cause.js [app-client] (ecmascript)");
__turbopack_context__.r("[project]/node_modules/core-js-pure/modules/es.array.iterator.js [app-client] (ecmascript)");
__turbopack_context__.r("[project]/node_modules/core-js-pure/modules/es.string.iterator.js [app-client] (ecmascript)");
var path = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/path.js [app-client] (ecmascript)");
module.exports = path.AggregateError;
}),
"[project]/node_modules/core-js-pure/internals/dom-iterables.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
};
}),
"[project]/node_modules/core-js-pure/modules/web.dom-collections.iterator.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

__turbopack_context__.r("[project]/node_modules/core-js-pure/modules/es.array.iterator.js [app-client] (ecmascript)");
var DOMIterables = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/dom-iterables.js [app-client] (ecmascript)");
var globalThis = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/global-this.js [app-client] (ecmascript)");
var setToStringTag = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/set-to-string-tag.js [app-client] (ecmascript)");
var Iterators = __turbopack_context__.r("[project]/node_modules/core-js-pure/internals/iterators.js [app-client] (ecmascript)");
for(var COLLECTION_NAME in DOMIterables){
    setToStringTag(globalThis[COLLECTION_NAME], COLLECTION_NAME);
    Iterators[COLLECTION_NAME] = Iterators.Array;
}
}),
"[project]/node_modules/core-js-pure/stable/aggregate-error.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// TODO: remove from `core-js@4`
__turbopack_context__.r("[project]/node_modules/core-js-pure/modules/esnext.aggregate-error.js [app-client] (ecmascript)");
var parent = __turbopack_context__.r("[project]/node_modules/core-js-pure/es/aggregate-error.js [app-client] (ecmascript)");
__turbopack_context__.r("[project]/node_modules/core-js-pure/modules/web.dom-collections.iterator.js [app-client] (ecmascript)");
module.exports = parent;
}),
"[project]/node_modules/core-js-pure/actual/aggregate-error.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var parent = __turbopack_context__.r("[project]/node_modules/core-js-pure/stable/aggregate-error.js [app-client] (ecmascript)");
module.exports = parent;
}),
"[project]/node_modules/core-js-pure/full/aggregate-error.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// TODO: remove from `core-js@4`
__turbopack_context__.r("[project]/node_modules/core-js-pure/modules/esnext.aggregate-error.js [app-client] (ecmascript)");
var parent = __turbopack_context__.r("[project]/node_modules/core-js-pure/actual/aggregate-error.js [app-client] (ecmascript)");
module.exports = parent;
}),
"[project]/node_modules/core-js-pure/features/aggregate-error.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/core-js-pure/full/aggregate-error.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@babel/runtime-corejs3/helpers/esm/extends.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>_extends
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$core$2d$js$2d$pure$2f$features$2f$object$2f$assign$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/core-js-pure/features/object/assign.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$core$2d$js$2d$pure$2f$features$2f$instance$2f$bind$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/core-js-pure/features/instance/bind.js [app-client] (ecmascript)");
;
;
function _extends() {
    var _context;
    return _extends = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$core$2d$js$2d$pure$2f$features$2f$object$2f$assign$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$core$2d$js$2d$pure$2f$features$2f$instance$2f$bind$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(_context = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$core$2d$js$2d$pure$2f$features$2f$object$2f$assign$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]).call(_context) : function(n) {
        for(var e = 1; e < arguments.length; e++){
            var t = arguments[e];
            for(var r in t)({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
        }
        return n;
    }, _extends.apply(null, arguments);
}
;
}),
"[project]/node_modules/@babel/runtime-corejs3/core-js/aggregate-error.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = __turbopack_context__.r("[project]/node_modules/core-js-pure/features/aggregate-error.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>_objectWithoutPropertiesLoose
]);
function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for(var n in r)if (({}).hasOwnProperty.call(r, n)) {
        if (-1 !== e.indexOf(n)) continue;
        t[n] = r[n];
    }
    return t;
}
;
}),
"[project]/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>_objectWithoutProperties
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$objectWithoutPropertiesLoose$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js [app-client] (ecmascript)");
;
function _objectWithoutProperties(e, t) {
    if (null == e) return {};
    var o, r, i = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$objectWithoutPropertiesLoose$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(e, t);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(e);
        for(r = 0; r < n.length; r++)o = n[r], -1 === t.indexOf(o) && ({}).propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
}
;
}),
"[project]/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>_arrayLikeToArray
]);
function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];
    return n;
}
;
}),
"[project]/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>_arrayWithoutHoles
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$arrayLikeToArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js [app-client] (ecmascript)");
;
function _arrayWithoutHoles(r) {
    if (Array.isArray(r)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$arrayLikeToArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(r);
}
;
}),
"[project]/node_modules/@babel/runtime/helpers/esm/iterableToArray.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>_iterableToArray
]);
function _iterableToArray(r) {
    if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
;
}),
"[project]/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>_unsupportedIterableToArray
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$arrayLikeToArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js [app-client] (ecmascript)");
;
function _unsupportedIterableToArray(r, a) {
    if (r) {
        if ("string" == typeof r) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$arrayLikeToArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(r, a);
        var t = ({}).toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$arrayLikeToArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(r, a) : void 0;
    }
}
;
}),
"[project]/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>_nonIterableSpread
]);
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
;
}),
"[project]/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>_toConsumableArray
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$arrayWithoutHoles$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$iterableToArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/iterableToArray.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$unsupportedIterableToArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$nonIterableSpread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js [app-client] (ecmascript)");
;
;
;
;
function _toConsumableArray(r) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$arrayWithoutHoles$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(r) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$iterableToArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(r) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$unsupportedIterableToArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(r) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$nonIterableSpread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
}
;
}),
"[project]/node_modules/@babel/runtime/helpers/esm/typeof.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>_typeof
]);
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
;
}),
"[project]/node_modules/@babel/runtime/helpers/esm/toPrimitive.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>toPrimitive
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$typeof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/typeof.js [app-client] (ecmascript)");
;
function toPrimitive(t, r) {
    if ("object" != (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$typeof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$typeof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
;
}),
"[project]/node_modules/@babel/runtime/helpers/esm/toPropertyKey.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>toPropertyKey
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$typeof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/typeof.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$toPrimitive$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/toPrimitive.js [app-client] (ecmascript)");
;
;
function toPropertyKey(t) {
    var i = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$toPrimitive$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(t, "string");
    return "symbol" == (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$typeof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(i) ? i : i + "";
}
;
}),
"[project]/node_modules/@babel/runtime/helpers/esm/defineProperty.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>_defineProperty
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$toPropertyKey$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/toPropertyKey.js [app-client] (ecmascript)");
;
function _defineProperty(e, r, t) {
    return (r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$toPropertyKey$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
;
}),
"[project]/node_modules/@babel/runtime/helpers/esm/extends.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>_extends
]);
function _extends() {
    return _extends = ("TURBOPACK compile-time truthy", 1) ? Object.assign.bind() : "TURBOPACK unreachable", _extends.apply(null, arguments);
}
;
}),
"[project]/node_modules/classnames/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/ /* global define */ (function() {
    'use strict';
    var hasOwn = {}.hasOwnProperty;
    function classNames() {
        var classes = '';
        for(var i = 0; i < arguments.length; i++){
            var arg = arguments[i];
            if (arg) {
                classes = appendClass(classes, parseValue(arg));
            }
        }
        return classes;
    }
    function parseValue(arg) {
        if (typeof arg === 'string' || typeof arg === 'number') {
            return arg;
        }
        if (typeof arg !== 'object') {
            return '';
        }
        if (Array.isArray(arg)) {
            return classNames.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {
            return arg.toString();
        }
        var classes = '';
        for(var key in arg){
            if (hasOwn.call(arg, key) && arg[key]) {
                classes = appendClass(classes, key);
            }
        }
        return classes;
    }
    function appendClass(value, newClass) {
        if (!newClass) {
            return value;
        }
        if (value) {
            return value + ' ' + newClass;
        }
        return value + newClass;
    }
    if (("TURBOPACK compile-time value", "object") !== 'undefined' && module.exports) {
        classNames.default = classNames;
        module.exports = classNames;
    } else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
        // register as 'classnames', consistent with npm package name
        ((r)=>r !== undefined && __turbopack_context__.v(r))(function() {
            return classNames;
        }());
    } else {
        window.classNames = classNames;
    }
})();
}),
"[project]/node_modules/toggle-selection/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = function() {
    var selection = document.getSelection();
    if (!selection.rangeCount) {
        return function() {};
    }
    var active = document.activeElement;
    var ranges = [];
    for(var i = 0; i < selection.rangeCount; i++){
        ranges.push(selection.getRangeAt(i));
    }
    switch(active.tagName.toUpperCase()){
        case 'INPUT':
        case 'TEXTAREA':
            active.blur();
            break;
        default:
            active = null;
            break;
    }
    selection.removeAllRanges();
    return function() {
        selection.type === 'Caret' && selection.removeAllRanges();
        if (!selection.rangeCount) {
            ranges.forEach(function(range) {
                selection.addRange(range);
            });
        }
        active && active.focus();
    };
};
}),
"[project]/node_modules/copy-to-clipboard/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var deselectCurrent = __turbopack_context__.r("[project]/node_modules/toggle-selection/index.js [app-client] (ecmascript)");
var clipboardToIE11Formatting = {
    "text/plain": "Text",
    "text/html": "Url",
    "default": "Text"
};
var defaultMessage = "Copy to clipboard: #{key}, Enter";
function format(message) {
    var copyKey = (/mac os x/i.test(navigator.userAgent) ? "" : "Ctrl") + "+C";
    return message.replace(/#{\s*key\s*}/g, copyKey);
}
function copy(text, options) {
    var debug, message, reselectPrevious, range, selection, mark, success = false;
    if (!options) {
        options = {};
    }
    debug = options.debug || false;
    try {
        reselectPrevious = deselectCurrent();
        range = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        // avoid screen readers from reading out loud the text
        mark.ariaHidden = "true";
        // reset user styles for span element
        mark.style.all = "unset";
        // prevents scrolling to the end of the page
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        // used to preserve spaces and line breaks
        mark.style.whiteSpace = "pre";
        // do not inherit user-select (it may be `none`)
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e) {
            e.stopPropagation();
            if (options.format) {
                e.preventDefault();
                if (typeof e.clipboardData === "undefined") {
                    debug && console.warn("unable to use e.clipboardData");
                    debug && console.warn("trying IE specific stuff");
                    window.clipboardData.clearData();
                    var format = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
                    window.clipboardData.setData(format, text);
                } else {
                    e.clipboardData.clearData();
                    e.clipboardData.setData(options.format, text);
                }
            }
            if (options.onCopy) {
                e.preventDefault();
                options.onCopy(e.clipboardData);
            }
        });
        document.body.appendChild(mark);
        range.selectNodeContents(mark);
        selection.addRange(range);
        var successful = document.execCommand("copy");
        if (!successful) {
            throw new Error("copy command was unsuccessful");
        }
        success = true;
    } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
            window.clipboardData.setData(options.format || "text", text);
            options.onCopy && options.onCopy(window.clipboardData);
            success = true;
        } catch (err) {
            debug && console.error("unable to copy using clipboardData: ", err);
            debug && console.error("falling back to prompt");
            message = format("message" in options ? options.message : defaultMessage);
            window.prompt(message, text);
        }
    } finally{
        if (selection) {
            if (typeof selection.removeRange == "function") {
                selection.removeRange(range);
            } else {
                selection.removeAllRanges();
            }
        }
        if (mark) {
            document.body.removeChild(mark);
        }
        reselectPrevious();
    }
    return success;
}
module.exports = copy;
}),
"[project]/node_modules/react-copy-to-clipboard/lib/Component.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
}
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CopyToClipboard = void 0;
var _react = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
var _copyToClipboard = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/copy-to-clipboard/index.js [app-client] (ecmascript)"));
var _excluded = [
    "text",
    "onCopy",
    "options",
    "children"
];
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    };
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    Object.defineProperty(subClass, "prototype", {
        writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
    } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var CopyToClipboard = /*#__PURE__*/ function(_React$PureComponent) {
    _inherits(CopyToClipboard, _React$PureComponent);
    var _super = _createSuper(CopyToClipboard);
    function CopyToClipboard() {
        var _this;
        _classCallCheck(this, CopyToClipboard);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this), "onClick", function(event) {
            var _this$props = _this.props, text = _this$props.text, onCopy = _this$props.onCopy, children = _this$props.children, options = _this$props.options;
            var elem = _react["default"].Children.only(children);
            var result = (0, _copyToClipboard["default"])(text, options);
            if (onCopy) {
                onCopy(text, result);
            } // Bypass onClick if it was present
            if (elem && elem.props && typeof elem.props.onClick === 'function') {
                elem.props.onClick(event);
            }
        });
        return _this;
    }
    _createClass(CopyToClipboard, [
        {
            key: "render",
            value: function render() {
                var _this$props2 = this.props, _text = _this$props2.text, _onCopy = _this$props2.onCopy, _options = _this$props2.options, children = _this$props2.children, props = _objectWithoutProperties(_this$props2, _excluded);
                var elem = _react["default"].Children.only(children);
                return /*#__PURE__*/ _react["default"].cloneElement(elem, _objectSpread(_objectSpread({}, props), {}, {
                    onClick: this.onClick
                }));
            }
        }
    ]);
    return CopyToClipboard;
}(_react["default"].PureComponent);
exports.CopyToClipboard = CopyToClipboard;
_defineProperty(CopyToClipboard, "defaultProps", {
    onCopy: undefined,
    options: undefined
});
}),
"[project]/node_modules/react-copy-to-clipboard/lib/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/react-copy-to-clipboard/lib/Component.js [app-client] (ecmascript)"), CopyToClipboard = _require.CopyToClipboard;
CopyToClipboard.CopyToClipboard = CopyToClipboard;
module.exports = CopyToClipboard;
}),
"[project]/node_modules/react-immutable-pure-component/lib/react-immutable-pure-component.es.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ImmutablePureComponent",
    ()=>ImmutablePureComponent,
    "default",
    ()=>__TURBOPACK__default__export__,
    "immutableMemo",
    ()=>immutableMemo
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immutable$2f$dist$2f$immutable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/immutable/dist/immutable.js [app-client] (ecmascript)");
;
;
function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function(obj) {
            return typeof obj;
        };
    } else {
        _typeof = function(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread2(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
            ownKeys(source, true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
            });
        } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
            ownKeys(source).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
        }
    }
    return target;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _assertThisInitialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized(self);
}
var NOT_SET = {};
function isMapLike(collection) {
    return collection !== null && _typeof(collection) === 'object' && typeof collection.get === 'function' && typeof collection.has === 'function';
}
function isInvalid(collection) {
    return collection === null || collection === undefined;
}
function get(collection, key, notSetValue) {
    if (isInvalid(collection)) {
        return notSetValue;
    }
    if (isMapLike(collection)) {
        return collection.has(key) ? collection.get(key) : notSetValue;
    }
    return hasOwnProperty.call(collection, key) ? collection[key] : notSetValue;
}
function getIn(collection, keyPath, notSetValue) {
    var i = 0;
    while(i !== keyPath.length){
        collection = get(collection, keyPath[i++], NOT_SET);
        if (collection === NOT_SET) {
            return notSetValue;
        }
    }
    return collection;
}
function check(config) {
    var prev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var next = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var checkItem = createChecker(prev, next);
    var checklist = config || Object.keys(_objectSpread2({}, next, {}, prev));
    return checklist.every(checkItem);
}
function createChecker(prev, next) {
    return function(name) {
        if (typeof name === 'string') {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immutable$2f$dist$2f$immutable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["is"])(next[name], prev[name]);
        } else if (Array.isArray(name)) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immutable$2f$dist$2f$immutable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["is"])(getIn(next, name), getIn(prev, name));
        }
        throw new TypeError('Invalid key: expected Array or string: ' + name);
    };
}
var ImmutablePureComponent = /*#__PURE__*/ function(_React$Component) {
    _inherits(ImmutablePureComponent, _React$Component);
    function ImmutablePureComponent() {
        _classCallCheck(this, ImmutablePureComponent);
        return _possibleConstructorReturn(this, _getPrototypeOf(ImmutablePureComponent).apply(this, arguments));
    }
    _createClass(ImmutablePureComponent, [
        {
            key: "shouldComponentUpdate",
            value: function shouldComponentUpdate(nextProps) {
                var nextState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                return !check(this.updateOnProps, this.props, nextProps, 'updateOnProps') || !check(this.updateOnStates, this.state, nextState, 'updateOnStates');
            }
        }
    ]);
    return ImmutablePureComponent;
}(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Component);
function immutableMemo(Component, updateOnProps) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].memo(Component, function(prev, next) {
        return check(updateOnProps, prev, next, 'immutableMemo');
    });
}
const __TURBOPACK__default__export__ = ImmutablePureComponent;
;
}),
"[project]/node_modules/lodash.debounce/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the `TypeError` message for "Functions" methods. */ var FUNC_ERROR_TEXT = 'Expected a function';
/** Used as references for various `Number` constants. */ var NAN = 0 / 0;
/** `Object#toString` result references. */ var symbolTag = '[object Symbol]';
/** Used to match leading and trailing whitespace. */ var reTrim = /^\s+|\s+$/g;
/** Used to detect bad signed hexadecimal string values. */ var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */ var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */ var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */ var freeParseInt = parseInt;
/** Detect free variable `global` from Node.js. */ var freeGlobal = ("TURBOPACK compile-time value", "object") == 'object' && /*TURBOPACK member replacement*/ __turbopack_context__.g && /*TURBOPACK member replacement*/ __turbopack_context__.g.Object === Object && /*TURBOPACK member replacement*/ __turbopack_context__.g;
/** Detect free variable `self`. */ var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function('return this')();
/** Used for built-in method references. */ var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max, nativeMin = Math.min;
/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */ var now = function() {
    return root.Date.now();
};
/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */ function debounce(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
    }
    function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result = wait - timeSinceLastCall;
        return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
    }
    function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
            return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
        timerId = undefined;
        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
            return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
    }
    function cancel() {
        if (timerId !== undefined) {
            clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
    }
    function flush() {
        return timerId === undefined ? result : trailingEdge(now());
    }
    function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
            if (timerId === undefined) {
                return leadingEdge(lastCallTime);
            }
            if (maxing) {
                // Handle invocations in a tight loop.
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
            }
        }
        if (timerId === undefined) {
            timerId = setTimeout(timerExpired, wait);
        }
        return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == 'object';
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */ function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */ function toNumber(value) {
    if (typeof value == 'number') {
        return value;
    }
    if (isSymbol(value)) {
        return NAN;
    }
    if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? other + '' : other;
    }
    if (typeof value != 'string') {
        return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
module.exports = debounce;
}),
"[project]/node_modules/react-debounce-input/lib/Component.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
}
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DebounceInput = void 0;
var _react = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
var _lodash = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/lodash.debounce/index.js [app-client] (ecmascript)"));
var _excluded = [
    "element",
    "onChange",
    "value",
    "minLength",
    "debounceTimeout",
    "forceNotifyByEnter",
    "forceNotifyOnBlur",
    "onKeyDown",
    "onBlur",
    "inputRef"
];
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    };
}
function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    Object.defineProperty(subClass, "prototype", {
        writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
    } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var DebounceInput = /*#__PURE__*/ function(_React$PureComponent) {
    _inherits(DebounceInput, _React$PureComponent);
    var _super = _createSuper(DebounceInput);
    function DebounceInput(props) {
        var _this;
        _classCallCheck(this, DebounceInput);
        _this = _super.call(this, props);
        _defineProperty(_assertThisInitialized(_this), "onChange", function(event) {
            event.persist();
            var oldValue = _this.state.value;
            var minLength = _this.props.minLength;
            _this.setState({
                value: event.target.value
            }, function() {
                var value = _this.state.value;
                if (value.length >= minLength) {
                    _this.notify(event);
                    return;
                } // If user hits backspace and goes below minLength consider it cleaning the value
                if (oldValue.length > value.length) {
                    _this.notify(_objectSpread(_objectSpread({}, event), {}, {
                        target: _objectSpread(_objectSpread({}, event.target), {}, {
                            value: ''
                        })
                    }));
                }
            });
        });
        _defineProperty(_assertThisInitialized(_this), "onKeyDown", function(event) {
            if (event.key === 'Enter') {
                _this.forceNotify(event);
            } // Invoke original onKeyDown if present
            var onKeyDown = _this.props.onKeyDown;
            if (onKeyDown) {
                event.persist();
                onKeyDown(event);
            }
        });
        _defineProperty(_assertThisInitialized(_this), "onBlur", function(event) {
            _this.forceNotify(event); // Invoke original onBlur if present
            var onBlur = _this.props.onBlur;
            if (onBlur) {
                event.persist();
                onBlur(event);
            }
        });
        _defineProperty(_assertThisInitialized(_this), "createNotifier", function(debounceTimeout) {
            if (debounceTimeout < 0) {
                _this.notify = function() {
                    return null;
                };
            } else if (debounceTimeout === 0) {
                _this.notify = _this.doNotify;
            } else {
                var debouncedChangeFunc = (0, _lodash["default"])(function(event) {
                    _this.isDebouncing = false;
                    _this.doNotify(event);
                }, debounceTimeout);
                _this.notify = function(event) {
                    _this.isDebouncing = true;
                    debouncedChangeFunc(event);
                };
                _this.flush = function() {
                    return debouncedChangeFunc.flush();
                };
                _this.cancel = function() {
                    _this.isDebouncing = false;
                    debouncedChangeFunc.cancel();
                };
            }
        });
        _defineProperty(_assertThisInitialized(_this), "doNotify", function() {
            var onChange = _this.props.onChange;
            onChange.apply(void 0, arguments);
        });
        _defineProperty(_assertThisInitialized(_this), "forceNotify", function(event) {
            var debounceTimeout = _this.props.debounceTimeout;
            if (!_this.isDebouncing && debounceTimeout > 0) {
                return;
            }
            if (_this.cancel) {
                _this.cancel();
            }
            var value = _this.state.value;
            var minLength = _this.props.minLength;
            if (value.length >= minLength) {
                _this.doNotify(event);
            } else {
                _this.doNotify(_objectSpread(_objectSpread({}, event), {}, {
                    target: _objectSpread(_objectSpread({}, event.target), {}, {
                        value: value
                    })
                }));
            }
        });
        _this.isDebouncing = false;
        _this.state = {
            value: typeof props.value === 'undefined' || props.value === null ? '' : props.value
        };
        var _debounceTimeout2 = _this.props.debounceTimeout;
        _this.createNotifier(_debounceTimeout2);
        return _this;
    }
    _createClass(DebounceInput, [
        {
            key: "componentDidUpdate",
            value: function componentDidUpdate(prevProps) {
                if (this.isDebouncing) {
                    return;
                }
                var _this$props = this.props, value = _this$props.value, debounceTimeout = _this$props.debounceTimeout;
                var oldTimeout = prevProps.debounceTimeout, oldValue = prevProps.value;
                var stateValue = this.state.value;
                if (typeof value !== 'undefined' && oldValue !== value && stateValue !== value) {
                    // Update state.value if new value passed via props, yep re-render should happen
                    // eslint-disable-next-line react/no-did-update-set-state
                    this.setState({
                        value: value
                    });
                }
                if (debounceTimeout !== oldTimeout) {
                    this.createNotifier(debounceTimeout);
                }
            }
        },
        {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                if (this.flush) {
                    this.flush();
                }
            }
        },
        {
            key: "render",
            value: function render() {
                var _this$props2 = this.props, element = _this$props2.element, _onChange = _this$props2.onChange, _value = _this$props2.value, _minLength = _this$props2.minLength, _debounceTimeout = _this$props2.debounceTimeout, forceNotifyByEnter = _this$props2.forceNotifyByEnter, forceNotifyOnBlur = _this$props2.forceNotifyOnBlur, onKeyDown = _this$props2.onKeyDown, onBlur = _this$props2.onBlur, inputRef = _this$props2.inputRef, props = _objectWithoutProperties(_this$props2, _excluded);
                var value = this.state.value;
                var maybeOnKeyDown;
                if (forceNotifyByEnter) {
                    maybeOnKeyDown = {
                        onKeyDown: this.onKeyDown
                    };
                } else if (onKeyDown) {
                    maybeOnKeyDown = {
                        onKeyDown: onKeyDown
                    };
                } else {
                    maybeOnKeyDown = {};
                }
                var maybeOnBlur;
                if (forceNotifyOnBlur) {
                    maybeOnBlur = {
                        onBlur: this.onBlur
                    };
                } else if (onBlur) {
                    maybeOnBlur = {
                        onBlur: onBlur
                    };
                } else {
                    maybeOnBlur = {};
                }
                var maybeRef = inputRef ? {
                    ref: inputRef
                } : {};
                return /*#__PURE__*/ _react["default"].createElement(element, _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, props), {}, {
                    onChange: this.onChange,
                    value: value
                }, maybeOnKeyDown), maybeOnBlur), maybeRef));
            }
        }
    ]);
    return DebounceInput;
}(_react["default"].PureComponent);
exports.DebounceInput = DebounceInput;
_defineProperty(DebounceInput, "defaultProps", {
    element: 'input',
    type: 'text',
    onKeyDown: undefined,
    onBlur: undefined,
    value: undefined,
    minLength: 0,
    debounceTimeout: 100,
    forceNotifyByEnter: true,
    forceNotifyOnBlur: true,
    inputRef: undefined
});
}),
"[project]/node_modules/react-debounce-input/lib/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/react-debounce-input/lib/Component.js [app-client] (ecmascript)"), DebounceInput = _require.DebounceInput;
DebounceInput.DebounceInput = DebounceInput;
module.exports = DebounceInput;
}),
"[project]/node_modules/ret/lib/types.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = {
    ROOT: 0,
    GROUP: 1,
    POSITION: 2,
    SET: 3,
    RANGE: 4,
    REPETITION: 5,
    REFERENCE: 6,
    CHAR: 7
};
}),
"[project]/node_modules/ret/lib/sets.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const types = __turbopack_context__.r("[project]/node_modules/ret/lib/types.js [app-client] (ecmascript)");
const INTS = ()=>[
        {
            type: types.RANGE,
            from: 48,
            to: 57
        }
    ];
const WORDS = ()=>{
    return [
        {
            type: types.CHAR,
            value: 95
        },
        {
            type: types.RANGE,
            from: 97,
            to: 122
        },
        {
            type: types.RANGE,
            from: 65,
            to: 90
        }
    ].concat(INTS());
};
const WHITESPACE = ()=>{
    return [
        {
            type: types.CHAR,
            value: 9
        },
        {
            type: types.CHAR,
            value: 10
        },
        {
            type: types.CHAR,
            value: 11
        },
        {
            type: types.CHAR,
            value: 12
        },
        {
            type: types.CHAR,
            value: 13
        },
        {
            type: types.CHAR,
            value: 32
        },
        {
            type: types.CHAR,
            value: 160
        },
        {
            type: types.CHAR,
            value: 5760
        },
        {
            type: types.RANGE,
            from: 8192,
            to: 8202
        },
        {
            type: types.CHAR,
            value: 8232
        },
        {
            type: types.CHAR,
            value: 8233
        },
        {
            type: types.CHAR,
            value: 8239
        },
        {
            type: types.CHAR,
            value: 8287
        },
        {
            type: types.CHAR,
            value: 12288
        },
        {
            type: types.CHAR,
            value: 65279
        }
    ];
};
const NOTANYCHAR = ()=>{
    return [
        {
            type: types.CHAR,
            value: 10
        },
        {
            type: types.CHAR,
            value: 13
        },
        {
            type: types.CHAR,
            value: 8232
        },
        {
            type: types.CHAR,
            value: 8233
        }
    ];
};
// Predefined class objects.
exports.words = ()=>({
        type: types.SET,
        set: WORDS(),
        not: false
    });
exports.notWords = ()=>({
        type: types.SET,
        set: WORDS(),
        not: true
    });
exports.ints = ()=>({
        type: types.SET,
        set: INTS(),
        not: false
    });
exports.notInts = ()=>({
        type: types.SET,
        set: INTS(),
        not: true
    });
exports.whitespace = ()=>({
        type: types.SET,
        set: WHITESPACE(),
        not: false
    });
exports.notWhitespace = ()=>({
        type: types.SET,
        set: WHITESPACE(),
        not: true
    });
exports.anyChar = ()=>({
        type: types.SET,
        set: NOTANYCHAR(),
        not: true
    });
}),
"[project]/node_modules/ret/lib/util.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const types = __turbopack_context__.r("[project]/node_modules/ret/lib/types.js [app-client] (ecmascript)");
const sets = __turbopack_context__.r("[project]/node_modules/ret/lib/sets.js [app-client] (ecmascript)");
const CTRL = '@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?';
const SLSH = {
    '0': 0,
    't': 9,
    'n': 10,
    'v': 11,
    'f': 12,
    'r': 13
};
/**
 * Finds character representations in str and convert all to
 * their respective characters
 *
 * @param {String} str
 * @return {String}
 */ exports.strToChars = function(str) {
    /* jshint maxlen: false */ var chars_regex = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g;
    str = str.replace(chars_regex, function(s, b, lbs, a16, b16, c8, dctrl, eslsh) {
        if (lbs) {
            return s;
        }
        var code = b ? 8 : a16 ? parseInt(a16, 16) : b16 ? parseInt(b16, 16) : c8 ? parseInt(c8, 8) : dctrl ? CTRL.indexOf(dctrl) : SLSH[eslsh];
        var c = String.fromCharCode(code);
        // Escape special regex characters.
        if (/[[\]{}^$.|?*+()]/.test(c)) {
            c = '\\' + c;
        }
        return c;
    });
    return str;
};
/**
 * turns class into tokens
 * reads str until it encounters a ] not preceeded by a \
 *
 * @param {String} str
 * @param {String} regexpStr
 * @return {Array.<Array.<Object>, Number>}
 */ exports.tokenizeClass = (str, regexpStr)=>{
    /* jshint maxlen: false */ var tokens = [];
    var regexp = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(?:\\)?([^\]]))|(\])|(?:\\)?([^])/g;
    var rs, c;
    while((rs = regexp.exec(str)) != null){
        if (rs[1]) {
            tokens.push(sets.words());
        } else if (rs[2]) {
            tokens.push(sets.ints());
        } else if (rs[3]) {
            tokens.push(sets.whitespace());
        } else if (rs[4]) {
            tokens.push(sets.notWords());
        } else if (rs[5]) {
            tokens.push(sets.notInts());
        } else if (rs[6]) {
            tokens.push(sets.notWhitespace());
        } else if (rs[7]) {
            tokens.push({
                type: types.RANGE,
                from: (rs[8] || rs[9]).charCodeAt(0),
                to: rs[10].charCodeAt(0)
            });
        } else if (c = rs[12]) {
            tokens.push({
                type: types.CHAR,
                value: c.charCodeAt(0)
            });
        } else {
            return [
                tokens,
                regexp.lastIndex
            ];
        }
    }
    exports.error(regexpStr, 'Unterminated character class');
};
/**
 * Shortcut to throw errors.
 *
 * @param {String} regexp
 * @param {String} msg
 */ exports.error = (regexp, msg)=>{
    throw new SyntaxError('Invalid regular expression: /' + regexp + '/: ' + msg);
};
}),
"[project]/node_modules/ret/lib/positions.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const types = __turbopack_context__.r("[project]/node_modules/ret/lib/types.js [app-client] (ecmascript)");
exports.wordBoundary = ()=>({
        type: types.POSITION,
        value: 'b'
    });
exports.nonWordBoundary = ()=>({
        type: types.POSITION,
        value: 'B'
    });
exports.begin = ()=>({
        type: types.POSITION,
        value: '^'
    });
exports.end = ()=>({
        type: types.POSITION,
        value: '$'
    });
}),
"[project]/node_modules/ret/lib/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const util = __turbopack_context__.r("[project]/node_modules/ret/lib/util.js [app-client] (ecmascript)");
const types = __turbopack_context__.r("[project]/node_modules/ret/lib/types.js [app-client] (ecmascript)");
const sets = __turbopack_context__.r("[project]/node_modules/ret/lib/sets.js [app-client] (ecmascript)");
const positions = __turbopack_context__.r("[project]/node_modules/ret/lib/positions.js [app-client] (ecmascript)");
module.exports = (regexpStr)=>{
    var i = 0, l, c, start = {
        type: types.ROOT,
        stack: []
    }, // Keep track of last clause/group and stack.
    lastGroup = start, last = start.stack, groupStack = [];
    var repeatErr = (i)=>{
        util.error(regexpStr, `Nothing to repeat at column ${i - 1}`);
    };
    // Decode a few escaped characters.
    var str = util.strToChars(regexpStr);
    l = str.length;
    // Iterate through each character in string.
    while(i < l){
        c = str[i++];
        switch(c){
            // Handle escaped characters, inclues a few sets.
            case '\\':
                c = str[i++];
                switch(c){
                    case 'b':
                        last.push(positions.wordBoundary());
                        break;
                    case 'B':
                        last.push(positions.nonWordBoundary());
                        break;
                    case 'w':
                        last.push(sets.words());
                        break;
                    case 'W':
                        last.push(sets.notWords());
                        break;
                    case 'd':
                        last.push(sets.ints());
                        break;
                    case 'D':
                        last.push(sets.notInts());
                        break;
                    case 's':
                        last.push(sets.whitespace());
                        break;
                    case 'S':
                        last.push(sets.notWhitespace());
                        break;
                    default:
                        // Check if c is integer.
                        // In which case it's a reference.
                        if (/\d/.test(c)) {
                            last.push({
                                type: types.REFERENCE,
                                value: parseInt(c, 10)
                            });
                        // Escaped character.
                        } else {
                            last.push({
                                type: types.CHAR,
                                value: c.charCodeAt(0)
                            });
                        }
                }
                break;
            // Positionals.
            case '^':
                last.push(positions.begin());
                break;
            case '$':
                last.push(positions.end());
                break;
            // Handle custom sets.
            case '[':
                // Check if this class is 'anti' i.e. [^abc].
                var not;
                if (str[i] === '^') {
                    not = true;
                    i++;
                } else {
                    not = false;
                }
                // Get all the characters in class.
                var classTokens = util.tokenizeClass(str.slice(i), regexpStr);
                // Increase index by length of class.
                i += classTokens[1];
                last.push({
                    type: types.SET,
                    set: classTokens[0],
                    not
                });
                break;
            // Class of any character except \n.
            case '.':
                last.push(sets.anyChar());
                break;
            // Push group onto stack.
            case '(':
                // Create group.
                var group = {
                    type: types.GROUP,
                    stack: [],
                    remember: true
                };
                c = str[i];
                // If if this is a special kind of group.
                if (c === '?') {
                    c = str[i + 1];
                    i += 2;
                    // Match if followed by.
                    if (c === '=') {
                        group.followedBy = true;
                    // Match if not followed by.
                    } else if (c === '!') {
                        group.notFollowedBy = true;
                    } else if (c !== ':') {
                        util.error(regexpStr, `Invalid group, character '${c}'` + ` after '?' at column ${i - 1}`);
                    }
                    group.remember = false;
                }
                // Insert subgroup into current group stack.
                last.push(group);
                // Remember the current group for when the group closes.
                groupStack.push(lastGroup);
                // Make this new group the current group.
                lastGroup = group;
                last = group.stack;
                break;
            // Pop group out of stack.
            case ')':
                if (groupStack.length === 0) {
                    util.error(regexpStr, `Unmatched ) at column ${i - 1}`);
                }
                lastGroup = groupStack.pop();
                // Check if this group has a PIPE.
                // To get back the correct last stack.
                last = lastGroup.options ? lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;
                break;
            // Use pipe character to give more choices.
            case '|':
                // Create array where options are if this is the first PIPE
                // in this clause.
                if (!lastGroup.options) {
                    lastGroup.options = [
                        lastGroup.stack
                    ];
                    delete lastGroup.stack;
                }
                // Create a new stack and add to options for rest of clause.
                var stack = [];
                lastGroup.options.push(stack);
                last = stack;
                break;
            // Repetition.
            // For every repetition, remove last element from last stack
            // then insert back a RANGE object.
            // This design is chosen because there could be more than
            // one repetition symbols in a regex i.e. `a?+{2,3}`.
            case '{':
                var rs = /^(\d+)(,(\d+)?)?\}/.exec(str.slice(i)), min, max;
                if (rs !== null) {
                    if (last.length === 0) {
                        repeatErr(i);
                    }
                    min = parseInt(rs[1], 10);
                    max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;
                    i += rs[0].length;
                    last.push({
                        type: types.REPETITION,
                        min,
                        max,
                        value: last.pop()
                    });
                } else {
                    last.push({
                        type: types.CHAR,
                        value: 123
                    });
                }
                break;
            case '?':
                if (last.length === 0) {
                    repeatErr(i);
                }
                last.push({
                    type: types.REPETITION,
                    min: 0,
                    max: 1,
                    value: last.pop()
                });
                break;
            case '+':
                if (last.length === 0) {
                    repeatErr(i);
                }
                last.push({
                    type: types.REPETITION,
                    min: 1,
                    max: Infinity,
                    value: last.pop()
                });
                break;
            case '*':
                if (last.length === 0) {
                    repeatErr(i);
                }
                last.push({
                    type: types.REPETITION,
                    min: 0,
                    max: Infinity,
                    value: last.pop()
                });
                break;
            // Default is a character that is not `\[](){}?+*^$`.
            default:
                last.push({
                    type: types.CHAR,
                    value: c.charCodeAt(0)
                });
        }
    }
    // Check if any groups have not been closed.
    if (groupStack.length !== 0) {
        util.error(regexpStr, 'Unterminated group');
    }
    return start;
};
module.exports.types = types;
}),
"[project]/node_modules/drange/lib/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint indent: 4 */ // Private helper class
class SubRange {
    constructor(low, high){
        this.low = low;
        this.high = high;
        this.length = 1 + high - low;
    }
    overlaps(range) {
        return !(this.high < range.low || this.low > range.high);
    }
    touches(range) {
        return !(this.high + 1 < range.low || this.low - 1 > range.high);
    }
    // Returns inclusive combination of SubRanges as a SubRange.
    add(range) {
        return new SubRange(Math.min(this.low, range.low), Math.max(this.high, range.high));
    }
    // Returns subtraction of SubRanges as an array of SubRanges.
    // (There's a case where subtraction divides it in 2)
    subtract(range) {
        if (range.low <= this.low && range.high >= this.high) {
            return [];
        } else if (range.low > this.low && range.high < this.high) {
            return [
                new SubRange(this.low, range.low - 1),
                new SubRange(range.high + 1, this.high)
            ];
        } else if (range.low <= this.low) {
            return [
                new SubRange(range.high + 1, this.high)
            ];
        } else {
            return [
                new SubRange(this.low, range.low - 1)
            ];
        }
    }
    toString() {
        return this.low == this.high ? this.low.toString() : this.low + '-' + this.high;
    }
}
class DRange {
    constructor(a, b){
        this.ranges = [];
        this.length = 0;
        if (a != null) this.add(a, b);
    }
    _update_length() {
        this.length = this.ranges.reduce((previous, range)=>{
            return previous + range.length;
        }, 0);
    }
    add(a, b) {
        var _add = (subrange)=>{
            var i = 0;
            while(i < this.ranges.length && !subrange.touches(this.ranges[i])){
                i++;
            }
            var newRanges = this.ranges.slice(0, i);
            while(i < this.ranges.length && subrange.touches(this.ranges[i])){
                subrange = subrange.add(this.ranges[i]);
                i++;
            }
            newRanges.push(subrange);
            this.ranges = newRanges.concat(this.ranges.slice(i));
            this._update_length();
        };
        if (a instanceof DRange) {
            a.ranges.forEach(_add);
        } else {
            if (b == null) b = a;
            _add(new SubRange(a, b));
        }
        return this;
    }
    subtract(a, b) {
        var _subtract = (subrange)=>{
            var i = 0;
            while(i < this.ranges.length && !subrange.overlaps(this.ranges[i])){
                i++;
            }
            var newRanges = this.ranges.slice(0, i);
            while(i < this.ranges.length && subrange.overlaps(this.ranges[i])){
                newRanges = newRanges.concat(this.ranges[i].subtract(subrange));
                i++;
            }
            this.ranges = newRanges.concat(this.ranges.slice(i));
            this._update_length();
        };
        if (a instanceof DRange) {
            a.ranges.forEach(_subtract);
        } else {
            if (b == null) b = a;
            _subtract(new SubRange(a, b));
        }
        return this;
    }
    intersect(a, b) {
        var newRanges = [];
        var _intersect = (subrange)=>{
            var i = 0;
            while(i < this.ranges.length && !subrange.overlaps(this.ranges[i])){
                i++;
            }
            while(i < this.ranges.length && subrange.overlaps(this.ranges[i])){
                var low = Math.max(this.ranges[i].low, subrange.low);
                var high = Math.min(this.ranges[i].high, subrange.high);
                newRanges.push(new SubRange(low, high));
                i++;
            }
        };
        if (a instanceof DRange) {
            a.ranges.forEach(_intersect);
        } else {
            if (b == null) b = a;
            _intersect(new SubRange(a, b));
        }
        this.ranges = newRanges;
        this._update_length();
        return this;
    }
    index(index) {
        var i = 0;
        while(i < this.ranges.length && this.ranges[i].length <= index){
            index -= this.ranges[i].length;
            i++;
        }
        return this.ranges[i].low + index;
    }
    toString() {
        return '[ ' + this.ranges.join(', ') + ' ]';
    }
    clone() {
        return new DRange(this);
    }
    numbers() {
        return this.ranges.reduce((result, subrange)=>{
            var i = subrange.low;
            while(i <= subrange.high){
                result.push(i);
                i++;
            }
            return result;
        }, []);
    }
    subranges() {
        return this.ranges.map((subrange)=>({
                low: subrange.low,
                high: subrange.high,
                length: 1 + subrange.high - subrange.low
            }));
    }
}
module.exports = DRange;
}),
"[project]/node_modules/randexp/lib/randexp.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const ret = __turbopack_context__.r("[project]/node_modules/ret/lib/index.js [app-client] (ecmascript)");
const DRange = __turbopack_context__.r("[project]/node_modules/drange/lib/index.js [app-client] (ecmascript)");
const types = ret.types;
module.exports = class RandExp {
    /**
   * @constructor
   * @param {RegExp|String} regexp
   * @param {String} m
   */ constructor(regexp, m){
        this._setDefaults(regexp);
        if (regexp instanceof RegExp) {
            this.ignoreCase = regexp.ignoreCase;
            this.multiline = regexp.multiline;
            regexp = regexp.source;
        } else if (typeof regexp === 'string') {
            this.ignoreCase = m && m.indexOf('i') !== -1;
            this.multiline = m && m.indexOf('m') !== -1;
        } else {
            throw new Error('Expected a regexp or string');
        }
        this.tokens = ret(regexp);
    }
    /**
   * Checks if some custom properties have been set for this regexp.
   *
   * @param {RandExp} randexp
   * @param {RegExp} regexp
   */ _setDefaults(regexp) {
        // When a repetitional token has its max set to Infinite,
        // randexp won't actually generate a random amount between min and Infinite
        // instead it will see Infinite as min + 100.
        this.max = regexp.max != null ? regexp.max : RandExp.prototype.max != null ? RandExp.prototype.max : 100;
        // This allows expanding to include additional characters
        // for instance: RandExp.defaultRange.add(0, 65535);
        this.defaultRange = regexp.defaultRange ? regexp.defaultRange : this.defaultRange.clone();
        if (regexp.randInt) {
            this.randInt = regexp.randInt;
        }
    }
    /**
   * Generates the random string.
   *
   * @return {String}
   */ gen() {
        return this._gen(this.tokens, []);
    }
    /**
   * Generate random string modeled after given tokens.
   *
   * @param {Object} token
   * @param {Array.<String>} groups
   * @return {String}
   */ _gen(token, groups) {
        var stack, str, n, i, l;
        switch(token.type){
            case types.ROOT:
            case types.GROUP:
                // Ignore lookaheads for now.
                if (token.followedBy || token.notFollowedBy) {
                    return '';
                }
                // Insert placeholder until group string is generated.
                if (token.remember && token.groupNumber === undefined) {
                    token.groupNumber = groups.push(null) - 1;
                }
                stack = token.options ? this._randSelect(token.options) : token.stack;
                str = '';
                for(i = 0, l = stack.length; i < l; i++){
                    str += this._gen(stack[i], groups);
                }
                if (token.remember) {
                    groups[token.groupNumber] = str;
                }
                return str;
            case types.POSITION:
                // Do nothing for now.
                return '';
            case types.SET:
                var expandedSet = this._expand(token);
                if (!expandedSet.length) {
                    return '';
                }
                return String.fromCharCode(this._randSelect(expandedSet));
            case types.REPETITION:
                // Randomly generate number between min and max.
                n = this.randInt(token.min, token.max === Infinity ? token.min + this.max : token.max);
                str = '';
                for(i = 0; i < n; i++){
                    str += this._gen(token.value, groups);
                }
                return str;
            case types.REFERENCE:
                return groups[token.value - 1] || '';
            case types.CHAR:
                var code = this.ignoreCase && this._randBool() ? this._toOtherCase(token.value) : token.value;
                return String.fromCharCode(code);
        }
    }
    /**
   * If code is alphabetic, converts to other case.
   * If not alphabetic, returns back code.
   *
   * @param {Number} code
   * @return {Number}
   */ _toOtherCase(code) {
        return code + (97 <= code && code <= 122 ? -32 : 65 <= code && code <= 90 ? 32 : 0);
    }
    /**
   * Randomly returns a true or false value.
   *
   * @return {Boolean}
   */ _randBool() {
        return !this.randInt(0, 1);
    }
    /**
   * Randomly selects and returns a value from the array.
   *
   * @param {Array.<Object>} arr
   * @return {Object}
   */ _randSelect(arr) {
        if (arr instanceof DRange) {
            return arr.index(this.randInt(0, arr.length - 1));
        }
        return arr[this.randInt(0, arr.length - 1)];
    }
    /**
   * expands a token to a DiscontinuousRange of characters which has a
   * length and an index function (for random selecting)
   *
   * @param {Object} token
   * @return {DiscontinuousRange}
   */ _expand(token) {
        if (token.type === ret.types.CHAR) {
            return new DRange(token.value);
        } else if (token.type === ret.types.RANGE) {
            return new DRange(token.from, token.to);
        } else {
            let drange = new DRange();
            for(let i = 0; i < token.set.length; i++){
                let subrange = this._expand(token.set[i]);
                drange.add(subrange);
                if (this.ignoreCase) {
                    for(let j = 0; j < subrange.length; j++){
                        let code = subrange.index(j);
                        let otherCaseCode = this._toOtherCase(code);
                        if (code !== otherCaseCode) {
                            drange.add(otherCaseCode);
                        }
                    }
                }
            }
            if (token.not) {
                return this.defaultRange.clone().subtract(drange);
            } else {
                return this.defaultRange.clone().intersect(drange);
            }
        }
    }
    /**
   * Randomly generates and returns a number between a and b (inclusive).
   *
   * @param {Number} a
   * @param {Number} b
   * @return {Number}
   */ randInt(a, b) {
        return a + Math.floor(Math.random() * (1 + b - a));
    }
    /**
   * Default range of characters to generate from.
   */ get defaultRange() {
        return this._range = this._range || new DRange(32, 126);
    }
    set defaultRange(range) {
        this._range = range;
    }
    /**
   *
   * Enables use of randexp with a shorter call.
   *
   * @param {RegExp|String| regexp}
   * @param {String} m
   * @return {String}
   */ static randexp(regexp, m) {
        var randexp;
        if (typeof regexp === 'string') {
            regexp = new RegExp(regexp, m);
        }
        if (regexp._randexp === undefined) {
            randexp = new RandExp(regexp, m);
            regexp._randexp = randexp;
        } else {
            randexp = regexp._randexp;
            randexp._setDefaults(regexp);
        }
        return randexp.gen();
    }
    /**
   * Enables sugary /regexp/.gen syntax.
   */ static sugar() {
        /* eshint freeze:false */ RegExp.prototype.gen = function() {
            return RandExp.randexp(this);
        };
    }
};
}),
"[project]/node_modules/fast-json-patch/module/helpers.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2022 Joachim Wester
 * MIT licensed
 */ __turbopack_context__.s([
    "PatchError",
    ()=>PatchError,
    "_deepClone",
    ()=>_deepClone,
    "_getPathRecursive",
    ()=>_getPathRecursive,
    "_objectKeys",
    ()=>_objectKeys,
    "escapePathComponent",
    ()=>escapePathComponent,
    "getPath",
    ()=>getPath,
    "hasOwnProperty",
    ()=>hasOwnProperty,
    "hasUndefined",
    ()=>hasUndefined,
    "isInteger",
    ()=>isInteger,
    "unescapePathComponent",
    ()=>unescapePathComponent
]);
var __extends = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key) {
    return _hasOwnProperty.call(obj, key);
}
function _objectKeys(obj) {
    if (Array.isArray(obj)) {
        var keys_1 = new Array(obj.length);
        for(var k = 0; k < keys_1.length; k++){
            keys_1[k] = "" + k;
        }
        return keys_1;
    }
    if (Object.keys) {
        return Object.keys(obj);
    }
    var keys = [];
    for(var i in obj){
        if (hasOwnProperty(obj, i)) {
            keys.push(i);
        }
    }
    return keys;
}
;
function _deepClone(obj) {
    switch(typeof obj){
        case "object":
            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5
        case "undefined":
            return null; //this is how JSON.stringify behaves for array items
        default:
            return obj; //no need to clone primitives
    }
}
function isInteger(str) {
    var i = 0;
    var len = str.length;
    var charCode;
    while(i < len){
        charCode = str.charCodeAt(i);
        if (charCode >= 48 && charCode <= 57) {
            i++;
            continue;
        }
        return false;
    }
    return true;
}
function escapePathComponent(path) {
    if (path.indexOf('/') === -1 && path.indexOf('~') === -1) return path;
    return path.replace(/~/g, '~0').replace(/\//g, '~1');
}
function unescapePathComponent(path) {
    return path.replace(/~1/g, '/').replace(/~0/g, '~');
}
function _getPathRecursive(root, obj) {
    var found;
    for(var key in root){
        if (hasOwnProperty(root, key)) {
            if (root[key] === obj) {
                return escapePathComponent(key) + '/';
            } else if (typeof root[key] === 'object') {
                found = _getPathRecursive(root[key], obj);
                if (found != '') {
                    return escapePathComponent(key) + '/' + found;
                }
            }
        }
    }
    return '';
}
function getPath(root, obj) {
    if (root === obj) {
        return '/';
    }
    var path = _getPathRecursive(root, obj);
    if (path === '') {
        throw new Error("Object not found in root");
    }
    return "/" + path;
}
function hasUndefined(obj) {
    if (obj === undefined) {
        return true;
    }
    if (obj) {
        if (Array.isArray(obj)) {
            for(var i_1 = 0, len = obj.length; i_1 < len; i_1++){
                if (hasUndefined(obj[i_1])) {
                    return true;
                }
            }
        } else if (typeof obj === "object") {
            var objKeys = _objectKeys(obj);
            var objKeysLength = objKeys.length;
            for(var i = 0; i < objKeysLength; i++){
                if (hasUndefined(obj[objKeys[i]])) {
                    return true;
                }
            }
        }
    }
    return false;
}
function patchErrorMessageFormatter(message, args) {
    var messageParts = [
        message
    ];
    for(var key in args){
        var value = typeof args[key] === 'object' ? JSON.stringify(args[key], null, 2) : args[key]; // pretty print
        if (typeof value !== 'undefined') {
            messageParts.push(key + ": " + value);
        }
    }
    return messageParts.join('\n');
}
var PatchError = function(_super) {
    __extends(PatchError, _super);
    function PatchError(message, name, index, operation, tree) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, patchErrorMessageFormatter(message, {
            name: name,
            index: index,
            operation: operation,
            tree: tree
        })) || this;
        _this.name = name;
        _this.index = index;
        _this.operation = operation;
        _this.tree = tree;
        Object.setPrototypeOf(_this, _newTarget.prototype); // restore prototype chain, see https://stackoverflow.com/a/48342359
        _this.message = patchErrorMessageFormatter(message, {
            name: name,
            index: index,
            operation: operation,
            tree: tree
        });
        return _this;
    }
    return PatchError;
}(Error);
;
}),
"[project]/node_modules/fast-json-patch/module/core.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "JsonPatchError",
    ()=>JsonPatchError,
    "_areEquals",
    ()=>_areEquals,
    "applyOperation",
    ()=>applyOperation,
    "applyPatch",
    ()=>applyPatch,
    "applyReducer",
    ()=>applyReducer,
    "deepClone",
    ()=>deepClone,
    "getValueByPointer",
    ()=>getValueByPointer,
    "validate",
    ()=>validate,
    "validator",
    ()=>validator
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/fast-json-patch/module/helpers.mjs [app-client] (ecmascript)");
;
var JsonPatchError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PatchError"];
var deepClone = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_deepClone"];
/* We use a Javascript hash to store each
 function. Each hash entry (property) uses
 the operation identifiers specified in rfc6902.
 In this way, we can map each patch operation
 to its dedicated function in efficient way.
 */ /* The operations applicable to an object */ var objOps = {
    add: function(obj, key, document) {
        obj[key] = this.value;
        return {
            newDocument: document
        };
    },
    remove: function(obj, key, document) {
        var removed = obj[key];
        delete obj[key];
        return {
            newDocument: document,
            removed: removed
        };
    },
    replace: function(obj, key, document) {
        var removed = obj[key];
        obj[key] = this.value;
        return {
            newDocument: document,
            removed: removed
        };
    },
    move: function(obj, key, document) {
        /* in case move target overwrites an existing value,
        return the removed value, this can be taxing performance-wise,
        and is potentially unneeded */ var removed = getValueByPointer(document, this.path);
        if (removed) {
            removed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_deepClone"])(removed);
        }
        var originalValue = applyOperation(document, {
            op: "remove",
            path: this.from
        }).removed;
        applyOperation(document, {
            op: "add",
            path: this.path,
            value: originalValue
        });
        return {
            newDocument: document,
            removed: removed
        };
    },
    copy: function(obj, key, document) {
        var valueToCopy = getValueByPointer(document, this.from);
        // enforce copy by value so further operations don't affect source (see issue #177)
        applyOperation(document, {
            op: "add",
            path: this.path,
            value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_deepClone"])(valueToCopy)
        });
        return {
            newDocument: document
        };
    },
    test: function(obj, key, document) {
        return {
            newDocument: document,
            test: _areEquals(obj[key], this.value)
        };
    },
    _get: function(obj, key, document) {
        this.value = obj[key];
        return {
            newDocument: document
        };
    }
};
/* The operations applicable to an array. Many are the same as for the object */ var arrOps = {
    add: function(arr, i, document) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInteger"])(i)) {
            arr.splice(i, 0, this.value);
        } else {
            arr[i] = this.value;
        }
        // this may be needed when using '-' in an array
        return {
            newDocument: document,
            index: i
        };
    },
    remove: function(arr, i, document) {
        var removedList = arr.splice(i, 1);
        return {
            newDocument: document,
            removed: removedList[0]
        };
    },
    replace: function(arr, i, document) {
        var removed = arr[i];
        arr[i] = this.value;
        return {
            newDocument: document,
            removed: removed
        };
    },
    move: objOps.move,
    copy: objOps.copy,
    test: objOps.test,
    _get: objOps._get
};
function getValueByPointer(document, pointer) {
    if (pointer == '') {
        return document;
    }
    var getOriginalDestination = {
        op: "_get",
        path: pointer
    };
    applyOperation(document, getOriginalDestination);
    return getOriginalDestination.value;
}
function applyOperation(document, operation, validateOperation, mutateDocument, banPrototypeModifications, index) {
    if (validateOperation === void 0) {
        validateOperation = false;
    }
    if (mutateDocument === void 0) {
        mutateDocument = true;
    }
    if (banPrototypeModifications === void 0) {
        banPrototypeModifications = true;
    }
    if (index === void 0) {
        index = 0;
    }
    if (validateOperation) {
        if (typeof validateOperation == 'function') {
            validateOperation(operation, 0, document, operation.path);
        } else {
            validator(operation, 0);
        }
    }
    /* ROOT OPERATIONS */ if (operation.path === "") {
        var returnValue = {
            newDocument: document
        };
        if (operation.op === 'add') {
            returnValue.newDocument = operation.value;
            return returnValue;
        } else if (operation.op === 'replace') {
            returnValue.newDocument = operation.value;
            returnValue.removed = document; //document we removed
            return returnValue;
        } else if (operation.op === 'move' || operation.op === 'copy') {
            returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field
            if (operation.op === 'move') {
                returnValue.removed = document;
            }
            return returnValue;
        } else if (operation.op === 'test') {
            returnValue.test = _areEquals(document, operation.value);
            if (returnValue.test === false) {
                throw new JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
            }
            returnValue.newDocument = document;
            return returnValue;
        } else if (operation.op === 'remove') {
            returnValue.removed = document;
            returnValue.newDocument = null;
            return returnValue;
        } else if (operation.op === '_get') {
            operation.value = document;
            return returnValue;
        } else {
            if (validateOperation) {
                throw new JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);
            } else {
                return returnValue;
            }
        }
    } else {
        if (!mutateDocument) {
            document = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_deepClone"])(document);
        }
        var path = operation.path || "";
        var keys = path.split('/');
        var obj = document;
        var t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift
        var len = keys.length;
        var existingPathFragment = undefined;
        var key = void 0;
        var validateFunction = void 0;
        if (typeof validateOperation == 'function') {
            validateFunction = validateOperation;
        } else {
            validateFunction = validator;
        }
        while(true){
            key = keys[t];
            if (key && key.indexOf('~') != -1) {
                key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unescapePathComponent"])(key);
            }
            if (banPrototypeModifications && (key == '__proto__' || key == 'prototype' && t > 0 && keys[t - 1] == 'constructor')) {
                throw new TypeError('JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README');
            }
            if (validateOperation) {
                if (existingPathFragment === undefined) {
                    if (obj[key] === undefined) {
                        existingPathFragment = keys.slice(0, t).join('/');
                    } else if (t == len - 1) {
                        existingPathFragment = operation.path;
                    }
                    if (existingPathFragment !== undefined) {
                        validateFunction(operation, 0, document, existingPathFragment);
                    }
                }
            }
            t++;
            if (Array.isArray(obj)) {
                if (key === '-') {
                    key = obj.length;
                } else {
                    if (validateOperation && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInteger"])(key)) {
                        throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index, operation, document);
                    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInteger"])(key)) {
                        key = ~~key;
                    }
                }
                if (t >= len) {
                    if (validateOperation && operation.op === "add" && key > obj.length) {
                        throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index, operation, document);
                    }
                    var returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch
                    if (returnValue.test === false) {
                        throw new JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
                    }
                    return returnValue;
                }
            } else {
                if (t >= len) {
                    var returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch
                    if (returnValue.test === false) {
                        throw new JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
                    }
                    return returnValue;
                }
            }
            obj = obj[key];
            // If we have more keys in the path, but the next value isn't a non-null object,
            // throw an OPERATION_PATH_UNRESOLVABLE error instead of iterating again.
            if (validateOperation && t < len && (!obj || typeof obj !== "object")) {
                throw new JsonPatchError('Cannot perform operation at the desired path', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);
            }
        }
    }
}
function applyPatch(document, patch, validateOperation, mutateDocument, banPrototypeModifications) {
    if (mutateDocument === void 0) {
        mutateDocument = true;
    }
    if (banPrototypeModifications === void 0) {
        banPrototypeModifications = true;
    }
    if (validateOperation) {
        if (!Array.isArray(patch)) {
            throw new JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');
        }
    }
    if (!mutateDocument) {
        document = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_deepClone"])(document);
    }
    var results = new Array(patch.length);
    for(var i = 0, length_1 = patch.length; i < length_1; i++){
        // we don't need to pass mutateDocument argument because if it was true, we already deep cloned the object, we'll just pass `true`
        results[i] = applyOperation(document, patch[i], validateOperation, true, banPrototypeModifications, i);
        document = results[i].newDocument; // in case root was replaced
    }
    results.newDocument = document;
    return results;
}
function applyReducer(document, operation, index) {
    var operationResult = applyOperation(document, operation);
    if (operationResult.test === false) {
        throw new JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
    }
    return operationResult.newDocument;
}
function validator(operation, index, document, existingPathFragment) {
    if (typeof operation !== 'object' || operation === null || Array.isArray(operation)) {
        throw new JsonPatchError('Operation is not an object', 'OPERATION_NOT_AN_OBJECT', index, operation, document);
    } else if (!objOps[operation.op]) {
        throw new JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);
    } else if (typeof operation.path !== 'string') {
        throw new JsonPatchError('Operation `path` property is not a string', 'OPERATION_PATH_INVALID', index, operation, document);
    } else if (operation.path.indexOf('/') !== 0 && operation.path.length > 0) {
        // paths that aren't empty string should start with "/"
        throw new JsonPatchError('Operation `path` property must start with "/"', 'OPERATION_PATH_INVALID', index, operation, document);
    } else if ((operation.op === 'move' || operation.op === 'copy') && typeof operation.from !== 'string') {
        throw new JsonPatchError('Operation `from` property is not present (applicable in `move` and `copy` operations)', 'OPERATION_FROM_REQUIRED', index, operation, document);
    } else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && operation.value === undefined) {
        throw new JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_REQUIRED', index, operation, document);
    } else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasUndefined"])(operation.value)) {
        throw new JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED', index, operation, document);
    } else if (document) {
        if (operation.op == "add") {
            var pathLen = operation.path.split("/").length;
            var existingPathLen = existingPathFragment.split("/").length;
            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
                throw new JsonPatchError('Cannot perform an `add` operation at the desired path', 'OPERATION_PATH_CANNOT_ADD', index, operation, document);
            }
        } else if (operation.op === 'replace' || operation.op === 'remove' || operation.op === '_get') {
            if (operation.path !== existingPathFragment) {
                throw new JsonPatchError('Cannot perform the operation at a path that does not exist', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);
            }
        } else if (operation.op === 'move' || operation.op === 'copy') {
            var existingValue = {
                op: "_get",
                path: operation.from,
                value: undefined
            };
            var error = validate([
                existingValue
            ], document);
            if (error && error.name === 'OPERATION_PATH_UNRESOLVABLE') {
                throw new JsonPatchError('Cannot perform the operation from a path that does not exist', 'OPERATION_FROM_UNRESOLVABLE', index, operation, document);
            }
        }
    }
}
function validate(sequence, document, externalValidator) {
    try {
        if (!Array.isArray(sequence)) {
            throw new JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');
        }
        if (document) {
            //clone document and sequence so that we can safely try applying operations
            applyPatch((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_deepClone"])(document), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_deepClone"])(sequence), externalValidator || true);
        } else {
            externalValidator = externalValidator || validator;
            for(var i = 0; i < sequence.length; i++){
                externalValidator(sequence[i], i, document, undefined);
            }
        }
    } catch (e) {
        if (e instanceof JsonPatchError) {
            return e;
        } else {
            throw e;
        }
    }
}
function _areEquals(a, b) {
    if (a === b) return true;
    if (a && b && typeof a == 'object' && typeof b == 'object') {
        var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;
        if (arrA && arrB) {
            length = a.length;
            if (length != b.length) return false;
            for(i = length; i-- !== 0;)if (!_areEquals(a[i], b[i])) return false;
            return true;
        }
        if (arrA != arrB) return false;
        var keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for(i = length; i-- !== 0;)if (!b.hasOwnProperty(keys[i])) return false;
        for(i = length; i-- !== 0;){
            key = keys[i];
            if (!_areEquals(a[key], b[key])) return false;
        }
        return true;
    }
    return a !== a && b !== b;
}
;
}),
"[project]/node_modules/fast-json-patch/module/duplex.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2021 Joachim Wester
 * MIT license
 */ __turbopack_context__.s([
    "compare",
    ()=>compare,
    "generate",
    ()=>generate,
    "observe",
    ()=>observe,
    "unobserve",
    ()=>unobserve
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/fast-json-patch/module/helpers.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/fast-json-patch/module/core.mjs [app-client] (ecmascript)");
;
;
var beforeDict = new WeakMap();
var Mirror = function() {
    function Mirror(obj) {
        this.observers = new Map();
        this.obj = obj;
    }
    return Mirror;
}();
var ObserverInfo = function() {
    function ObserverInfo(callback, observer) {
        this.callback = callback;
        this.observer = observer;
    }
    return ObserverInfo;
}();
function getMirror(obj) {
    return beforeDict.get(obj);
}
function getObserverFromMirror(mirror, callback) {
    return mirror.observers.get(callback);
}
function removeObserverFromMirror(mirror, observer) {
    mirror.observers.delete(observer.callback);
}
function unobserve(root, observer) {
    observer.unobserve();
}
function observe(obj, callback) {
    var patches = [];
    var observer;
    var mirror = getMirror(obj);
    if (!mirror) {
        mirror = new Mirror(obj);
        beforeDict.set(obj, mirror);
    } else {
        var observerInfo = getObserverFromMirror(mirror, callback);
        observer = observerInfo && observerInfo.observer;
    }
    if (observer) {
        return observer;
    }
    observer = {};
    mirror.value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_deepClone"])(obj);
    if (callback) {
        observer.callback = callback;
        observer.next = null;
        var dirtyCheck = function() {
            generate(observer);
        };
        var fastCheck = function() {
            clearTimeout(observer.next);
            observer.next = setTimeout(dirtyCheck);
        };
        if (typeof window !== 'undefined') {
            window.addEventListener('mouseup', fastCheck);
            window.addEventListener('keyup', fastCheck);
            window.addEventListener('mousedown', fastCheck);
            window.addEventListener('keydown', fastCheck);
            window.addEventListener('change', fastCheck);
        }
    }
    observer.patches = patches;
    observer.object = obj;
    observer.unobserve = function() {
        generate(observer);
        clearTimeout(observer.next);
        removeObserverFromMirror(mirror, observer);
        if (typeof window !== 'undefined') {
            window.removeEventListener('mouseup', fastCheck);
            window.removeEventListener('keyup', fastCheck);
            window.removeEventListener('mousedown', fastCheck);
            window.removeEventListener('keydown', fastCheck);
            window.removeEventListener('change', fastCheck);
        }
    };
    mirror.observers.set(callback, new ObserverInfo(callback, observer));
    return observer;
}
function generate(observer, invertible) {
    if (invertible === void 0) {
        invertible = false;
    }
    var mirror = beforeDict.get(observer.object);
    _generate(mirror.value, observer.object, observer.patches, "", invertible);
    if (observer.patches.length) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyPatch"])(mirror.value, observer.patches);
    }
    var temp = observer.patches;
    if (temp.length > 0) {
        observer.patches = [];
        if (observer.callback) {
            observer.callback(temp);
        }
    }
    return temp;
}
// Dirty check if obj is different from mirror, generate patches and update mirror
function _generate(mirror, obj, patches, path, invertible) {
    if (obj === mirror) {
        return;
    }
    if (typeof obj.toJSON === "function") {
        obj = obj.toJSON();
    }
    var newKeys = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_objectKeys"])(obj);
    var oldKeys = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_objectKeys"])(mirror);
    var changed = false;
    var deleted = false;
    //if ever "move" operation is implemented here, make sure this test runs OK: "should not generate the same patch twice (move)"
    for(var t = oldKeys.length - 1; t >= 0; t--){
        var key = oldKeys[t];
        var oldVal = mirror[key];
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(obj, key) && !(obj[key] === undefined && oldVal !== undefined && Array.isArray(obj) === false)) {
            var newVal = obj[key];
            if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null && Array.isArray(oldVal) === Array.isArray(newVal)) {
                _generate(oldVal, newVal, patches, path + "/" + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["escapePathComponent"])(key), invertible);
            } else {
                if (oldVal !== newVal) {
                    changed = true;
                    if (invertible) {
                        patches.push({
                            op: "test",
                            path: path + "/" + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["escapePathComponent"])(key),
                            value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_deepClone"])(oldVal)
                        });
                    }
                    patches.push({
                        op: "replace",
                        path: path + "/" + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["escapePathComponent"])(key),
                        value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_deepClone"])(newVal)
                    });
                }
            }
        } else if (Array.isArray(mirror) === Array.isArray(obj)) {
            if (invertible) {
                patches.push({
                    op: "test",
                    path: path + "/" + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["escapePathComponent"])(key),
                    value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_deepClone"])(oldVal)
                });
            }
            patches.push({
                op: "remove",
                path: path + "/" + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["escapePathComponent"])(key)
            });
            deleted = true; // property has been deleted
        } else {
            if (invertible) {
                patches.push({
                    op: "test",
                    path: path,
                    value: mirror
                });
            }
            patches.push({
                op: "replace",
                path: path,
                value: obj
            });
            changed = true;
        }
    }
    if (!deleted && newKeys.length == oldKeys.length) {
        return;
    }
    for(var t = 0; t < newKeys.length; t++){
        var key = newKeys[t];
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(mirror, key) && obj[key] !== undefined) {
            patches.push({
                op: "add",
                path: path + "/" + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["escapePathComponent"])(key),
                value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_deepClone"])(obj[key])
            });
        }
    }
}
function compare(tree1, tree2, invertible) {
    if (invertible === void 0) {
        invertible = false;
    }
    var patches = [];
    _generate(tree1, tree2, patches, '', invertible);
    return patches;
}
}),
"[project]/node_modules/fast-json-patch/index.mjs [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/fast-json-patch/module/core.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$duplex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/fast-json-patch/module/duplex.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/fast-json-patch/module/helpers.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
const __TURBOPACK__default__export__ = Object.assign({}, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$duplex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__, {
    JsonPatchError: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PatchError"],
    deepClone: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_deepClone"],
    escapePathComponent: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["escapePathComponent"],
    unescapePathComponent: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$json$2d$patch$2f$module$2f$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unescapePathComponent"]
});
}),
"[project]/node_modules/deepmerge/dist/cjs.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var isMergeableObject = function isMergeableObject(value) {
    return isNonNullObject(value) && !isSpecial(value);
};
function isNonNullObject(value) {
    return !!value && typeof value === 'object';
}
function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);
}
// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;
function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
}
function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
}
function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
    });
}
function getMergeFunction(key, options) {
    if (!options.customMerge) {
        return deepmerge;
    }
    var customMerge = options.customMerge(key);
    return typeof customMerge === 'function' ? customMerge : deepmerge;
}
function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
    }) : [];
}
function getKeys(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
}
function propertyIsOnObject(object, property) {
    try {
        return property in object;
    } catch (_) {
        return false;
    }
}
// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target, key) {
    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
     && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
     && Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
    ;
}
function mergeObject(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
            destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
    }
    getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
            return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
            destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
            destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
    });
    return destination;
}
function deepmerge(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
    // implementations can use it. The caller may not replace it.
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
    } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
    } else {
        return mergeObject(target, source, options);
    }
}
deepmerge.all = function deepmergeAll(array, options) {
    if (!Array.isArray(array)) {
        throw new Error('first argument should be an array');
    }
    return array.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
    }, {});
};
var deepmerge_1 = deepmerge;
module.exports = deepmerge_1;
}),
"[project]/node_modules/process/browser.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function() {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}
function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len){
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for(var i = 1; i < arguments.length; i++){
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error('process.binding is not supported');
};
process.cwd = function() {
    return '/';
};
process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() {
    return 0;
};
}),
"[project]/node_modules/ramda-adjunct/es/stubUndefined.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$always$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__always$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/always.js [app-client] (ecmascript) <export default as always>");
;
/**
 * A function that returns `undefined`.
 *
 * @func stubUndefined
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.0.0|v1.0.0}
 * @category Function
 * @sig ... -> undefined
 * @return {undefined}
 * @example
 *
 * RA.stubUndefined(); //=> undefined
 * RA.stubUndefined(1, 2, 3); //=> undefined
 */ var stubUndefined = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$always$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__always$3e$__["always"])(void 0); // eslint-disable-line no-void
const __TURBOPACK__default__export__ = stubUndefined;
}),
"[project]/node_modules/ramda-adjunct/es/isUndefined.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__equals$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/equals.js [app-client] (ecmascript) <export default as equals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$stubUndefined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/stubUndefined.js [app-client] (ecmascript)");
;
;
/**
 * Checks if input value is `undefined`.
 *
 * @func isUndefined
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.0.1|v0.0.1}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotUndefined|isNotUndefined}
 * @example
 *
 * RA.isUndefined(1); //=> false
 * RA.isUndefined(undefined); //=> true
 * RA.isUndefined(null); //=> false
 */ var isUndefined = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__equals$3e$__["equals"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$stubUndefined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])());
const __TURBOPACK__default__export__ = isUndefined;
}),
"[project]/node_modules/ramda-adjunct/es/isUndefined.js [app-client] (ecmascript) <export default as isUndefined>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isUndefined",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isUndefined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isUndefined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/isUndefined.js [app-client] (ecmascript)");
}),
"[project]/node_modules/ramda-adjunct/es/isGeneratorFunction.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__type$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/type.js [app-client] (ecmascript) <export default as type>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$identical$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__identical$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/identical.js [app-client] (ecmascript) <export default as identical>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$pipe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pipe$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/pipe.js [app-client] (ecmascript) <export default as pipe>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$curryN$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__curryN$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/curryN.js [app-client] (ecmascript) <export default as curryN>");
;
/**
 * Checks if input value is `Generator Function`.
 *
 * @func isGeneratorFunction
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isFunction|isFunction}, {@link RA.isAsyncFunction|isAsyncFunction}, {@link RA.isNotGeneratorFunction|isNotGeneratorFunction}
 * @example
 *
 * RA.isGeneratorFunction(function* test() { }); //=> true
 * RA.isGeneratorFunction(null); //=> false
 * RA.isGeneratorFunction(function test() { }); //=> false
 * RA.isGeneratorFunction(() => {}); //=> false
 */ var isGeneratorFunction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$curryN$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__curryN$3e$__["curryN"])(1, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$pipe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pipe$3e$__["pipe"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__type$3e$__["type"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$identical$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__identical$3e$__["identical"])('GeneratorFunction')));
const __TURBOPACK__default__export__ = isGeneratorFunction;
}),
"[project]/node_modules/ramda-adjunct/es/isAsyncFunction.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$pipe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pipe$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/pipe.js [app-client] (ecmascript) <export default as pipe>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__type$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/type.js [app-client] (ecmascript) <export default as type>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$identical$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__identical$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/identical.js [app-client] (ecmascript) <export default as identical>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$curryN$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__curryN$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/curryN.js [app-client] (ecmascript) <export default as curryN>");
;
/**
 * Checks if input value is `Async Function`.
 *
 * @func isAsyncFunction
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isFunction|isFunction}, {@link RA.isNotAsyncFunction|isNotAsyncFunction}, {@link RA.isGeneratorFunction|isGeneratorFunction}
 * @example
 *
 * RA.isAsyncFunction(async function test() { }); //=> true
 * RA.isAsyncFunction(null); //=> false
 * RA.isAsyncFunction(function test() { }); //=> false
 * RA.isAsyncFunction(() => {}); //=> false
 */ var isAsyncFunction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$curryN$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__curryN$3e$__["curryN"])(1, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$pipe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pipe$3e$__["pipe"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__type$3e$__["type"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$identical$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__identical$3e$__["identical"])('AsyncFunction')));
const __TURBOPACK__default__export__ = isAsyncFunction;
}),
"[project]/node_modules/ramda-adjunct/es/isFunction.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$anyPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__anyPass$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/anyPass.js [app-client] (ecmascript) <export default as anyPass>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__type$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/type.js [app-client] (ecmascript) <export default as type>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$pipe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pipe$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/pipe.js [app-client] (ecmascript) <export default as pipe>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$identical$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__identical$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/identical.js [app-client] (ecmascript) <export default as identical>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isGeneratorFunction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/isGeneratorFunction.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isAsyncFunction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/isAsyncFunction.js [app-client] (ecmascript)");
;
;
;
/**
 * Checks if input value is `Function`.
 *
 * @func isFunction
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotFunction|isNotFunction}, {@link RA.isAsyncFunction|isNotAsyncFunction}, {@link RA.isGeneratorFunction|isGeneratorFunction}
 * @example
 *
 * RA.isFunction(function test() { }); //=> true
 * RA.isFunction(function* test() { }); //=> true
 * RA.isFunction(async function test() { }); //=> true
 * RA.isFunction(() => {}); //=> true
 * RA.isFunction(null); //=> false
 * RA.isFunction('abc'); //=> false
 */ var isFunction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$anyPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__anyPass$3e$__["anyPass"])([
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$pipe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pipe$3e$__["pipe"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__type$3e$__["type"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$identical$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__identical$3e$__["identical"])('Function')),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isGeneratorFunction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isAsyncFunction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
const __TURBOPACK__default__export__ = isFunction;
}),
"[project]/node_modules/ramda-adjunct/es/isRegExp.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__type$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/type.js [app-client] (ecmascript) <export default as type>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$identical$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__identical$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/identical.js [app-client] (ecmascript) <export default as identical>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$pipe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pipe$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/pipe.js [app-client] (ecmascript) <export default as pipe>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$curryN$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__curryN$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/curryN.js [app-client] (ecmascript) <export default as curryN>");
;
/**
 * Checks if value is `RegExp` object.
 *
 * @func isRegExp
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.5.0|v2.5.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotRegExp|isNotRegExp}
 * @example
 *
 * RA.isRegExp(new RegExp()); //=> true
 * RA.isRegExp(/(?:)/); //=> true
 * RA.isRegExp(1); //=> false
 */ var isRegExp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$curryN$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__curryN$3e$__["curryN"])(1, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$pipe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pipe$3e$__["pipe"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__type$3e$__["type"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$identical$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__identical$3e$__["identical"])('RegExp')));
const __TURBOPACK__default__export__ = isRegExp;
}),
"[project]/node_modules/ramda-adjunct/es/isString.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$curryN$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__curryN$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/curryN.js [app-client] (ecmascript) <export default as curryN>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$pipe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pipe$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/pipe.js [app-client] (ecmascript) <export default as pipe>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__type$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/type.js [app-client] (ecmascript) <export default as type>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$identical$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__identical$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/identical.js [app-client] (ecmascript) <export default as identical>");
;
/**
 * Checks if input value is `String`.
 *
 * @func isString
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.4.0|v0.4.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotString|isNotString}
 * @example
 *
 * RA.isString('abc'); //=> true
 * RA.isString(1); //=> false
 */ var isString = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$curryN$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__curryN$3e$__["curryN"])(1, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$pipe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pipe$3e$__["pipe"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__type$3e$__["type"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$identical$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__identical$3e$__["identical"])('String')));
const __TURBOPACK__default__export__ = isString;
}),
"[project]/node_modules/ramda-adjunct/es/escapeRegExp.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$when$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__when$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/when.js [app-client] (ecmascript) <export default as when>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$replace$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__replace$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/replace.js [app-client] (ecmascript) <export default as replace>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isString$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/isString.js [app-client] (ecmascript)");
;
;
/**
 * Escapes the RegExp special characters.
 *
 * @func escapeRegExp
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.21.0|v2.21.0}
 * @category String
 * @sig String -> String
 * @param {string} val the value to escape
 * @return {string}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping|MDN Regular Expressions Escaping}
 * @example
 *
 * RA.escapeRegExp('[ramda-adjunct](https://github.com/char0n/ramda-adjunct)'); //=> '\[ramda\-adjunct\]\(https://github\.com/char0n/ramda\-adjunct\)'
 */ var escapeRegExp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$when$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__when$3e$__["when"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isString$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$replace$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__replace$3e$__["replace"])(/[.*+?^${}()|[\]\\-]/g, '\\$&'));
const __TURBOPACK__default__export__ = escapeRegExp;
}),
"[project]/node_modules/ramda-adjunct/es/internal/ponyfills/String.replaceAll.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$replace$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__replace$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/replace.js [app-client] (ecmascript) <export default as replace>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isRegExp$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/isRegExp.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$escapeRegExp$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/escapeRegExp.js [app-client] (ecmascript)");
;
;
;
var checkArguments = function checkArguments(searchValue, replaceValue, str) {
    if (str == null || searchValue == null || replaceValue == null) {
        throw TypeError('Input values must not be `null` or `undefined`');
    }
};
var checkValue = function checkValue(value, valueName) {
    if (typeof value !== 'string') {
        if (!(value instanceof String)) {
            throw TypeError("`".concat(valueName, "` must be a string"));
        }
    }
};
var checkSearchValue = function checkSearchValue(searchValue) {
    if (typeof searchValue !== 'string' && !(searchValue instanceof String) && !(searchValue instanceof RegExp)) {
        throw TypeError('`searchValue` must be a string or an regexp');
    }
};
var replaceAll = function replaceAll(searchValue, replaceValue, str) {
    checkArguments(searchValue, replaceValue, str);
    checkValue(str, 'str');
    checkValue(replaceValue, 'replaceValue');
    checkSearchValue(searchValue);
    var regexp = new RegExp((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isRegExp$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(searchValue) ? searchValue : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$escapeRegExp$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(searchValue), 'g');
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$replace$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__replace$3e$__["replace"])(regexp, replaceValue, str);
};
const __TURBOPACK__default__export__ = replaceAll;
}),
"[project]/node_modules/ramda-adjunct/es/replaceAll.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__,
    "replaceAllInvoker",
    ()=>replaceAllInvoker,
    "replaceAllPonyfill",
    ()=>replaceAllPonyfill
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$curryN$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__curryN$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/curryN.js [app-client] (ecmascript) <export default as curryN>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$invoker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__invoker$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/invoker.js [app-client] (ecmascript) <export default as invoker>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isFunction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/isFunction.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$internal$2f$ponyfills$2f$String$2e$replaceAll$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/internal/ponyfills/String.replaceAll.js [app-client] (ecmascript)");
;
;
;
var replaceAllPonyfill = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$curryN$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__curryN$3e$__["curryN"])(3, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$internal$2f$ponyfills$2f$String$2e$replaceAll$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
var replaceAllInvoker = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$invoker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__invoker$3e$__["invoker"])(2, 'replaceAll');
/**
 * Replaces all substring matches in a string with a replacement.
 *
 * @func replaceAll
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.17.0|v2.17.0}
 * @category String
 * @sig String -> String -> String -> String
 * @param {string} searchValue The substring or a global RegExp to match
 * @param {string} replaceValue The string to replace the matches with
 * @param {string} str The String to do the search and replacement in
 * @return {string} A new string containing all the `searchValue` replaced with the `replaceValue`
 * @throws {TypeError} When invalid arguments provided
 * @see {@link http://ramdajs.com/docs/#replace|R.replace}, {@link https://github.com/tc39/proposal-string-replaceall|TC39 proposal}
 * @example
 *
 * RA.replaceAll('ac', 'ef', 'ac ab ac ab'); //=> 'ef ab ef ab'
 * RA.replaceAll('', '_', 'xxx'); //=> '_x_x_x_'
 * RA.replaceAll(/x/g, 'v', 'xxx'); //=> 'vvv'
 * RA.replaceAll(/x/, 'v', 'xxx'); //=> TypeError
 */ var replaceAll = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isFunction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(String.prototype.replaceAll) ? replaceAllInvoker : replaceAllPonyfill;
const __TURBOPACK__default__export__ = replaceAll;
}),
"[project]/node_modules/ramda-adjunct/es/replaceAll.js [app-client] (ecmascript) <export default as replaceAll>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "replaceAll",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$replaceAll$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$replaceAll$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/replaceAll.js [app-client] (ecmascript)");
}),
"[project]/node_modules/ramda-adjunct/es/isNotUndefined.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$complement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__complement$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/complement.js [app-client] (ecmascript) <export default as complement>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isUndefined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/isUndefined.js [app-client] (ecmascript)");
;
;
/**
 * Checks if input value is complement `undefined`.
 *
 * @func isNotUndefined
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.0.1|v0.0.1}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isUndefined|isUndefined}
 * @example
 *
 * RA.isNotUndefined(1); //=> true
 * RA.isNotUndefined(undefined); //=> false
 * RA.isNotUndefined(null); //=> true
 */ var isNotUndefined = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$complement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__complement$3e$__["complement"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isUndefined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = isNotUndefined;
}),
"[project]/node_modules/ramda-adjunct/es/isNotUndefined.js [app-client] (ecmascript) <export default as isNotUndefined>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isNotUndefined",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isNotUndefined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isNotUndefined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/isNotUndefined.js [app-client] (ecmascript)");
}),
"[project]/node_modules/ramda-adjunct/es/included.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$flip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__flip$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/flip.js [app-client] (ecmascript) <export default as flip>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$includes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__includes$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/includes.js [app-client] (ecmascript) <export default as includes>");
;
/**
 * Returns true if the specified value is equal, in R.equals terms,
 * to at least one element of the given list or false otherwise.
 * Given list can be a string.
 *
 * Like {@link http://ramdajs.com/docs/#includes|R.includes} but with argument order reversed.
 *
 * @func included
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/3.0.0|v3.0.0}
 * @category List
 * @sig [a] -> a -> Boolean
 * @param {Array|String} list The list to consider
 * @param {*} a The item to compare against
 * @return {boolean} Returns Boolean `true` if an equivalent item is in the list or `false` otherwise
 * @see {@link http://ramdajs.com/docs/#includes|R.includes}
 * @example
 *
 * RA.included([1, 2, 3], 3); //=> true
 * RA.included([1, 2, 3], 4); //=> false
 * RA.included([{ name: 'Fred' }], { name: 'Fred' }); //=> true
 * RA.included([[42]], [42]); //=> true
 */ var included = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$flip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__flip$3e$__["flip"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$includes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__includes$3e$__["includes"]);
const __TURBOPACK__default__export__ = included;
}),
"[project]/node_modules/ramda-adjunct/es/trimCharsEnd.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$curry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__curry$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/curry.js [app-client] (ecmascript) <export default as curry>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$dropLastWhile$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__dropLastWhile$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/dropLastWhile.js [app-client] (ecmascript) <export default as dropLastWhile>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$join$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__join$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/join.js [app-client] (ecmascript) <export default as join>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$pipe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pipe$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/pipe.js [app-client] (ecmascript) <export default as pipe>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$split$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__split$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/split.js [app-client] (ecmascript) <export default as split>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$included$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/included.js [app-client] (ecmascript)");
;
;
/**
 * Removes specified characters from the end of a string.
 *
 * @func trimCharsEnd
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.25.0|v2.25.0}
 * @category String
 * @sig String -> String
 * @param {string} chars The characters to trim
 * @param {string} value The string to trim
 * @return {string} Returns the trimmed string.
 * @example
 *
 * RA.trimCharsEnd('_-', '-_-abc-_-'); //=> '-_-abc'
 */ var trimCharsEnd = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$curry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__curry$3e$__["curry"])(function(chars, value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$pipe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pipe$3e$__["pipe"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$split$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__split$3e$__["split"])(''), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$dropLastWhile$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__dropLastWhile$3e$__["dropLastWhile"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$included$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(chars)), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$join$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__join$3e$__["join"])(''))(value);
});
const __TURBOPACK__default__export__ = trimCharsEnd;
}),
"[project]/node_modules/ramda-adjunct/es/trimCharsEnd.js [app-client] (ecmascript) <export default as trimCharsEnd>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "trimCharsEnd",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$trimCharsEnd$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$trimCharsEnd$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/trimCharsEnd.js [app-client] (ecmascript)");
}),
"[project]/node_modules/ramda-adjunct/es/isNull.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__equals$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/equals.js [app-client] (ecmascript) <export default as equals>");
;
/**
 * Checks if input value is `null`.
 *
 * @func isNull
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.1.0|v0.1.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotNull|isNotNull}
 * @example
 *
 * RA.isNull(1); //=> false
 * RA.isNull(undefined); //=> false
 * RA.isNull(null); //=> true
 */ var isNull = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__equals$3e$__["equals"])(null);
const __TURBOPACK__default__export__ = isNull;
}),
"[project]/node_modules/ramda-adjunct/es/isNotNull.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$complement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__complement$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/complement.js [app-client] (ecmascript) <export default as complement>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isNull$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/isNull.js [app-client] (ecmascript)");
;
;
/**
 * Checks if input value is complement of `null`.
 *
 * @func isNotNull
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.1.0|v0.1.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNull|isNull}
 * @example
 *
 * RA.isNotNull(1); //=> true
 * RA.isNotNull(undefined); //=> true
 * RA.isNotNull(null); //=> false
 */ var isNotNull = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$complement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__complement$3e$__["complement"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isNull$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = isNotNull;
}),
"[project]/node_modules/ramda-adjunct/es/internal/isOfTypeObject.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
var isOfTypeObject = function isOfTypeObject(val) {
    return _typeof(val) === 'object';
};
const __TURBOPACK__default__export__ = isOfTypeObject;
}),
"[project]/node_modules/ramda-adjunct/es/isObjLike.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$both$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__both$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/both.js [app-client] (ecmascript) <export default as both>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$curryN$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__curryN$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/curryN.js [app-client] (ecmascript) <export default as curryN>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isNotNull$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/isNotNull.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$internal$2f$isOfTypeObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/internal/isOfTypeObject.js [app-client] (ecmascript)");
;
;
;
/* eslint-disable max-len */ /**
 * Checks if value is object-like. A value is object-like if it's not null and has a typeof result of "object".
 *
 * @func isObjLike
 * @aliases isObjectLike
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotObjLike|isNotObjLike}, {@link RA.isObj|isObj}, {@link RA.isPlainObj|isPlainObj}
 * @example
 *
 * RA.isObjLike({}); //=> true
 * RA.isObjLike([]); //=> true
 * RA.isObjLike(() => {}); //=> false
 * RA.isObjLike(null); //=> false
 * RA.isObjLike(undefined); //=> false
 */ /* eslint-enable max-len */ var isObjLike = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$curryN$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__curryN$3e$__["curryN"])(1, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$both$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__both$3e$__["both"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isNotNull$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$internal$2f$isOfTypeObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]));
const __TURBOPACK__default__export__ = isObjLike;
}),
"[project]/node_modules/ramda-adjunct/es/isPlainObj.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$pipe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pipe$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/pipe.js [app-client] (ecmascript) <export default as pipe>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__type$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/type.js [app-client] (ecmascript) <export default as type>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$identical$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__identical$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/identical.js [app-client] (ecmascript) <export default as identical>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$both$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__both$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/both.js [app-client] (ecmascript) <export default as both>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__equals$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/equals.js [app-client] (ecmascript) <export default as equals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$toString$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__toString$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/toString.js [app-client] (ecmascript) <export default as toString>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$pathSatisfies$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pathSatisfies$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/pathSatisfies.js [app-client] (ecmascript) <export default as pathSatisfies>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$curryN$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__curryN$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/curryN.js [app-client] (ecmascript) <export default as curryN>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isNull$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/isNull.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isObjLike$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/isObjLike.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isFunction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/isFunction.js [app-client] (ecmascript)");
;
;
;
;
var isObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$pipe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pipe$3e$__["pipe"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__type$3e$__["type"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$identical$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__identical$3e$__["identical"])('Object'));
var isObjectConstructor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$pipe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pipe$3e$__["pipe"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$toString$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__toString$3e$__["toString"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__equals$3e$__["equals"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$toString$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__toString$3e$__["toString"])(Object)));
var hasObjectConstructor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$pathSatisfies$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pathSatisfies$3e$__["pathSatisfies"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$both$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__both$3e$__["both"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isFunction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], isObjectConstructor), [
    'constructor'
]);
/* eslint-disable max-len */ /**
 * Check to see if an object is a plain object (created using `{}`, `new Object()` or `Object.create(null)`).
 *
 * @func isPlainObj
 * @aliases isPlainObject
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotPlainObj|isNotPlainObj}, {@link RA.isObjLike|isObjLike}, {@link RA.isObj|isObj}
 * @example
 *
 * class Bar {
 *   constructor() {
 *     this.prop = 'value';
 *   }
 * }
 *
 * RA.isPlainObj(new Bar()); //=> false
 * RA.isPlainObj({ prop: 'value' }); //=> true
 * RA.isPlainObj(['a', 'b', 'c']); //=> false
 * RA.isPlainObj(Object.create(null); //=> true
 * RA.isPlainObj(new Object()); //=> true
 */ /* eslint-enable max-len */ var isPlainObj = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$curryN$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__curryN$3e$__["curryN"])(1, function(val) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isObjLike$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(val) || !isObject(val)) {
        return false;
    }
    var proto = Object.getPrototypeOf(val);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isNull$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(proto)) {
        return true;
    }
    return hasObjectConstructor(proto);
});
const __TURBOPACK__default__export__ = isPlainObj;
}),
"[project]/node_modules/ramda-adjunct/es/isPlainObj.js [app-client] (ecmascript) <export default as isPlainObject>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isPlainObject",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isPlainObj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isPlainObj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/isPlainObj.js [app-client] (ecmascript)");
}),
"[project]/node_modules/ramda-adjunct/es/included.js [app-client] (ecmascript) <export default as included>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "included",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$included$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$included$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/included.js [app-client] (ecmascript)");
}),
"[project]/node_modules/ramda-adjunct/es/isString.js [app-client] (ecmascript) <export default as isString>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isString",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isString$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isString$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/isString.js [app-client] (ecmascript)");
}),
"[project]/node_modules/ramda-adjunct/es/trimCharsStart.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$curry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__curry$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/curry.js [app-client] (ecmascript) <export default as curry>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$dropWhile$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__dropWhile$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/dropWhile.js [app-client] (ecmascript) <export default as dropWhile>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$join$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__join$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/join.js [app-client] (ecmascript) <export default as join>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$pipe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pipe$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/pipe.js [app-client] (ecmascript) <export default as pipe>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$split$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__split$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/split.js [app-client] (ecmascript) <export default as split>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$included$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/included.js [app-client] (ecmascript)");
;
;
/**
 * Removes specified characters from the beginning of a string.
 *
 * @func trimCharsStart
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.24.0|v2.24.0}
 * @category String
 * @sig String -> String
 * @param {string} chars The characters to trim
 * @param {string} value The string to trim
 * @return {string} Returns the trimmed string.
 * @example
 *
 * RA.trimCharsStart('_-', '-_-abc-_-'); //=> 'abc-_-'
 */ var trimCharsStart = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$curry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__curry$3e$__["curry"])(function(chars, value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$pipe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pipe$3e$__["pipe"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$split$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__split$3e$__["split"])(''), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$dropWhile$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__dropWhile$3e$__["dropWhile"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$included$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(chars)), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$join$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__join$3e$__["join"])(''))(value);
});
const __TURBOPACK__default__export__ = trimCharsStart;
}),
"[project]/node_modules/ramda-adjunct/es/trimCharsStart.js [app-client] (ecmascript) <export default as trimCharsStart>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "trimCharsStart",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$trimCharsStart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$trimCharsStart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/trimCharsStart.js [app-client] (ecmascript)");
}),
"[project]/node_modules/ramda-adjunct/es/isEmptyString.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__equals$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/equals.js [app-client] (ecmascript) <export default as equals>");
;
/**
 * Checks if input value is an empty `String`.
 *
 * @func isEmptyString
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.4.0|v2.4.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotEmptyString|isNotEmptyString}
 * @example
 *
 * RA.isEmptyString(''); // => true
 * RA.isEmptyString('42'); // => false
 * RA.isEmptyString(new String('42')); // => false
 * RA.isEmptyString(new String('')); // => false
 * RA.isEmptyString([42]); // => false
 * RA.isEmptyString({}); // => false
 * RA.isEmptyString(null); // => false
 * RA.isEmptyString(undefined); // => false
 * RA.isEmptyString(42); // => false
 */ var isEmptyString = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__equals$3e$__["equals"])('');
const __TURBOPACK__default__export__ = isEmptyString;
}),
"[project]/node_modules/ramda-adjunct/es/isEmptyString.js [app-client] (ecmascript) <export default as isEmptyString>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isEmptyString",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isEmptyString$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isEmptyString$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/isEmptyString.js [app-client] (ecmascript)");
}),
"[project]/node_modules/ramda-adjunct/es/isNotFunction.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$complement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__complement$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/complement.js [app-client] (ecmascript) <export default as complement>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isFunction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/isFunction.js [app-client] (ecmascript)");
;
;
/* eslint-disable max-len */ /**
 * Checks if input value is complement of `Function`.
 *
 * @func isNotFunction
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isFunction|isFunction}, {@link RA.isAsyncFunction|isNotAsyncFunction}, {@link RA.isGeneratorFunction|isGeneratorFunction}
 * @example
 *
 * RA.isNotFunction(function test() { }); //=> false
 * RA.isNotFunction(function* test() { }); //=> false
 * RA.isNotFunction(async function test() { }); //=> false
 * RA.isNotFunction(() => {}); //=> false
 * RA.isNotFunction(null); //=> true
 * RA.isNotFunction('abc'); //=> true
 */ /* eslint-enable max-len */ var isNotFunction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$complement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__complement$3e$__["complement"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isFunction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = isNotFunction;
}),
"[project]/node_modules/ramda-adjunct/es/isArray.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$curryN$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__curryN$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/curryN.js [app-client] (ecmascript) <export default as curryN>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$pipe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pipe$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/pipe.js [app-client] (ecmascript) <export default as pipe>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__type$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/type.js [app-client] (ecmascript) <export default as type>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$identical$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__identical$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/identical.js [app-client] (ecmascript) <export default as identical>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isFunction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/isFunction.js [app-client] (ecmascript)");
;
;
/**
 * Checks if input value is `Array`.
 *
 * @func isArray
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.3.0|v0.3.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotArray|isNotArray}
 * @example
 *
 * RA.isArray([]); //=> true
 * RA.isArray(null); //=> false
 * RA.isArray({}); //=> false
 */ var isArray = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$curryN$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__curryN$3e$__["curryN"])(1, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isFunction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(Array.isArray) ? Array.isArray : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$pipe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pipe$3e$__["pipe"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__type$3e$__["type"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$identical$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__identical$3e$__["identical"])('Array')));
const __TURBOPACK__default__export__ = isArray;
}),
"[project]/node_modules/ramda-adjunct/es/isEmptyArray.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$both$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__both$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/both.js [app-client] (ecmascript) <export default as both>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$isEmpty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isEmpty$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/isEmpty.js [app-client] (ecmascript) <export default as isEmpty>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/isArray.js [app-client] (ecmascript)");
;
;
/**
 * Checks if input value is an empty `Array`.
 *
 * @func isEmptyArray
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.4.0|v2.4.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotEmptyArray|isNotEmptyArray}
 * @example
 *
 * RA.isEmptyArray([]); // => true
 * RA.isEmptyArray([42]); // => false
 * RA.isEmptyArray({}); // => false
 * RA.isEmptyArray(null); // => false
 * RA.isEmptyArray(undefined); // => false
 * RA.isEmptyArray(42); // => false
 * RA.isEmptyArray('42'); // => false
 */ var isEmptyArray = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$both$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__both$3e$__["both"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$isEmpty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isEmpty$3e$__["isEmpty"]);
const __TURBOPACK__default__export__ = isEmptyArray;
}),
"[project]/node_modules/ramda-adjunct/es/invokeArgs.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$curryN$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__curryN$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/curryN.js [app-client] (ecmascript) <export default as curryN>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$path$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__path$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/path.js [app-client] (ecmascript) <export default as path>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$apply$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__apply$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/apply.js [app-client] (ecmascript) <export default as apply>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$init$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__init$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/init.js [app-client] (ecmascript) <export default as init>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$bind$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bind$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/bind.js [app-client] (ecmascript) <export default as bind>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isNotFunction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/isNotFunction.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isEmptyArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/isEmptyArray.js [app-client] (ecmascript)");
;
;
;
/**
 * Invokes the method at path of object with given arguments.
 *
 * @func invokeArgs
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.27.0|v2.27.0}
 * @category Object
 * @sig Array -> Array -> Object -> *
 * @param {Array.<string|number>} path The path of the method to invoke
 * @param {Array} args The arguments to invoke the method with
 * @param {Object} obj The object to query
 * @return {*}
 * @example
 *
 * RA.invokeArgs(['abs'], [-1], Math); //=> 1
 * RA.invokeArgs(['path', 'to', 'non-existent', 'method'], [-1], Math); //=> undefined
 */ var invokeArgs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$curryN$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__curryN$3e$__["curryN"])(3, function(mpath, args, obj) {
    var method = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$path$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__path$3e$__["path"])(mpath, obj);
    var context = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$path$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__path$3e$__["path"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$init$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__init$3e$__["init"])(mpath), obj);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isNotFunction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(method)) return undefined;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isEmptyArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(mpath)) return undefined;
    var boundMethod = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$bind$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bind$3e$__["bind"])(method, context);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$apply$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__apply$3e$__["apply"])(boundMethod, args);
});
const __TURBOPACK__default__export__ = invokeArgs;
}),
"[project]/node_modules/ramda-adjunct/es/invokeArgs.js [app-client] (ecmascript) <export default as invokeArgs>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "invokeArgs",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$invokeArgs$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$invokeArgs$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/invokeArgs.js [app-client] (ecmascript)");
}),
"[project]/node_modules/ramda-adjunct/es/isObj.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$both$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__both$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/both.js [app-client] (ecmascript) <export default as both>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$either$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__either$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/either.js [app-client] (ecmascript) <export default as either>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$curryN$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__curryN$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/curryN.js [app-client] (ecmascript) <export default as curryN>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isNotNull$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/isNotNull.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isFunction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/isFunction.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$internal$2f$isOfTypeObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/internal/isOfTypeObject.js [app-client] (ecmascript)");
;
;
;
;
/* eslint-disable max-len */ /**
 * Checks if input value is language type of `Object`.
 *
 * @func isObj
 * @aliases isObject
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotObj|isNotObj}, {@link RA.isObjLike|isObjLike}, {@link RA.isPlainObj|isPlainObj}
 * @example
 *
 * RA.isObj({}); //=> true
 * RA.isObj([]); //=> true
 * RA.isObj(() => {}); //=> true
 * RA.isObj(null); //=> false
 * RA.isObj(undefined); //=> false
 */ /* eslint-enable max-len */ var isObj = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$curryN$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__curryN$3e$__["curryN"])(1, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$both$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__both$3e$__["both"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isNotNull$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$either$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__either$3e$__["either"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$internal$2f$isOfTypeObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isFunction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])));
const __TURBOPACK__default__export__ = isObj;
}),
"[project]/node_modules/ramda-adjunct/es/isNotObj.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$complement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__complement$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/complement.js [app-client] (ecmascript) <export default as complement>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isObj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/isObj.js [app-client] (ecmascript)");
;
;
/* eslint-disable max-len */ /**
 * Checks if input value is complement of language type of `Object`.
 *
 * @func isNotObj
 * @aliases isNotObject
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isObj|isObj}, {@link RA.isObjLike|isObjLike}, {@link RA.isPlainObj|isPlainObj}
 * @example
 *
 * RA.isNotObj({}); //=> false
 * RA.isNotObj([]); //=> false
 * RA.isNotObj(() => {}); //=> false
 * RA.isNotObj(null); //=> true
 * RA.isNotObj(undefined); //=> true
 */ /* eslint-enable max-len */ var isNotObj = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$complement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__complement$3e$__["complement"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isObj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = isNotObj;
}),
"[project]/node_modules/ramda-adjunct/es/isNonEmptyString.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$allPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__allPass$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/allPass.js [app-client] (ecmascript) <export default as allPass>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$isNotEmpty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isNotEmpty$3e$__ = __turbopack_context__.i("[project]/node_modules/ramda/es/isNotEmpty.js [app-client] (ecmascript) <export default as isNotEmpty>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isString$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/isString.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isNotObj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/isNotObj.js [app-client] (ecmascript)");
;
;
;
/**
 * Checks if input value is not an empty `String`.
 *
 * @func isNonEmptyString
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.4.0|v2.4.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isEmptyString|isEmptyString}
 * @example
 *
 * RA.isNonEmptyString('42'); // => true
 * RA.isNonEmptyString(''); // => false
 * RA.isNonEmptyString(new String('42')); // => false
 * RA.isNonEmptyString(new String('')); // => false
 * RA.isNonEmptyString([42]); // => false
 * RA.isNonEmptyString({}); // => false
 * RA.isNonEmptyString(null); // => false
 * RA.isNonEmptyString(undefined); // => false
 * RA.isNonEmptyString(42); // => false
 */ var isNonEmptyString = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$allPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__allPass$3e$__["allPass"])([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isString$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isNotObj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2f$es$2f$isNotEmpty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isNotEmpty$3e$__["isNotEmpty"]
]);
const __TURBOPACK__default__export__ = isNonEmptyString;
}),
"[project]/node_modules/ramda-adjunct/es/isNonEmptyString.js [app-client] (ecmascript) <export default as isNonEmptyString>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isNonEmptyString",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isNonEmptyString$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ramda$2d$adjunct$2f$es$2f$isNonEmptyString$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ramda-adjunct/es/isNonEmptyString.js [app-client] (ecmascript)");
}),
"[project]/node_modules/neotraverse/dist/legacy/legacy.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>src_default
]);
function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes(arr) {
    if (Array.isArray(arr)) return arr;
}
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _iterable_to_array_limit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array(arr, i) {
    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _type_of(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
var __typeError = function(msg) {
    throw TypeError(msg);
};
var __accessCheck = function(obj, member, msg) {
    return member.has(obj) || __typeError("Cannot " + msg);
};
var __privateGet = function(obj, member, getter) {
    return __accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = function(obj, member, value) {
    return member.has(obj) ? __typeError("Cannot add the same private member more than once") : _instanceof(member, WeakSet) ? member.add(obj) : member.set(obj, value);
};
var __privateSet = function(obj, member, value, setter) {
    return __accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value;
};
// src/index.ts
var to_string = function(obj) {
    return Object.prototype.toString.call(obj);
};
var is_typed_array = function(value) {
    return ArrayBuffer.isView(value) && !_instanceof(value, DataView);
};
var is_date = function(obj) {
    return to_string(obj) === "[object Date]";
};
var is_regexp = function(obj) {
    return to_string(obj) === "[object RegExp]";
};
var is_error = function(obj) {
    return to_string(obj) === "[object Error]";
};
var is_boolean = function(obj) {
    return to_string(obj) === "[object Boolean]";
};
var is_number = function(obj) {
    return to_string(obj) === "[object Number]";
};
var is_string = function(obj) {
    return to_string(obj) === "[object String]";
};
var is_array = Array.isArray;
var gopd = Object.getOwnPropertyDescriptor;
var is_property_enumerable = Object.prototype.propertyIsEnumerable;
var get_own_property_symbols = Object.getOwnPropertySymbols;
var has_own_property = Object.prototype.hasOwnProperty;
function own_enumerable_keys(obj) {
    var res = Object.keys(obj);
    var symbols = get_own_property_symbols(obj);
    for(var i = 0; i < symbols.length; i++){
        if (is_property_enumerable.call(obj, symbols[i])) {
            res.push(symbols[i]);
        }
    }
    return res;
}
function is_writable(object, key) {
    var _gopd;
    return !((_gopd = gopd(object, key)) === null || _gopd === void 0 ? void 0 : _gopd.writable);
}
function copy(src, options) {
    if ((typeof src === "undefined" ? "undefined" : _type_of(src)) === "object" && src !== null) {
        var dst;
        if (is_array(src)) {
            dst = [];
        } else if (is_date(src)) {
            dst = new Date(src.getTime ? src.getTime() : src);
        } else if (is_regexp(src)) {
            dst = new RegExp(src);
        } else if (is_error(src)) {
            dst = {
                message: src.message
            };
        } else if (is_boolean(src) || is_number(src) || is_string(src)) {
            dst = Object(src);
        } else if (is_typed_array(src)) {
            return src.slice();
        } else {
            dst = Object.create(Object.getPrototypeOf(src));
        }
        var iterator_function = options.includeSymbols ? own_enumerable_keys : Object.keys;
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = iterator_function(src)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var key = _step.value;
                dst[key] = src[key];
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return dst;
    }
    return src;
}
var empty_null = {
    includeSymbols: false,
    immutable: false
};
function walk(root, cb) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : empty_null;
    var path = [];
    var parents = [];
    var alive = true;
    var iterator_function = options.includeSymbols ? own_enumerable_keys : Object.keys;
    var immutable = !!options.immutable;
    return function walker(node_) {
        var node = immutable ? copy(node_, options) : node_;
        var modifiers = {};
        var keep_going = true;
        var state = {
            node: node,
            node_: node_,
            path: [].concat(path),
            parent: parents[parents.length - 1],
            parents: parents,
            key: path[path.length - 1],
            isRoot: path.length === 0,
            level: path.length,
            circular: void 0,
            isLeaf: false,
            notLeaf: true,
            notRoot: true,
            isFirst: false,
            isLast: false,
            update: function update(x) {
                var stopHere = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                if (!state.isRoot) {
                    state.parent.node[state.key] = x;
                }
                state.node = x;
                if (stopHere) {
                    keep_going = false;
                }
            },
            delete: function _delete(stopHere) {
                delete state.parent.node[state.key];
                if (stopHere) {
                    keep_going = false;
                }
            },
            remove: function remove(stopHere) {
                if (is_array(state.parent.node)) {
                    state.parent.node.splice(state.key, 1);
                } else {
                    delete state.parent.node[state.key];
                }
                if (stopHere) {
                    keep_going = false;
                }
            },
            keys: null,
            before: function before(f) {
                modifiers.before = f;
            },
            after: function after(f) {
                modifiers.after = f;
            },
            pre: function pre(f) {
                modifiers.pre = f;
            },
            post: function post(f) {
                modifiers.post = f;
            },
            stop: function stop() {
                alive = false;
            },
            block: function block() {
                keep_going = false;
            }
        };
        if (!alive) {
            return state;
        }
        function update_state() {
            if (_type_of(state.node) === "object" && state.node !== null) {
                if (!state.keys || state.node_ !== state.node) {
                    state.keys = iterator_function(state.node);
                }
                state.isLeaf = state.keys.length === 0;
                for(var i = 0; i < parents.length; i++){
                    if (parents[i].node_ === node_) {
                        state.circular = parents[i];
                        break;
                    }
                }
            } else {
                state.isLeaf = true;
                state.keys = null;
            }
            state.notLeaf = !state.isLeaf;
            state.notRoot = !state.isRoot;
        }
        update_state();
        var ret = cb.call(state, state.node);
        if (ret !== void 0 && state.update) {
            state.update(ret);
        }
        if (modifiers.before) {
            modifiers.before.call(state, state.node);
        }
        if (!keep_going) {
            return state;
        }
        if (_type_of(state.node) === "object" && state.node !== null && !state.circular) {
            parents.push(state);
            update_state();
            var _state_keys;
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = Object.entries((_state_keys = state.keys) !== null && _state_keys !== void 0 ? _state_keys : [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var _step_value = _sliced_to_array(_step.value, 2), index = _step_value[0], key = _step_value[1];
                    var _state_keys1;
                    path.push(key);
                    if (modifiers.pre) {
                        modifiers.pre.call(state, state.node[key], key);
                    }
                    var child = walker(state.node[key]);
                    if (immutable && has_own_property.call(state.node, key) && !is_writable(state.node, key)) {
                        state.node[key] = child.node;
                    }
                    child.isLast = ((_state_keys1 = state.keys) === null || _state_keys1 === void 0 ? void 0 : _state_keys1.length) ? +index === state.keys.length - 1 : false;
                    child.isFirst = +index === 0;
                    if (modifiers.post) {
                        modifiers.post.call(state, child);
                    }
                    path.pop();
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            parents.pop();
        }
        if (modifiers.after) {
            modifiers.after.call(state, state.node);
        }
        return state;
    }(root).node;
}
var _value, _options;
var Traverse = /*#__PURE__*/ function() {
    "use strict";
    function Traverse(obj) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : empty_null;
        _class_call_check(this, Traverse);
        // ! Have to keep these public as legacy mode requires them
        __privateAdd(this, _value);
        __privateAdd(this, _options);
        __privateSet(this, _value, obj);
        __privateSet(this, _options, options);
    }
    _create_class(Traverse, [
        {
            /**
   * Get the element at the array `path`.
   */ key: "get",
            value: function get(paths) {
                var node = __privateGet(this, _value);
                for(var i = 0; node && i < paths.length; i++){
                    var key = paths[i];
                    if (!has_own_property.call(node, key) || !__privateGet(this, _options).includeSymbols && (typeof key === "undefined" ? "undefined" : _type_of(key)) === "symbol") {
                        return void 0;
                    }
                    node = node[key];
                }
                return node;
            }
        },
        {
            /**
   * Return whether the element at the array `path` exists.
   */ key: "has",
            value: function has(paths) {
                var node = __privateGet(this, _value);
                for(var i = 0; node && i < paths.length; i++){
                    var key = paths[i];
                    if (!has_own_property.call(node, key) || !__privateGet(this, _options).includeSymbols && (typeof key === "undefined" ? "undefined" : _type_of(key)) === "symbol") {
                        return false;
                    }
                    node = node[key];
                }
                return true;
            }
        },
        {
            /**
   * Set the element at the array `path` to `value`.
   */ key: "set",
            value: function set(path, value) {
                var node = __privateGet(this, _value);
                var i = 0;
                for(i = 0; i < path.length - 1; i++){
                    var key = path[i];
                    if (!has_own_property.call(node, key)) {
                        node[key] = {};
                    }
                    node = node[key];
                }
                node[path[i]] = value;
                return value;
            }
        },
        {
            /**
   * Execute `fn` for each node in the object and return a new object with the results of the walk. To update nodes in the result use `this.update(value)`.
   */ key: "map",
            value: function map(cb) {
                return walk(__privateGet(this, _value), cb, {
                    immutable: true,
                    includeSymbols: !!__privateGet(this, _options).includeSymbols
                });
            }
        },
        {
            /**
   * Execute `fn` for each node in the object but unlike `.map()`, when `this.update()` is called it updates the object in-place.
   */ key: "forEach",
            value: function forEach(cb) {
                __privateSet(this, _value, walk(__privateGet(this, _value), cb, __privateGet(this, _options)));
                return __privateGet(this, _value);
            }
        },
        {
            /**
   * For each node in the object, perform a [left-fold](http://en.wikipedia.org/wiki/Fold_(higher-order_function)) with the return value of `fn(acc, node)`.
   *
   * If `init` isn't specified, `init` is set to the root object for the first step and the root element is skipped.
   */ key: "reduce",
            value: function reduce(cb, init) {
                var skip = arguments.length === 1;
                var acc = skip ? __privateGet(this, _value) : init;
                this.forEach(function(x) {
                    if (!this.isRoot || !skip) {
                        acc = cb.call(this, acc, x);
                    }
                });
                return acc;
            }
        },
        {
            /**
   * Return an `Array` of every possible non-cyclic path in the object.
   * Paths are `Array`s of string keys.
   */ key: "paths",
            value: function paths() {
                var acc = [];
                this.forEach(function() {
                    acc.push(this.path);
                });
                return acc;
            }
        },
        {
            /**
   * Return an `Array` of every node in the object.
   */ key: "nodes",
            value: function nodes() {
                var acc = [];
                this.forEach(function() {
                    acc.push(this.node);
                });
                return acc;
            }
        },
        {
            /**
   * Create a deep clone of the object.
   */ key: "clone",
            value: function clone() {
                var parents = [];
                var nodes = [];
                var options = __privateGet(this, _options);
                if (is_typed_array(__privateGet(this, _value))) {
                    return __privateGet(this, _value).slice();
                }
                return function clone(src) {
                    for(var i = 0; i < parents.length; i++){
                        if (parents[i] === src) {
                            return nodes[i];
                        }
                    }
                    if ((typeof src === "undefined" ? "undefined" : _type_of(src)) === "object" && src !== null) {
                        var dst = copy(src, options);
                        parents.push(src);
                        nodes.push(dst);
                        var iteratorFunction = options.includeSymbols ? own_enumerable_keys : Object.keys;
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator = iteratorFunction(src)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                var key = _step.value;
                                dst[key] = clone(src[key]);
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                        parents.pop();
                        nodes.pop();
                        return dst;
                    }
                    return src;
                }(__privateGet(this, _value));
            }
        }
    ]);
    return Traverse;
}();
_value = new WeakMap();
_options = new WeakMap();
var traverse = function(obj, options) {
    return new Traverse(obj, options);
};
traverse.get = function(obj, paths, options) {
    return new Traverse(obj, options).get(paths);
};
traverse.set = function(obj, path, value, options) {
    return new Traverse(obj, options).set(path, value);
};
traverse.has = function(obj, paths, options) {
    return new Traverse(obj, options).has(paths);
};
traverse.map = function(obj, cb, options) {
    return new Traverse(obj, options).map(cb);
};
traverse.forEach = function(obj, cb, options) {
    return new Traverse(obj, options).forEach(cb);
};
traverse.reduce = function(obj, cb, init, options) {
    return new Traverse(obj, options).reduce(cb, init);
};
traverse.paths = function(obj, options) {
    return new Traverse(obj, options).paths();
};
traverse.nodes = function(obj, options) {
    return new Traverse(obj, options).nodes();
};
traverse.clone = function(obj, options) {
    return new Traverse(obj, options).clone();
};
var src_default = traverse;
;
}),
"[project]/node_modules/minim/lib/serialisers/JSONSerialiser.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * @class JSONSerialiser
 *
 * @param {Namespace} namespace
 *
 * @property {Namespace} namespace
 */ class JSONSerialiser {
    constructor(namespace){
        this.namespace = namespace || new this.Namespace();
    }
    /**
   * @param {Element} element
   * @returns {object}
   */ serialise(element) {
        if (!(element instanceof this.namespace.elements.Element)) {
            throw new TypeError(`Given element \`${element}\` is not an Element instance`);
        }
        const payload = {
            element: element.element
        };
        if (element._meta && element._meta.length > 0) {
            payload.meta = this.serialiseObject(element.meta);
        }
        if (element._attributes && element._attributes.length > 0) {
            payload.attributes = this.serialiseObject(element.attributes);
        }
        const content = this.serialiseContent(element.content);
        if (content !== undefined) {
            payload.content = content;
        }
        return payload;
    }
    /**
   * @param {object} value
   * @returns {Element}
   */ deserialise(value) {
        if (!value.element) {
            throw new Error('Given value is not an object containing an element name');
        }
        const ElementClass = this.namespace.getElementClass(value.element);
        const element = new ElementClass();
        if (element.element !== value.element) {
            element.element = value.element;
        }
        if (value.meta) {
            this.deserialiseObject(value.meta, element.meta);
        }
        if (value.attributes) {
            this.deserialiseObject(value.attributes, element.attributes);
        }
        const content = this.deserialiseContent(value.content);
        if (content !== undefined || element.content === null) {
            element.content = content;
        }
        return element;
    }
    // Private API
    serialiseContent(content) {
        if (content instanceof this.namespace.elements.Element) {
            return this.serialise(content);
        }
        if (content instanceof this.namespace.KeyValuePair) {
            const pair = {
                key: this.serialise(content.key)
            };
            if (content.value) {
                pair.value = this.serialise(content.value);
            }
            return pair;
        }
        if (content && content.map) {
            if (content.length === 0) {
                return undefined;
            }
            return content.map(this.serialise, this);
        }
        return content;
    }
    deserialiseContent(content) {
        if (content) {
            if (content.element) {
                return this.deserialise(content);
            }
            if (content.key) {
                const pair = new this.namespace.KeyValuePair(this.deserialise(content.key));
                if (content.value) {
                    pair.value = this.deserialise(content.value);
                }
                return pair;
            }
            if (content.map) {
                return content.map(this.deserialise, this);
            }
        }
        return content;
    }
    serialiseObject(obj) {
        const result = {};
        obj.forEach((value, key)=>{
            if (value) {
                result[key.toValue()] = this.serialise(value);
            }
        });
        if (Object.keys(result).length === 0) {
            return undefined;
        }
        return result;
    }
    deserialiseObject(from, to) {
        Object.keys(from).forEach((key)=>{
            to.set(key, this.deserialise(from[key]));
        });
    }
}
module.exports = JSONSerialiser;
}),
"[project]/node_modules/minim/lib/KeyValuePair.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * @class
 *
 * @property {Element} key
 * @property {Element} value
 */ class KeyValuePair {
    constructor(key, value){
        this.key = key;
        this.value = value;
    }
    /**
   * @returns {KeyValuePair}
   */ clone() {
        const clone = new KeyValuePair();
        if (this.key) {
            clone.key = this.key.clone();
        }
        if (this.value) {
            clone.value = this.value.clone();
        }
        return clone;
    }
}
module.exports = KeyValuePair;
}),
"[project]/node_modules/minim/lib/ArraySlice.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const negate = __turbopack_context__.r("[project]/node_modules/lodash/negate.js [app-client] (ecmascript)");
// Coerces an a parameter into a callback for matching elements.
// This accepts an element name, an element type and returns a
// callback to match for those elements.
function coerceElementMatchingCallback(value) {
    // Element Name
    if (typeof value === 'string') {
        return (element)=>element.element === value;
    }
    // Element Type
    if (value.constructor && value.extend) {
        return (element)=>element instanceof value;
    }
    return value;
}
/**
 * @class
 *
 * @param {Element[]} elements
 *
 * @property {Element[]} elements
 */ class ArraySlice {
    constructor(elements){
        this.elements = elements || [];
    }
    /**
   * @returns {Array}
   */ toValue() {
        return this.elements.map((element)=>element.toValue());
    }
    // High Order Functions
    /**
   * @param callback - Function to execute for each element
   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
   * @returns {array} A new array with each element being the result of the callback function
   */ map(callback, thisArg) {
        return this.elements.map(callback, thisArg);
    }
    /**
   * Maps and then flattens the results.
   * @param callback - Function to execute for each element.
   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
   * @returns {array}
   */ flatMap(callback, thisArg) {
        return this.map(callback, thisArg).reduce((a, b)=>a.concat(b), []);
    }
    /**
   * Returns an array containing the truthy results of calling the given transformation with each element of this sequence
   * @param transform - A closure that accepts an element of this array as its argument and returns an optional value.
   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
   * @memberof ArraySlice.prototype
   * @returns An array of the non-undefined results of calling transform with each element of the array
   */ compactMap(transform, thisArg) {
        const results = [];
        this.forEach((element)=>{
            const result = transform.bind(thisArg)(element);
            if (result) {
                results.push(result);
            }
        });
        return results;
    }
    /**
   * @param callback - Function to execute for each element. This may be a callback, an element name or an element class.
   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
   * @returns {ArraySlice}
   * @memberof ArraySlice.prototype
   */ filter(callback, thisArg) {
        callback = coerceElementMatchingCallback(callback);
        return new ArraySlice(this.elements.filter(callback, thisArg));
    }
    /**
   * @param callback - Function to execute for each element. This may be a callback, an element name or an element class.
   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
   * @returns {ArraySlice}
   * @memberof ArraySlice.prototype
   */ reject(callback, thisArg) {
        callback = coerceElementMatchingCallback(callback);
        return new ArraySlice(this.elements.filter(negate(callback), thisArg));
    }
    /**
   * Returns the first element in the array that satisfies the given value
   * @param callback - Function to execute for each element. This may be a callback, an element name or an element class.
   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
   * @returns {Element}
   * @memberof ArraySlice.prototype
   */ find(callback, thisArg) {
        callback = coerceElementMatchingCallback(callback);
        return this.elements.find(callback, thisArg);
    }
    /**
   * @param callback - Function to execute for each element
   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
   * @memberof ArraySlice.prototype
   */ forEach(callback, thisArg) {
        this.elements.forEach(callback, thisArg);
    }
    /**
   * @param callback - Function to execute for each element
   * @param initialValue
   * @memberof ArraySlice.prototype
   */ reduce(callback, initialValue) {
        return this.elements.reduce(callback, initialValue);
    }
    /**
   * @param value
   * @returns {boolean}
   * @memberof ArraySlice.prototype
   */ includes(value) {
        return this.elements.some((element)=>element.equals(value));
    }
    // Mutation
    /**
   * Removes the first element from the slice
   * @returns {Element} The removed element or undefined if the slice is empty
   * @memberof ArraySlice.prototype
   */ shift() {
        return this.elements.shift();
    }
    /**
   * Adds the given element to the begining of the slice
   * @parameter {Element} value
   * @memberof ArraySlice.prototype
   */ unshift(value) {
        this.elements.unshift(this.refract(value));
    }
    /**
   * Adds the given element to the end of the slice
   * @parameter {Element} value
   * @memberof ArraySlice.prototype
   */ push(value) {
        this.elements.push(this.refract(value));
        return this;
    }
    /**
   * @parameter {Element} value
   * @memberof ArraySlice.prototype
   */ add(value) {
        this.push(value);
    }
    // Accessors
    /**
   * @parameter {number} index
   * @returns {Element}
   * @memberof ArraySlice.prototype
   */ get(index) {
        return this.elements[index];
    }
    /**
   * @parameter {number} index
   * @memberof ArraySlice.prototype
   */ getValue(index) {
        const element = this.elements[index];
        if (element) {
            return element.toValue();
        }
        return undefined;
    }
    /**
   * Returns the number of elements in the slice
   * @type number
   */ get length() {
        return this.elements.length;
    }
    /**
   * Returns whether the slice is empty
   * @type boolean
   */ get isEmpty() {
        return this.elements.length === 0;
    }
    /**
   * Returns the first element in the slice or undefined if the slice is empty
   * @type Element
   */ get first() {
        return this.elements[0];
    }
}
if (typeof Symbol !== 'undefined') {
    ArraySlice.prototype[Symbol.iterator] = function symbol() {
        return this.elements[Symbol.iterator]();
    };
}
module.exports = ArraySlice;
}),
"[project]/node_modules/minim/lib/primitives/Element.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const isEqual = __turbopack_context__.r("[project]/node_modules/lodash/isEqual.js [app-client] (ecmascript)");
const KeyValuePair = __turbopack_context__.r("[project]/node_modules/minim/lib/KeyValuePair.js [app-client] (ecmascript)");
const ArraySlice = __turbopack_context__.r("[project]/node_modules/minim/lib/ArraySlice.js [app-client] (ecmascript)");
/**
 * @class
 *
 * @param content
 * @param meta
 * @param attributes
 *
 * @property {string} element
 */ class Element {
    constructor(content, meta, attributes){
        // Lazy load this.meta and this.attributes because it's a Minim element
        // Otherwise, we get into circuluar calls
        if (meta) {
            this.meta = meta;
        }
        if (attributes) {
            this.attributes = attributes;
        }
        this.content = content;
    }
    /**
   * Freezes the element to prevent any mutation.
   * A frozen element will add `parent` property to every child element
   * to allow traversing up the element tree.
   */ freeze() {
        if (Object.isFrozen(this)) {
            return;
        }
        if (this._meta) {
            this.meta.parent = this;
            this.meta.freeze();
        }
        if (this._attributes) {
            this.attributes.parent = this;
            this.attributes.freeze();
        }
        this.children.forEach((element)=>{
            element.parent = this;
            element.freeze();
        }, this);
        if (this.content && Array.isArray(this.content)) {
            Object.freeze(this.content);
        }
        Object.freeze(this);
    }
    primitive() {}
    /**
   * Creates a deep clone of the instance
   */ clone() {
        const copy = new this.constructor();
        copy.element = this.element;
        if (this.meta.length) {
            copy._meta = this.meta.clone();
        }
        if (this.attributes.length) {
            copy._attributes = this.attributes.clone();
        }
        if (this.content) {
            if (this.content.clone) {
                copy.content = this.content.clone();
            } else if (Array.isArray(this.content)) {
                copy.content = this.content.map((element)=>element.clone());
            } else {
                copy.content = this.content;
            }
        } else {
            copy.content = this.content;
        }
        return copy;
    }
    /**
   */ toValue() {
        if (this.content instanceof Element) {
            return this.content.toValue();
        }
        if (this.content instanceof KeyValuePair) {
            return {
                key: this.content.key.toValue(),
                value: this.content.value ? this.content.value.toValue() : undefined
            };
        }
        if (this.content && this.content.map) {
            return this.content.map((element)=>element.toValue(), this);
        }
        return this.content;
    }
    /**
   * Creates a reference pointing at the Element
   * @returns {RefElement}
   * @memberof Element.prototype
   */ toRef(path) {
        if (this.id.toValue() === '') {
            throw Error('Cannot create reference to an element that does not contain an ID');
        }
        const ref = new this.RefElement(this.id.toValue());
        if (path) {
            ref.path = path;
        }
        return ref;
    }
    /**
   * Finds the given elements in the element tree.
   * When providing multiple element names, you must first freeze the element.
   *
   * @param names {...elementNames}
   * @returns {ArraySlice}
   */ findRecursive(...elementNames) {
        if (arguments.length > 1 && !this.isFrozen) {
            throw new Error('Cannot find recursive with multiple element names without first freezing the element. Call `element.freeze()`');
        }
        const elementName = elementNames.pop();
        let elements = new ArraySlice();
        const append = (array, element)=>{
            array.push(element);
            return array;
        };
        // Checks the given element and appends element/sub-elements
        // that match element name to given array
        const checkElement = (array, element)=>{
            if (element.element === elementName) {
                array.push(element);
            }
            const items = element.findRecursive(elementName);
            if (items) {
                items.reduce(append, array);
            }
            if (element.content instanceof KeyValuePair) {
                if (element.content.key) {
                    checkElement(array, element.content.key);
                }
                if (element.content.value) {
                    checkElement(array, element.content.value);
                }
            }
            return array;
        };
        if (this.content) {
            // Direct Element
            if (this.content.element) {
                checkElement(elements, this.content);
            }
            // Element Array
            if (Array.isArray(this.content)) {
                this.content.reduce(checkElement, elements);
            }
        }
        if (!elementNames.isEmpty) {
            elements = elements.filter((element)=>{
                let parentElements = element.parents.map((e)=>e.element);
                // eslint-disable-next-line no-restricted-syntax
                for(const namesIndex in elementNames){
                    const name = elementNames[namesIndex];
                    const index = parentElements.indexOf(name);
                    if (index !== -1) {
                        parentElements = parentElements.splice(0, index);
                    } else {
                        return false;
                    }
                }
                return true;
            });
        }
        return elements;
    }
    set(content) {
        this.content = content;
        return this;
    }
    equals(value) {
        return isEqual(this.toValue(), value);
    }
    getMetaProperty(name, value) {
        if (!this.meta.hasKey(name)) {
            if (this.isFrozen) {
                const element = this.refract(value);
                element.freeze();
                return element;
            }
            this.meta.set(name, value);
        }
        return this.meta.get(name);
    }
    setMetaProperty(name, value) {
        this.meta.set(name, value);
    }
    /**
   * @type String
   */ get element() {
        // Returns 'element' so we don't have undefined as element
        return this._storedElement || 'element';
    }
    set element(element) {
        this._storedElement = element;
    }
    get content() {
        return this._content;
    }
    set content(value) {
        if (value instanceof Element) {
            this._content = value;
        } else if (value instanceof ArraySlice) {
            this.content = value.elements;
        } else if (typeof value == 'string' || typeof value == 'number' || typeof value == 'boolean' || value === 'null' || value == undefined) {
            // Primitive Values
            this._content = value;
        } else if (value instanceof KeyValuePair) {
            this._content = value;
        } else if (Array.isArray(value)) {
            this._content = value.map(this.refract);
        } else if (typeof value === 'object') {
            this._content = Object.keys(value).map((key)=>new this.MemberElement(key, value[key]));
        } else {
            throw new Error('Cannot set content to given value');
        }
    }
    /**
   * @type ObjectElement
   */ get meta() {
        if (!this._meta) {
            if (this.isFrozen) {
                const meta = new this.ObjectElement();
                meta.freeze();
                return meta;
            }
            this._meta = new this.ObjectElement();
        }
        return this._meta;
    }
    set meta(value) {
        if (value instanceof this.ObjectElement) {
            this._meta = value;
        } else {
            this.meta.set(value || {});
        }
    }
    /**
   * The attributes property defines attributes about the given instance
   * of the element, as specified by the element property.
   *
   * @type ObjectElement
   */ get attributes() {
        if (!this._attributes) {
            if (this.isFrozen) {
                const meta = new this.ObjectElement();
                meta.freeze();
                return meta;
            }
            this._attributes = new this.ObjectElement();
        }
        return this._attributes;
    }
    set attributes(value) {
        if (value instanceof this.ObjectElement) {
            this._attributes = value;
        } else {
            this.attributes.set(value || {});
        }
    }
    /**
   * Unique Identifier, MUST be unique throughout an entire element tree.
   * @type StringElement
   */ get id() {
        return this.getMetaProperty('id', '');
    }
    set id(element) {
        this.setMetaProperty('id', element);
    }
    /**
   * @type ArrayElement
   */ get classes() {
        return this.getMetaProperty('classes', []);
    }
    set classes(element) {
        this.setMetaProperty('classes', element);
    }
    /**
   * Human-readable title of element
   * @type StringElement
   */ get title() {
        return this.getMetaProperty('title', '');
    }
    set title(element) {
        this.setMetaProperty('title', element);
    }
    /**
   * Human-readable description of element
   * @type StringElement
   */ get description() {
        return this.getMetaProperty('description', '');
    }
    set description(element) {
        this.setMetaProperty('description', element);
    }
    /**
   * @type ArrayElement
   */ get links() {
        return this.getMetaProperty('links', []);
    }
    set links(element) {
        this.setMetaProperty('links', element);
    }
    /**
   * Returns whether the element is frozen.
   * @type boolean
   * @see freeze
   */ get isFrozen() {
        return Object.isFrozen(this);
    }
    /**
   * Returns all of the parent elements.
   * @type ArraySlice
   */ get parents() {
        let { parent } = this;
        const parents = new ArraySlice();
        while(parent){
            parents.push(parent);
            // eslint-disable-next-line prefer-destructuring
            parent = parent.parent;
        }
        return parents;
    }
    /**
   * Returns all of the children elements found within the element.
   * @type ArraySlice
   * @see recursiveChildren
   */ get children() {
        if (Array.isArray(this.content)) {
            return new ArraySlice(this.content);
        }
        if (this.content instanceof KeyValuePair) {
            const children = new ArraySlice([
                this.content.key
            ]);
            if (this.content.value) {
                children.push(this.content.value);
            }
            return children;
        }
        if (this.content instanceof Element) {
            return new ArraySlice([
                this.content
            ]);
        }
        return new ArraySlice();
    }
    /**
  * Returns all of the children elements found within the element recursively.
  * @type ArraySlice
  * @see children
  */ get recursiveChildren() {
        const children = new ArraySlice();
        this.children.forEach((element)=>{
            children.push(element);
            element.recursiveChildren.forEach((child)=>{
                children.push(child);
            });
        });
        return children;
    }
}
module.exports = Element;
}),
"[project]/node_modules/minim/lib/primitives/NullElement.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const Element = __turbopack_context__.r("[project]/node_modules/minim/lib/primitives/Element.js [app-client] (ecmascript)");
/**
 */ class NullElement extends Element {
    constructor(content, meta, attributes){
        super(content || null, meta, attributes);
        this.element = 'null';
    }
    primitive() {
        return 'null';
    }
    set() {
        return new Error('Cannot set the value of null');
    }
}
module.exports = NullElement;
}),
"[project]/node_modules/minim/lib/primitives/StringElement.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const Element = __turbopack_context__.r("[project]/node_modules/minim/lib/primitives/Element.js [app-client] (ecmascript)");
/**
 * @class StringElement
 *
 * @param {string} content
 * @param meta
 * @param attributes
 */ module.exports = class StringElement extends Element {
    constructor(content, meta, attributes){
        super(content, meta, attributes);
        this.element = 'string';
    }
    primitive() {
        return 'string';
    }
    /**
   * The length of the string.
   * @type number
   */ get length() {
        return this.content.length;
    }
};
}),
"[project]/node_modules/minim/lib/primitives/NumberElement.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const Element = __turbopack_context__.r("[project]/node_modules/minim/lib/primitives/Element.js [app-client] (ecmascript)");
/**
 * @class NumberElement
 *
 * @param {number} content
 * @param meta
 * @param attributes
 */ module.exports = class NumberElement extends Element {
    constructor(content, meta, attributes){
        super(content, meta, attributes);
        this.element = 'number';
    }
    primitive() {
        return 'number';
    }
};
}),
"[project]/node_modules/minim/lib/primitives/BooleanElement.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const Element = __turbopack_context__.r("[project]/node_modules/minim/lib/primitives/Element.js [app-client] (ecmascript)");
/**
 * @class BooleanElement
 *
 * @param {boolean} content
 * @param meta
 * @param attributes
 */ module.exports = class BooleanElement extends Element {
    constructor(content, meta, attributes){
        super(content, meta, attributes);
        this.element = 'boolean';
    }
    primitive() {
        return 'boolean';
    }
};
}),
"[project]/node_modules/minim/lib/primitives/ArrayElement.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const negate = __turbopack_context__.r("[project]/node_modules/lodash/negate.js [app-client] (ecmascript)");
const Element = __turbopack_context__.r("[project]/node_modules/minim/lib/primitives/Element.js [app-client] (ecmascript)");
const ArraySlice = __turbopack_context__.r("[project]/node_modules/minim/lib/ArraySlice.js [app-client] (ecmascript)");
/**
 * @class
 *
 * @param {Element[]} content
 * @param meta
 * @param attributes
 */ class ArrayElement extends Element {
    constructor(content, meta, attributes){
        super(content || [], meta, attributes);
        this.element = 'array';
    }
    primitive() {
        return 'array';
    }
    /**
   * @returns {Element}
   */ get(index) {
        return this.content[index];
    }
    /**
   * Helper for returning the value of an item
   * This works for both ArrayElement and ObjectElement instances
   */ getValue(indexOrKey) {
        const item = this.get(indexOrKey);
        if (item) {
            return item.toValue();
        }
        return undefined;
    }
    /**
   * @returns {Element}
   */ getIndex(index) {
        return this.content[index];
    }
    set(index, value) {
        this.content[index] = this.refract(value);
        return this;
    }
    remove(index) {
        const removed = this.content.splice(index, 1);
        if (removed.length) {
            return removed[0];
        }
        return null;
    }
    /**
   * @param callback - Function to execute for each element
   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
   */ map(callback, thisArg) {
        return this.content.map(callback, thisArg);
    }
    /**
   * Maps and then flattens the results.
   * @param callback - Function to execute for each element.
   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
   * @returns {array}
   */ flatMap(callback, thisArg) {
        return this.map(callback, thisArg).reduce((a, b)=>a.concat(b), []);
    }
    /**
   * Returns an array containing the truthy results of calling the given transformation with each element of this sequence
   * @param transform - A closure that accepts an element of this array as its argument and returns an optional value.
   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
   * @memberof ArrayElement.prototype
   * @returns An array of the non-undefined results of calling transform with each element of the array
   */ compactMap(transform, thisArg) {
        const results = [];
        this.forEach((element)=>{
            const result = transform.bind(thisArg)(element);
            if (result) {
                results.push(result);
            }
        });
        return results;
    }
    /**
   * @param callback - Function to execute for each element
   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
   * @returns {ArraySlice}
   */ filter(callback, thisArg) {
        return new ArraySlice(this.content.filter(callback, thisArg));
    }
    /**
   * @param callback - Function to execute for each element
   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
   * @returns {ArraySlice}
   */ reject(callback, thisArg) {
        return this.filter(negate(callback), thisArg);
    }
    /**
   * This is a reduce function specifically for Minim arrays and objects. It
   * allows for returning normal values or Minim instances, so it converts any
   * primitives on each step.
   */ reduce(callback, initialValue) {
        let startIndex;
        let memo;
        // Allows for defining a starting value of the reduce
        if (initialValue !== undefined) {
            startIndex = 0;
            memo = this.refract(initialValue);
        } else {
            startIndex = 1;
            // Object Element content items are member elements. Because of this,
            // the memo should start out as the member value rather than the
            // actual member itself.
            memo = this.primitive() === 'object' ? this.first.value : this.first;
        }
        // Sending each function call to the registry allows for passing Minim
        // instances through the function return. This means you can return
        // primitive values or return Minim instances and reduce will still work.
        for(let i = startIndex; i < this.length; i += 1){
            const item = this.content[i];
            if (this.primitive() === 'object') {
                memo = this.refract(callback(memo, item.value, item.key, item, this));
            } else {
                memo = this.refract(callback(memo, item, i, this));
            }
        }
        return memo;
    }
    /**
   * @callback forEachCallback
   * @param {Element} currentValue
   * @param {NumberElement} index
   */ /**
   * @param {forEachCallback} callback - Function to execute for each element
   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
   * @memberof ArrayElement.prototype
   */ forEach(callback, thisArg) {
        this.content.forEach((item, index)=>{
            callback.bind(thisArg)(item, this.refract(index));
        });
    }
    /**
   * @returns {Element}
   */ shift() {
        return this.content.shift();
    }
    /**
   * @param value
   */ unshift(value) {
        this.content.unshift(this.refract(value));
    }
    /**
   * @param value
   */ push(value) {
        this.content.push(this.refract(value));
        return this;
    }
    /**
   * @param value
   */ add(value) {
        this.push(value);
    }
    /**
   * Recusively search all descendents using a condition function.
   * @returns {Element[]}
   */ findElements(condition, givenOptions) {
        const options = givenOptions || {};
        const recursive = !!options.recursive;
        const results = options.results === undefined ? [] : options.results;
        // The forEach method for Object Elements returns value, key, and member.
        // This passes those along to the condition function below.
        this.forEach((item, keyOrIndex, member)=>{
            // We use duck-typing here to support any registered class that
            // may contain other elements.
            if (recursive && item.findElements !== undefined) {
                item.findElements(condition, {
                    results,
                    recursive
                });
            }
            if (condition(item, keyOrIndex, member)) {
                results.push(item);
            }
        });
        return results;
    }
    /**
   * Recusively search all descendents using a condition function.
   * @param condition
   * @returns {ArraySlice}
   */ find(condition) {
        return new ArraySlice(this.findElements(condition, {
            recursive: true
        }));
    }
    /**
   * @param {string} element
   * @returns {ArraySlice}
   */ findByElement(element) {
        return this.find((item)=>item.element === element);
    }
    /**
   * @param {string} className
   * @returns {ArraySlice}
   * @memberof ArrayElement.prototype
   */ findByClass(className) {
        return this.find((item)=>item.classes.includes(className));
    }
    /**
   * Search the tree recursively and find the element with the matching ID
   * @param {string} id
   * @returns {Element}
   * @memberof ArrayElement.prototype
   */ getById(id) {
        return this.find((item)=>item.id.toValue() === id).first;
    }
    /**
   * Looks for matching children using deep equality
   * @param value
   * @returns {boolean}
   */ includes(value) {
        return this.content.some((element)=>element.equals(value));
    }
    /**
   * Looks for matching children using deep equality
   * @param value
   * @returns {boolean}
   * @see includes
   * @deprecated method was replaced by includes
   */ contains(value) {
        return this.includes(value);
    }
    // Fantasy Land
    /**
   * @returns {ArrayElement} An empty array element
   */ empty() {
        return new this.constructor([]);
    }
    ['fantasy-land/empty']() {
        return this.empty();
    }
    /**
   * @param {ArrayElement} other
   * @returns {ArrayElement}
   */ concat(other) {
        return new this.constructor(this.content.concat(other.content));
    }
    ['fantasy-land/concat'](other) {
        return this.concat(other);
    }
    ['fantasy-land/map'](transform) {
        return new this.constructor(this.map(transform));
    }
    ['fantasy-land/chain'](transform) {
        return this.map((element)=>transform(element), this).reduce((a, b)=>a.concat(b), this.empty());
    }
    ['fantasy-land/filter'](callback) {
        return new this.constructor(this.content.filter(callback));
    }
    ['fantasy-land/reduce'](transform, initialValue) {
        return this.content.reduce(transform, initialValue);
    }
    /**
   * Returns the length of the collection
   * @type number
   */ get length() {
        return this.content.length;
    }
    /**
   * Returns whether the collection is empty
   * @type boolean
   */ get isEmpty() {
        return this.content.length === 0;
    }
    /**
   * Return the first item in the collection
   * @type Element
   */ get first() {
        return this.getIndex(0);
    }
    /**
   * Return the second item in the collection
   * @type Element
   */ get second() {
        return this.getIndex(1);
    }
    /**
   * Return the last item in the collection
   * @type Element
   */ get last() {
        return this.getIndex(this.length - 1);
    }
}
/**
 * @returns {ArrayElement} An empty array element
 */ ArrayElement.empty = function empty() {
    return new this();
};
ArrayElement['fantasy-land/empty'] = ArrayElement.empty;
if (typeof Symbol !== 'undefined') {
    ArrayElement.prototype[Symbol.iterator] = function symbol() {
        return this.content[Symbol.iterator]();
    };
}
module.exports = ArrayElement;
}),
"[project]/node_modules/minim/lib/primitives/MemberElement.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const KeyValuePair = __turbopack_context__.r("[project]/node_modules/minim/lib/KeyValuePair.js [app-client] (ecmascript)");
const Element = __turbopack_context__.r("[project]/node_modules/minim/lib/primitives/Element.js [app-client] (ecmascript)");
/**
 * @class MemberElement
 *
 * @param {Element} key
 * @param {Element} value
 * @param meta
 * @param attributes
 */ module.exports = class MemberElement extends Element {
    constructor(key, value, meta, attributes){
        super(new KeyValuePair(), meta, attributes);
        this.element = 'member';
        this.key = key;
        this.value = value;
    }
    /**
   * @type Element
   */ get key() {
        return this.content.key;
    }
    set key(key) {
        this.content.key = this.refract(key);
    }
    /**
   * @type Element
   */ get value() {
        return this.content.value;
    }
    set value(value) {
        this.content.value = this.refract(value);
    }
};
}),
"[project]/node_modules/minim/lib/ObjectSlice.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const negate = __turbopack_context__.r("[project]/node_modules/lodash/negate.js [app-client] (ecmascript)");
const ArraySlice = __turbopack_context__.r("[project]/node_modules/minim/lib/ArraySlice.js [app-client] (ecmascript)");
/**
 */ class ObjectSlice extends ArraySlice {
    map(callback, thisArg) {
        return this.elements.map((member)=>callback.bind(thisArg)(member.value, member.key, member));
    }
    filter(callback, thisArg) {
        return new ObjectSlice(this.elements.filter((member)=>callback.bind(thisArg)(member.value, member.key, member)));
    }
    reject(callback, thisArg) {
        return this.filter(negate(callback.bind(thisArg)));
    }
    forEach(callback, thisArg) {
        return this.elements.forEach((member, index)=>{
            callback.bind(thisArg)(member.value, member.key, member, index);
        });
    }
    /**
   * @returns {array}
   */ keys() {
        return this.map((value, key)=>key.toValue());
    }
    /**
   * @returns {array}
   */ values() {
        return this.map((value)=>value.toValue());
    }
}
module.exports = ObjectSlice;
}),
"[project]/node_modules/minim/lib/primitives/ObjectElement.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const negate = __turbopack_context__.r("[project]/node_modules/lodash/negate.js [app-client] (ecmascript)");
const isObject = __turbopack_context__.r("[project]/node_modules/lodash/isObject.js [app-client] (ecmascript)");
const ArrayElement = __turbopack_context__.r("[project]/node_modules/minim/lib/primitives/ArrayElement.js [app-client] (ecmascript)");
const MemberElement = __turbopack_context__.r("[project]/node_modules/minim/lib/primitives/MemberElement.js [app-client] (ecmascript)");
const ObjectSlice = __turbopack_context__.r("[project]/node_modules/minim/lib/ObjectSlice.js [app-client] (ecmascript)");
/**
 * @class
 *
 * @param content
 * @param meta
 * @param attributes
 */ class ObjectElement extends ArrayElement {
    constructor(content, meta, attributes){
        super(content || [], meta, attributes);
        this.element = 'object';
    }
    primitive() {
        return 'object';
    }
    toValue() {
        return this.content.reduce((results, el)=>{
            results[el.key.toValue()] = el.value ? el.value.toValue() : undefined;
            return results;
        }, {});
    }
    /**
   * @param key
   * @returns {Element}
   */ get(name) {
        const member = this.getMember(name);
        if (member) {
            return member.value;
        }
        return undefined;
    }
    /**
   * @param key
   * @returns {MemberElement}
   */ getMember(name) {
        if (name === undefined) {
            return undefined;
        }
        return this.content.find((element)=>element.key.toValue() === name);
    }
    /**
   * @param key
   */ remove(name) {
        let removed = null;
        this.content = this.content.filter((item)=>{
            if (item.key.toValue() === name) {
                removed = item;
                return false;
            }
            return true;
        });
        return removed;
    }
    /**
   * @param key
   * @returns {Element}
   */ getKey(name) {
        const member = this.getMember(name);
        if (member) {
            return member.key;
        }
        return undefined;
    }
    /**
   * Set allows either a key/value pair to be given or an object
   * If an object is given, each key is set to its respective value
   */ set(keyOrObject, value) {
        if (isObject(keyOrObject)) {
            Object.keys(keyOrObject).forEach((objectKey)=>{
                this.set(objectKey, keyOrObject[objectKey]);
            });
            return this;
        }
        // Store as key for clarity
        const key = keyOrObject;
        const member = this.getMember(key);
        if (member) {
            member.value = value;
        } else {
            this.content.push(new MemberElement(key, value));
        }
        return this;
    }
    /**
   */ keys() {
        return this.content.map((item)=>item.key.toValue());
    }
    /**
   */ values() {
        return this.content.map((item)=>item.value.toValue());
    }
    /**
   * @returns {boolean}
   */ hasKey(value) {
        return this.content.some((member)=>member.key.equals(value));
    }
    /**
   * @returns {array}
   */ items() {
        return this.content.map((item)=>[
                item.key.toValue(),
                item.value.toValue()
            ]);
    }
    /**
   * @param callback
   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
   */ map(callback, thisArg) {
        return this.content.map((item)=>callback.bind(thisArg)(item.value, item.key, item));
    }
    /**
   * Returns an array containing the truthy results of calling the given transformation with each element of this sequence
   * @param transform - A closure that accepts the value, key and member element of this object as its argument and returns an optional value.
   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
   * @returns An array of the non-undefined results of calling transform with each element of the array
   */ compactMap(callback, thisArg) {
        const results = [];
        this.forEach((value, key, member)=>{
            const result = callback.bind(thisArg)(value, key, member);
            if (result) {
                results.push(result);
            }
        });
        return results;
    }
    /**
   * @param callback
   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
   *
   * @returns {ObjectSlice}
   */ filter(callback, thisArg) {
        return new ObjectSlice(this.content).filter(callback, thisArg);
    }
    /**
   * @param callback
   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
   *
   * @returns {ObjectSlice}
   *
   * @memberof ObjectElement.prototype
   */ reject(callback, thisArg) {
        return this.filter(negate(callback), thisArg);
    }
    /**
   * @param callback
   * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
   *
   * @memberof ObjectElement.prototype
   */ forEach(callback, thisArg) {
        return this.content.forEach((item)=>callback.bind(thisArg)(item.value, item.key, item));
    }
}
module.exports = ObjectElement;
}),
"[project]/node_modules/minim/lib/elements/LinkElement.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const Element = __turbopack_context__.r("[project]/node_modules/minim/lib/primitives/Element.js [app-client] (ecmascript)");
/** Hyperlinking MAY be used to link to other resources, provide links to
 * instructions on how to process a given element (by way of a profile or
 * other means), and may be used to provide meta data about the element in
 * which it's found. The meaning and purpose of the hyperlink is defined by
 * the link relation according to RFC 5988.
 *
 * @class LinkElement
 *
 * @param content
 * @param meta
 * @param attributes
 */ module.exports = class LinkElement extends Element {
    constructor(content, meta, attributes){
        super(content || [], meta, attributes);
        this.element = 'link';
    }
    /**
   * The relation identifier for the link, as defined in RFC 5988.
   * @type StringElement
   */ get relation() {
        return this.attributes.get('relation');
    }
    set relation(relation) {
        this.attributes.set('relation', relation);
    }
    /**
   * The URI for the given link.
   * @type StringElement
   */ get href() {
        return this.attributes.get('href');
    }
    set href(href) {
        this.attributes.set('href', href);
    }
};
}),
"[project]/node_modules/minim/lib/elements/RefElement.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const Element = __turbopack_context__.r("[project]/node_modules/minim/lib/primitives/Element.js [app-client] (ecmascript)");
/**
 * @class RefElement
 *
 * @param content
 * @param meta
 * @param attributes
 *
 * @extends Element
 */ module.exports = class RefElement extends Element {
    constructor(content, meta, attributes){
        super(content || [], meta, attributes);
        this.element = 'ref';
        if (!this.path) {
            this.path = 'element';
        }
    }
    /**
   * Path of referenced element to transclude instead of element itself.
   * @type StringElement
   * @default element
   */ get path() {
        return this.attributes.get('path');
    }
    set path(newValue) {
        this.attributes.set('path', newValue);
    }
};
}),
"[project]/node_modules/minim/lib/elements.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const Element = __turbopack_context__.r("[project]/node_modules/minim/lib/primitives/Element.js [app-client] (ecmascript)");
const NullElement = __turbopack_context__.r("[project]/node_modules/minim/lib/primitives/NullElement.js [app-client] (ecmascript)");
const StringElement = __turbopack_context__.r("[project]/node_modules/minim/lib/primitives/StringElement.js [app-client] (ecmascript)");
const NumberElement = __turbopack_context__.r("[project]/node_modules/minim/lib/primitives/NumberElement.js [app-client] (ecmascript)");
const BooleanElement = __turbopack_context__.r("[project]/node_modules/minim/lib/primitives/BooleanElement.js [app-client] (ecmascript)");
const ArrayElement = __turbopack_context__.r("[project]/node_modules/minim/lib/primitives/ArrayElement.js [app-client] (ecmascript)");
const MemberElement = __turbopack_context__.r("[project]/node_modules/minim/lib/primitives/MemberElement.js [app-client] (ecmascript)");
const ObjectElement = __turbopack_context__.r("[project]/node_modules/minim/lib/primitives/ObjectElement.js [app-client] (ecmascript)");
const LinkElement = __turbopack_context__.r("[project]/node_modules/minim/lib/elements/LinkElement.js [app-client] (ecmascript)");
const RefElement = __turbopack_context__.r("[project]/node_modules/minim/lib/elements/RefElement.js [app-client] (ecmascript)");
const ArraySlice = __turbopack_context__.r("[project]/node_modules/minim/lib/ArraySlice.js [app-client] (ecmascript)");
const ObjectSlice = __turbopack_context__.r("[project]/node_modules/minim/lib/ObjectSlice.js [app-client] (ecmascript)");
const KeyValuePair = __turbopack_context__.r("[project]/node_modules/minim/lib/KeyValuePair.js [app-client] (ecmascript)");
/**
 * Refracts a JSON type to minim elements
 * @param value
 * @returns {Element}
 */ function refract(value) {
    if (value instanceof Element) {
        return value;
    }
    if (typeof value === 'string') {
        return new StringElement(value);
    }
    if (typeof value === 'number') {
        return new NumberElement(value);
    }
    if (typeof value === 'boolean') {
        return new BooleanElement(value);
    }
    if (value === null) {
        return new NullElement();
    }
    if (Array.isArray(value)) {
        return new ArrayElement(value.map(refract));
    }
    if (typeof value === 'object') {
        const element = new ObjectElement(value);
        return element;
    }
    return value;
}
Element.prototype.ObjectElement = ObjectElement;
Element.prototype.RefElement = RefElement;
Element.prototype.MemberElement = MemberElement;
Element.prototype.refract = refract;
ArraySlice.prototype.refract = refract;
/**
 * Contains all of the element classes, and related structures and methods
 * for handling with element instances.
 */ module.exports = {
    Element,
    NullElement,
    StringElement,
    NumberElement,
    BooleanElement,
    ArrayElement,
    MemberElement,
    ObjectElement,
    LinkElement,
    RefElement,
    refract,
    ArraySlice,
    ObjectSlice,
    KeyValuePair
};
}),
"[project]/node_modules/minim/lib/Namespace.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const isNull = __turbopack_context__.r("[project]/node_modules/lodash/isNull.js [app-client] (ecmascript)");
const isString = __turbopack_context__.r("[project]/node_modules/lodash/isString.js [app-client] (ecmascript)");
const isNumber = __turbopack_context__.r("[project]/node_modules/lodash/isNumber.js [app-client] (ecmascript)");
const isBoolean = __turbopack_context__.r("[project]/node_modules/lodash/isBoolean.js [app-client] (ecmascript)");
const isObject = __turbopack_context__.r("[project]/node_modules/lodash/isObject.js [app-client] (ecmascript)");
const JSONSerialiser = __turbopack_context__.r("[project]/node_modules/minim/lib/serialisers/JSONSerialiser.js [app-client] (ecmascript)");
const elements = __turbopack_context__.r("[project]/node_modules/minim/lib/elements.js [app-client] (ecmascript)");
/**
 * @class
 *
 * A refract element implementation with an extensible namespace, able to
 * load other namespaces into it.
 *
 * The namespace allows you to register your own classes to be instantiated
 * when a particular refract element is encountered, and allows you to specify
 * which elements get instantiated for existing Javascript objects.
 */ class Namespace {
    constructor(options){
        this.elementMap = {};
        this.elementDetection = [];
        this.Element = elements.Element;
        this.KeyValuePair = elements.KeyValuePair;
        if (!options || !options.noDefault) {
            this.useDefault();
        }
        // These provide the defaults for new elements.
        this._attributeElementKeys = [];
        this._attributeElementArrayKeys = [];
    }
    /**
   * Use a namespace plugin or load a generic plugin.
   *
   * @param plugin
   */ use(plugin) {
        if (plugin.namespace) {
            plugin.namespace({
                base: this
            });
        }
        if (plugin.load) {
            plugin.load({
                base: this
            });
        }
        return this;
    }
    /*
   * Use the default namespace. This preloads all the default elements
   * into this registry instance.
   */ useDefault() {
        // Set up classes for default elements
        this.register('null', elements.NullElement).register('string', elements.StringElement).register('number', elements.NumberElement).register('boolean', elements.BooleanElement).register('array', elements.ArrayElement).register('object', elements.ObjectElement).register('member', elements.MemberElement).register('ref', elements.RefElement).register('link', elements.LinkElement);
        // Add instance detection functions to convert existing objects into
        // the corresponding refract elements.
        this.detect(isNull, elements.NullElement, false).detect(isString, elements.StringElement, false).detect(isNumber, elements.NumberElement, false).detect(isBoolean, elements.BooleanElement, false).detect(Array.isArray, elements.ArrayElement, false).detect(isObject, elements.ObjectElement, false);
        return this;
    }
    /**
   * Register a new element class for an element.
   *
   * @param {string} name
   * @param elementClass
   */ register(name, ElementClass) {
        this._elements = undefined;
        this.elementMap[name] = ElementClass;
        return this;
    }
    /**
   * Unregister a previously registered class for an element.
   *
   * @param {string} name
   */ unregister(name) {
        this._elements = undefined;
        delete this.elementMap[name];
        return this;
    }
    /*
   * Add a new detection function to determine which element
   * class to use when converting existing js instances into
   * refract element.
   */ detect(test, ElementClass, givenPrepend) {
        const prepend = givenPrepend === undefined ? true : givenPrepend;
        if (prepend) {
            this.elementDetection.unshift([
                test,
                ElementClass
            ]);
        } else {
            this.elementDetection.push([
                test,
                ElementClass
            ]);
        }
        return this;
    }
    /*
   * Convert an existing Javascript object into refract element instances, which
   * can be further processed or serialized into refract.
   * If the item passed in is already refracted, then it is returned
   * unmodified.
   */ toElement(value) {
        if (value instanceof this.Element) {
            return value;
        }
        let element;
        for(let i = 0; i < this.elementDetection.length; i += 1){
            const test = this.elementDetection[i][0];
            const ElementClass = this.elementDetection[i][1];
            if (test(value)) {
                element = new ElementClass(value);
                break;
            }
        }
        return element;
    }
    /*
   * Get an element class given an element name.
   */ getElementClass(element) {
        const ElementClass = this.elementMap[element];
        if (ElementClass === undefined) {
            // Fall back to the base element. We may not know what
            // to do with the `content`, but downstream software
            // may know.
            return this.Element;
        }
        return ElementClass;
    }
    /*
   * Convert a refract document into refract element instances.
   */ fromRefract(doc) {
        return this.serialiser.deserialise(doc);
    }
    /*
   * Convert an element to a Refracted JSON object.
   */ toRefract(element) {
        return this.serialiser.serialise(element);
    }
    /*
   * Get an object that contains all registered element classes, where
   * the key is the PascalCased element name and the value is the class.
   */ get elements() {
        if (this._elements === undefined) {
            this._elements = {
                Element: this.Element
            };
            Object.keys(this.elementMap).forEach((name)=>{
                // Currently, all registered element types use a camelCaseName.
                // Converting to PascalCase is as simple as upper-casing the first
                // letter.
                const pascal = name[0].toUpperCase() + name.substr(1);
                this._elements[pascal] = this.elementMap[name];
            });
        }
        return this._elements;
    }
    /**
   * Convinience method for getting a JSON Serialiser configured with the
   * current namespace
   *
   * @type JSONSerialiser
   * @readonly
   *
   * @memberof Namespace.prototype
   */ get serialiser() {
        return new JSONSerialiser(this);
    }
}
JSONSerialiser.prototype.Namespace = Namespace;
module.exports = Namespace;
}),
"[project]/node_modules/minim/lib/serialisers/JSON06Serialiser.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const JSONSerialiser = __turbopack_context__.r("[project]/node_modules/minim/lib/serialisers/JSONSerialiser.js [app-client] (ecmascript)");
module.exports = class JSON06Serialiser extends JSONSerialiser {
    serialise(element) {
        if (!(element instanceof this.namespace.elements.Element)) {
            throw new TypeError(`Given element \`${element}\` is not an Element instance`);
        }
        let variable;
        if (element._attributes && element.attributes.get('variable')) {
            variable = element.attributes.get('variable');
        }
        const payload = {
            element: element.element
        };
        if (element._meta && element._meta.length > 0) {
            payload.meta = this.serialiseObject(element.meta);
        }
        const isEnum = element.element === 'enum' || element.attributes.keys().indexOf('enumerations') !== -1;
        if (isEnum) {
            const attributes = this.enumSerialiseAttributes(element);
            if (attributes) {
                payload.attributes = attributes;
            }
        } else if (element._attributes && element._attributes.length > 0) {
            let { attributes } = element;
            // Meta attribute was renamed to metadata
            if (attributes.get('metadata')) {
                attributes = attributes.clone();
                attributes.set('meta', attributes.get('metadata'));
                attributes.remove('metadata');
            }
            if (element.element === 'member' && variable) {
                attributes = attributes.clone();
                attributes.remove('variable');
            }
            if (attributes.length > 0) {
                payload.attributes = this.serialiseObject(attributes);
            }
        }
        if (isEnum) {
            payload.content = this.enumSerialiseContent(element, payload);
        } else if (this[`${element.element}SerialiseContent`]) {
            payload.content = this[`${element.element}SerialiseContent`](element, payload);
        } else if (element.content !== undefined) {
            let content;
            if (variable && element.content.key) {
                content = element.content.clone();
                content.key.attributes.set('variable', variable);
                content = this.serialiseContent(content);
            } else {
                content = this.serialiseContent(element.content);
            }
            if (this.shouldSerialiseContent(element, content)) {
                payload.content = content;
            }
        } else if (this.shouldSerialiseContent(element, element.content) && element instanceof this.namespace.elements.Array) {
            payload.content = [];
        }
        return payload;
    }
    shouldSerialiseContent(element, content) {
        if (element.element === 'parseResult' || element.element === 'httpRequest' || element.element === 'httpResponse' || element.element === 'category' || element.element === 'link') {
            return true;
        }
        if (content === undefined) {
            return false;
        }
        if (Array.isArray(content) && content.length === 0) {
            return false;
        }
        return true;
    }
    refSerialiseContent(element, payload) {
        delete payload.attributes;
        return {
            href: element.toValue(),
            path: element.path.toValue()
        };
    }
    sourceMapSerialiseContent(element) {
        return element.toValue();
    }
    dataStructureSerialiseContent(element) {
        return [
            this.serialiseContent(element.content)
        ];
    }
    enumSerialiseAttributes(element) {
        const attributes = element.attributes.clone();
        // Enumerations attribute was is placed inside content (see `enumSerialiseContent` below)
        const enumerations = attributes.remove('enumerations') || new this.namespace.elements.Array([]);
        // Remove fixed type attribute from samples and default
        const defaultValue = attributes.get('default');
        let samples = attributes.get('samples') || new this.namespace.elements.Array([]);
        if (defaultValue && defaultValue.content) {
            if (defaultValue.content.attributes) {
                defaultValue.content.attributes.remove('typeAttributes');
            }
            // Wrap default in array (not sure it is really needed because tests pass without this line)
            attributes.set('default', new this.namespace.elements.Array([
                defaultValue.content
            ]));
        }
        // Strip typeAttributes from samples, 0.6 doesn't usually contain them in samples
        samples.forEach((sample)=>{
            if (sample.content && sample.content.element) {
                sample.content.attributes.remove('typeAttributes');
            }
        });
        // Content -> Samples
        if (element.content && enumerations.length !== 0) {
            // If we don't have enumerations, content should stay in
            // content (enumerations) as per Drafter 3 behaviour.
            samples.unshift(element.content);
        }
        samples = samples.map((sample)=>{
            if (sample instanceof this.namespace.elements.Array) {
                return [
                    sample
                ];
            }
            return new this.namespace.elements.Array([
                sample.content
            ]);
        });
        if (samples.length) {
            attributes.set('samples', samples);
        }
        if (attributes.length > 0) {
            return this.serialiseObject(attributes);
        }
        return undefined;
    }
    enumSerialiseContent(element) {
        // In API Elements < 1.0, the content is the enumerations
        // If we don't have an enumerations, use the value (Drafter 3 behaviour)
        if (element._attributes) {
            const enumerations = element.attributes.get('enumerations');
            if (enumerations && enumerations.length > 0) {
                return enumerations.content.map((enumeration)=>{
                    const e = enumeration.clone();
                    e.attributes.remove('typeAttributes');
                    return this.serialise(e);
                });
            }
        }
        if (element.content) {
            const value = element.content.clone();
            value.attributes.remove('typeAttributes');
            return [
                this.serialise(value)
            ];
        }
        return [];
    }
    deserialise(value) {
        if (typeof value === 'string') {
            return new this.namespace.elements.String(value);
        }
        if (typeof value === 'number') {
            return new this.namespace.elements.Number(value);
        }
        if (typeof value === 'boolean') {
            return new this.namespace.elements.Boolean(value);
        }
        if (value === null) {
            return new this.namespace.elements.Null();
        }
        if (Array.isArray(value)) {
            return new this.namespace.elements.Array(value.map(this.deserialise, this));
        }
        const ElementClass = this.namespace.getElementClass(value.element);
        const element = new ElementClass();
        if (element.element !== value.element) {
            element.element = value.element;
        }
        if (value.meta) {
            this.deserialiseObject(value.meta, element.meta);
        }
        if (value.attributes) {
            this.deserialiseObject(value.attributes, element.attributes);
        }
        const content = this.deserialiseContent(value.content);
        if (content !== undefined || element.content === null) {
            element.content = content;
        }
        if (element.element === 'enum') {
            // Grab enumerations from content
            if (element.content) {
                element.attributes.set('enumerations', element.content);
            }
            // Unwrap the sample value (inside double array)
            let samples = element.attributes.get('samples');
            element.attributes.remove('samples');
            if (samples) {
                // Re-wrap samples from array of array to array of enum's
                const existingSamples = samples;
                samples = new this.namespace.elements.Array();
                existingSamples.forEach((existingSample)=>{
                    existingSample.forEach((sample)=>{
                        const enumElement = new ElementClass(sample);
                        enumElement.element = element.element;
                        samples.push(enumElement);
                    });
                });
                const sample = samples.shift();
                if (sample) {
                    element.content = sample.content;
                } else {
                    element.content = undefined;
                }
                element.attributes.set('samples', samples);
            } else {
                element.content = undefined;
            }
            // Unwrap the default value
            let defaultValue = element.attributes.get('default');
            if (defaultValue && defaultValue.length > 0) {
                defaultValue = defaultValue.get(0);
                const defaultElement = new ElementClass(defaultValue);
                defaultElement.element = element.element;
                element.attributes.set('default', defaultElement);
            }
        } else if (element.element === 'dataStructure' && Array.isArray(element.content)) {
            [element.content] = element.content;
        } else if (element.element === 'category') {
            // "meta" attribute has been renamed to metadata
            const metadata = element.attributes.get('meta');
            if (metadata) {
                element.attributes.set('metadata', metadata);
                element.attributes.remove('meta');
            }
        } else if (element.element === 'member' && element.key && element.key._attributes && element.key._attributes.getValue('variable')) {
            element.attributes.set('variable', element.key.attributes.get('variable'));
            element.key.attributes.remove('variable');
        }
        return element;
    }
    // Private API
    serialiseContent(content) {
        if (content instanceof this.namespace.elements.Element) {
            return this.serialise(content);
        }
        if (content instanceof this.namespace.KeyValuePair) {
            const pair = {
                key: this.serialise(content.key)
            };
            if (content.value) {
                pair.value = this.serialise(content.value);
            }
            return pair;
        }
        if (content && content.map) {
            return content.map(this.serialise, this);
        }
        return content;
    }
    deserialiseContent(content) {
        if (content) {
            if (content.element) {
                return this.deserialise(content);
            }
            if (content.key) {
                const pair = new this.namespace.KeyValuePair(this.deserialise(content.key));
                if (content.value) {
                    pair.value = this.deserialise(content.value);
                }
                return pair;
            }
            if (content.map) {
                return content.map(this.deserialise, this);
            }
        }
        return content;
    }
    shouldRefract(element) {
        if (element._attributes && element.attributes.keys().length || element._meta && element.meta.keys().length) {
            return true;
        }
        if (element.element === 'enum') {
            // enum elements are treated like primitives (array)
            return false;
        }
        if (element.element !== element.primitive() || element.element === 'member') {
            return true;
        }
        return false;
    }
    convertKeyToRefract(key, item) {
        if (this.shouldRefract(item)) {
            return this.serialise(item);
        }
        if (item.element === 'enum') {
            return this.serialiseEnum(item);
        }
        if (item.element === 'array') {
            return item.map((subItem)=>{
                if (this.shouldRefract(subItem) || key === 'default') {
                    return this.serialise(subItem);
                }
                if (subItem.element === 'array' || subItem.element === 'object' || subItem.element === 'enum') {
                    // items for array or enum inside array are always serialised
                    return subItem.children.map((subSubItem)=>this.serialise(subSubItem));
                }
                return subItem.toValue();
            });
        }
        if (item.element === 'object') {
            return (item.content || []).map(this.serialise, this);
        }
        return item.toValue();
    }
    serialiseEnum(element) {
        return element.children.map((item)=>this.serialise(item));
    }
    serialiseObject(obj) {
        const result = {};
        obj.forEach((value, key)=>{
            if (value) {
                const keyValue = key.toValue();
                result[keyValue] = this.convertKeyToRefract(keyValue, value);
            }
        });
        return result;
    }
    deserialiseObject(from, to) {
        Object.keys(from).forEach((key)=>{
            to.set(key, this.deserialise(from[key]));
        });
    }
};
}),
"[project]/node_modules/minim/lib/minim.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const Namespace = __turbopack_context__.r("[project]/node_modules/minim/lib/Namespace.js [app-client] (ecmascript)");
const elements = __turbopack_context__.r("[project]/node_modules/minim/lib/elements.js [app-client] (ecmascript)");
// Direct access to the Namespace class
exports.Namespace = Namespace;
// Special constructor for the Namespace class
exports.namespace = function namespace(options) {
    return new Namespace(options);
};
exports.KeyValuePair = __turbopack_context__.r("[project]/node_modules/minim/lib/KeyValuePair.js [app-client] (ecmascript)");
exports.ArraySlice = elements.ArraySlice;
exports.ObjectSlice = elements.ObjectSlice;
exports.Element = elements.Element;
exports.StringElement = elements.StringElement;
exports.NumberElement = elements.NumberElement;
exports.BooleanElement = elements.BooleanElement;
exports.NullElement = elements.NullElement;
exports.ArrayElement = elements.ArrayElement;
exports.ObjectElement = elements.ObjectElement;
exports.MemberElement = elements.MemberElement;
exports.RefElement = elements.RefElement;
exports.LinkElement = elements.LinkElement;
exports.refract = elements.refract;
exports.JSONSerialiser = __turbopack_context__.r("[project]/node_modules/minim/lib/serialisers/JSONSerialiser.js [app-client] (ecmascript)");
exports.JSON06Serialiser = __turbopack_context__.r("[project]/node_modules/minim/lib/serialisers/JSON06Serialiser.js [app-client] (ecmascript)");
}),
"[project]/node_modules/apg-lite/lib/parser.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*  *************************************************************************************
 *   copyright: Copyright (c) 2023 Lowell D. Thomas, all rights reserved
 *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)
 *
 *    Redistribution and use in source and binary forms, with or without
 *    modification, are permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this
 *       list of conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice,
 *       this list of conditions and the following disclaimer in the documentation
 *       and/or other materials provided with the distribution.
 *
 *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 *    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *    FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *    DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *    OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *   ********************************************************************************* */ __turbopack_context__.s([
    "Ast",
    ()=>Ast,
    "Parser",
    ()=>Parser,
    "Stats",
    ()=>Stats,
    "Trace",
    ()=>Trace,
    "identifiers",
    ()=>identifiers,
    "utilities",
    ()=>utilities
]);
;
const Parser = function fnparser() {
    const id = identifiers;
    const utils = utilities;
    const p = this;
    const thisFileName = 'parser.js: Parser(): ';
    const systemData = function systemData() {
        this.state = id.ACTIVE;
        this.phraseLength = 0;
        this.refresh = ()=>{
            this.state = id.ACTIVE;
            this.phraseLength = 0;
        };
    };
    p.ast = undefined;
    p.stats = undefined;
    p.trace = undefined;
    p.callbacks = [];
    let lookAhead = 0;
    let treeDepth = 0;
    let maxTreeDepth = 0;
    let nodeHits = 0;
    let maxMatched = 0;
    let rules = undefined;
    let udts = undefined;
    let opcodes = undefined;
    let chars = undefined;
    let sysData = new systemData();
    let ruleCallbacks = undefined;
    let udtCallbacks = undefined;
    let userData = undefined;
    const clear = ()=>{
        lookAhead = 0;
        treeDepth = 0;
        maxTreeDepth = 0;
        nodeHits = 0;
        maxMatched = 0;
        rules = undefined;
        udts = undefined;
        opcodes = undefined;
        chars = undefined;
        sysData.refresh();
        ruleCallbacks = undefined;
        udtCallbacks = undefined;
        userData = undefined;
    };
    const initializeCallbacks = ()=>{
        const functionName = `${thisFileName}initializeCallbacks(): `;
        let i;
        ruleCallbacks = [];
        udtCallbacks = [];
        for(i = 0; i < rules.length; i += 1){
            ruleCallbacks[i] = undefined;
        }
        for(i = 0; i < udts.length; i += 1){
            udtCallbacks[i] = undefined;
        }
        let func;
        const list = [];
        for(i = 0; i < rules.length; i += 1){
            list.push(rules[i].lower);
        }
        for(i = 0; i < udts.length; i += 1){
            list.push(udts[i].lower);
        }
        for(const index in p.callbacks){
            if (p.callbacks.hasOwnProperty(index)) {
                i = list.indexOf(index.toLowerCase());
                if (i < 0) {
                    throw new Error(`${functionName}syntax callback '${index}' not a rule or udt name`);
                }
                func = p.callbacks[index] ? p.callbacks[index] : undefined;
                if (typeof func === 'function' || func === undefined) {
                    if (i < rules.length) {
                        ruleCallbacks[i] = func;
                    } else {
                        udtCallbacks[i - rules.length] = func;
                    }
                } else {
                    throw new Error(`${functionName}syntax callback[${index}] must be function reference or falsy)`);
                }
            }
        }
    };
    p.parse = (grammar, startName, inputString, callbackData)=>{
        const functionName = `${thisFileName}parse(): `;
        clear();
        chars = utils.stringToChars(inputString);
        rules = grammar.rules;
        udts = grammar.udts;
        const lower = startName.toLowerCase();
        let startIndex = undefined;
        for(const i in rules){
            if (rules.hasOwnProperty(i)) {
                if (lower === rules[i].lower) {
                    startIndex = rules[i].index;
                    break;
                }
            }
        }
        if (startIndex === undefined) {
            throw new Error(`${functionName}start rule name '${startRule}' not recognized`);
        }
        initializeCallbacks();
        if (p.trace) {
            p.trace.init(rules, udts, chars);
        }
        if (p.stats) {
            p.stats.init(rules, udts);
        }
        if (p.ast) {
            p.ast.init(rules, udts, chars);
        }
        userData = callbackData;
        /* create a dummy opcode for the start rule */ opcodes = [
            {
                type: id.RNM,
                index: startIndex
            }
        ];
        /* execute the start rule */ opExecute(0, 0);
        opcodes = undefined;
        /* test and return the sysData */ let success = false;
        switch(sysData.state){
            case id.ACTIVE:
                throw new Error(`${functionName}final state should never be 'ACTIVE'`);
            case id.NOMATCH:
                success = false;
                break;
            case id.EMPTY:
            case id.MATCH:
                if (sysData.phraseLength === chars.length) {
                    success = true;
                } else {
                    success = false;
                }
                break;
            default:
                throw new Error('unrecognized state');
        }
        return {
            success,
            state: sysData.state,
            stateName: id.idName(sysData.state),
            length: chars.length,
            matched: sysData.phraseLength,
            maxMatched,
            maxTreeDepth,
            nodeHits
        };
    };
    // The `ALT` operator.<br>
    // Executes its child nodes, from left to right, until it finds a match.
    // Fails if *all* of its child nodes fail.
    const opALT = (opIndex, phraseIndex)=>{
        const op = opcodes[opIndex];
        for(let i = 0; i < op.children.length; i += 1){
            opExecute(op.children[i], phraseIndex);
            if (sysData.state !== id.NOMATCH) {
                break;
            }
        }
    };
    // The `CAT` operator.<br>
    // Executes all of its child nodes, from left to right,
    // concatenating the matched phrases.
    // Fails if *any* child nodes fail.
    const opCAT = (opIndex, phraseIndex)=>{
        let success;
        let astLength;
        let catCharIndex;
        let catPhrase;
        const op = opcodes[opIndex];
        if (p.ast) {
            astLength = p.ast.getLength();
        }
        success = true;
        catCharIndex = phraseIndex;
        catPhrase = 0;
        for(let i = 0; i < op.children.length; i += 1){
            opExecute(op.children[i], catCharIndex);
            if (sysData.state === id.NOMATCH) {
                success = false;
                break;
            } else {
                catCharIndex += sysData.phraseLength;
                catPhrase += sysData.phraseLength;
            }
        }
        if (success) {
            sysData.state = catPhrase === 0 ? id.EMPTY : id.MATCH;
            sysData.phraseLength = catPhrase;
        } else {
            sysData.state = id.NOMATCH;
            sysData.phraseLength = 0;
            if (p.ast) {
                p.ast.setLength(astLength);
            }
        }
    };
    // The `REP` operator.<br>
    // Repeatedly executes its single child node,
    // concatenating each of the matched phrases found.
    // The number of repetitions executed and its final sysData depends
    // on its `min` & `max` repetition values.
    const opREP = (opIndex, phraseIndex)=>{
        let astLength;
        let repCharIndex;
        let repPhrase;
        let repCount;
        const op = opcodes[opIndex];
        if (op.max === 0) {
            // this is an empty-string acceptor
            // deprecated: use the TLS empty string operator, "", instead
            sysData.state = id.EMPTY;
            sysData.phraseLength = 0;
            return;
        }
        repCharIndex = phraseIndex;
        repPhrase = 0;
        repCount = 0;
        if (p.ast) {
            astLength = p.ast.getLength();
        }
        while(1){
            if (repCharIndex >= chars.length) {
                break;
            }
            opExecute(opIndex + 1, repCharIndex);
            if (sysData.state === id.NOMATCH) {
                break;
            }
            if (sysData.state === id.EMPTY) {
                break;
            }
            repCount += 1;
            repPhrase += sysData.phraseLength;
            repCharIndex += sysData.phraseLength;
            if (repCount === op.max) {
                break;
            }
        }
        /* evaluate the match count according to the min, max values */ if (sysData.state === id.EMPTY) {
            sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;
            sysData.phraseLength = repPhrase;
        } else if (repCount >= op.min) {
            sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;
            sysData.phraseLength = repPhrase;
        } else {
            sysData.state = id.NOMATCH;
            sysData.phraseLength = 0;
            if (p.ast) {
                p.ast.setLength(astLength);
            }
        }
    };
    // Validate the callback function's returned sysData values.
    // It's the user's responsibility to get them right
    // but `RNM` fails if not.
    const validateRnmCallbackResult = (rule, sysData, charsLeft, down)=>{
        if (sysData.phraseLength > charsLeft) {
            let str = `${thisFileName}opRNM(${rule.name}): callback function error: `;
            str += `sysData.phraseLength: ${sysData.phraseLength}`;
            str += ` must be <= remaining chars: ${charsLeft}`;
            throw new Error(str);
        }
        switch(sysData.state){
            case id.ACTIVE:
                if (!down) {
                    throw new Error(`${thisFileName}opRNM(${rule.name}): callback function return error. ACTIVE state not allowed.`);
                }
                break;
            case id.EMPTY:
                sysData.phraseLength = 0;
                break;
            case id.MATCH:
                if (sysData.phraseLength === 0) {
                    sysData.state = id.EMPTY;
                }
                break;
            case id.NOMATCH:
                sysData.phraseLength = 0;
                break;
            default:
                throw new Error(`${thisFileName}opRNM(${rule.name}): callback function return error. Unrecognized return state: ${sysData.state}`);
        }
    };
    // The `RNM` operator.<br>
    // This operator will acts as a root node for a parse tree branch below and
    // returns the matched phrase to its parent.
    // However, its larger responsibility is handling user-defined callback functions and `AST` nodes.
    // Note that the `AST` is a separate object, but `RNM` calls its functions to create its nodes.
    const opRNM = (opIndex, phraseIndex)=>{
        let astLength;
        let astDefined;
        let savedOpcodes;
        const op = opcodes[opIndex];
        const rule = rules[op.index];
        const callback = ruleCallbacks[rule.index];
        /* ignore AST in look ahead (AND or NOT operator above) */ if (!lookAhead) {
            astDefined = p.ast && p.ast.ruleDefined(op.index);
            if (astDefined) {
                astLength = p.ast.getLength();
                p.ast.down(op.index, rules[op.index].name);
            }
        }
        if (callback) {
            /* call user's callback going down the parse tree*/ const charsLeft = chars.length - phraseIndex;
            callback(sysData, chars, phraseIndex, userData);
            validateRnmCallbackResult(rule, sysData, charsLeft, true);
            if (sysData.state === id.ACTIVE) {
                savedOpcodes = opcodes;
                opcodes = rule.opcodes;
                opExecute(0, phraseIndex);
                opcodes = savedOpcodes;
                /* call user's callback going up the parse tree*/ callback(sysData, chars, phraseIndex, userData);
                validateRnmCallbackResult(rule, sysData, charsLeft, false);
            } /* implied else clause: just accept the callback sysData - RNM acting as UDT */ 
        } else {
            /* no callback - just execute the rule */ savedOpcodes = opcodes;
            opcodes = rule.opcodes;
            opExecute(0, phraseIndex, sysData);
            opcodes = savedOpcodes;
        }
        if (!lookAhead) {
            /* end AST */ if (astDefined) {
                if (sysData.state === id.NOMATCH) {
                    p.ast.setLength(astLength);
                } else {
                    p.ast.up(op.index, rule.name, phraseIndex, sysData.phraseLength);
                }
            }
        }
    };
    // The `TRG` operator.<br>
    // Succeeds if the single first character of the phrase is
    // within the `min - max` range.
    const opTRG = (opIndex, phraseIndex)=>{
        const op = opcodes[opIndex];
        sysData.state = id.NOMATCH;
        if (phraseIndex < chars.length) {
            if (op.min <= chars[phraseIndex] && chars[phraseIndex] <= op.max) {
                sysData.state = id.MATCH;
                sysData.phraseLength = 1;
            }
        }
    };
    // The `TBS` operator.<br>
    // Matches its pre-defined phrase against the input string.
    // All characters must match exactly.
    // Case-sensitive literal strings (`'string'` & `%s"string"`) are translated to `TBS`
    // operators by `apg`.
    // Phrase length of zero is not allowed.
    // Empty phrases can only be defined with `TLS` operators.
    const opTBS = (opIndex, phraseIndex)=>{
        const op = opcodes[opIndex];
        const len = op.string.length;
        sysData.state = id.NOMATCH;
        if (phraseIndex + len <= chars.length) {
            for(let i = 0; i < len; i += 1){
                if (chars[phraseIndex + i] !== op.string[i]) {
                    return;
                }
            }
            sysData.state = id.MATCH;
            sysData.phraseLength = len;
        } /* implied else NOMATCH */ 
    };
    // The `TLS` operator.<br>
    // Matches its pre-defined phrase against the input string.
    // A case-insensitive match is attempted for ASCII alphbetical characters.
    // `TLS` is the only operator that explicitly allows empty phrases.
    // `apg` will fail for empty `TBS`, case-sensitive strings (`''`) or
    // zero repetitions (`0*0RuleName` or `0RuleName`).
    const opTLS = (opIndex, phraseIndex)=>{
        let code;
        const op = opcodes[opIndex];
        sysData.state = id.NOMATCH;
        const len = op.string.length;
        if (len === 0) {
            /* EMPTY match allowed for TLS */ sysData.state = id.EMPTY;
            return;
        }
        if (phraseIndex + len <= chars.length) {
            for(let i = 0; i < len; i += 1){
                code = chars[phraseIndex + i];
                if (code >= 65 && code <= 90) {
                    code += 32;
                }
                if (code !== op.string[i]) {
                    return;
                }
            }
            sysData.state = id.MATCH;
            sysData.phraseLength = len;
        } /* implied else NOMATCH */ 
    };
    // Validate the callback function's returned sysData values.
    // It's the user's responsibility to get it right but `UDT` fails if not.
    const validateUdtCallbackResult = (udt, sysData, charsLeft)=>{
        if (sysData.phraseLength > charsLeft) {
            let str = `${thisFileName}opUDT(${udt.name}): callback function error: `;
            str += `sysData.phraseLength: ${sysData.phraseLength}`;
            str += ` must be <= remaining chars: ${charsLeft}`;
            throw new Error(str);
        }
        switch(sysData.state){
            case id.ACTIVE:
                throw new Error(`${thisFileName}opUDT(${udt.name}) ACTIVE state return not allowed.`);
            case id.EMPTY:
                if (udt.empty) {
                    sysData.phraseLength = 0;
                } else {
                    throw new Error(`${thisFileName}opUDT(${udt.name}) may not return EMPTY.`);
                }
                break;
            case id.MATCH:
                if (sysData.phraseLength === 0) {
                    if (udt.empty) {
                        sysData.state = id.EMPTY;
                    } else {
                        throw new Error(`${thisFileName}opUDT(${udt.name}) may not return EMPTY.`);
                    }
                }
                break;
            case id.NOMATCH:
                sysData.phraseLength = 0;
                break;
            default:
                throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. Unrecognized return state: ${sysData.state}`);
        }
    };
    // The `UDT` operator.<br>
    // Simply calls the user's callback function, but operates like `RNM` with regard to the `AST`
    // and back referencing.
    // There is some ambiguity here. `UDT`s act as terminals for phrase recognition but as named rules
    // for `AST` nodes and back referencing.
    // See [`ast.js`](./ast.html) for usage.
    const opUDT = (opIndex, phraseIndex)=>{
        let astLength;
        let astIndex;
        let astDefined;
        const op = opcodes[opIndex];
        const udt = udts[op.index];
        sysData.UdtIndex = udt.index;
        /* ignore AST in look ahead */ if (!lookAhead) {
            astDefined = p.ast && p.ast.udtDefined(op.index);
            if (astDefined) {
                astIndex = rules.length + op.index;
                astLength = p.ast.getLength();
                p.ast.down(astIndex, udt.name);
            }
        }
        /* call the UDT */ const charsLeft = chars.length - phraseIndex;
        udtCallbacks[op.index](sysData, chars, phraseIndex, userData);
        validateUdtCallbackResult(udt, sysData, charsLeft);
        if (!lookAhead) {
            /* end AST */ if (astDefined) {
                if (sysData.state === id.NOMATCH) {
                    p.ast.setLength(astLength);
                } else {
                    p.ast.up(astIndex, udt.name, phraseIndex, sysData.phraseLength);
                }
            }
        }
    };
    // The `AND` operator.<br>
    // This is the positive `look ahead` operator.
    // Executes its single child node, returning the EMPTY state
    // if it succeedsand NOMATCH if it fails.
    // *Always* backtracks on any matched phrase and returns EMPTY on success.
    const opAND = (opIndex, phraseIndex)=>{
        lookAhead += 1;
        opExecute(opIndex + 1, phraseIndex);
        lookAhead -= 1;
        sysData.phraseLength = 0;
        switch(sysData.state){
            case id.EMPTY:
                sysData.state = id.EMPTY;
                break;
            case id.MATCH:
                sysData.state = id.EMPTY;
                break;
            case id.NOMATCH:
                sysData.state = id.NOMATCH;
                break;
            default:
                throw new Error(`opAND: invalid state ${sysData.state}`);
        }
    };
    // The `NOT` operator.<br>
    // This is the negative `look ahead` operator.
    // Executes its single child node, returning the EMPTY state
    // if it *fails* and NOMATCH if it succeeds.
    // *Always* backtracks on any matched phrase and returns EMPTY
    // on success (failure of its child node).
    const opNOT = (opIndex, phraseIndex)=>{
        lookAhead += 1;
        opExecute(opIndex + 1, phraseIndex);
        lookAhead -= 1;
        sysData.phraseLength = 0;
        switch(sysData.state){
            case id.EMPTY:
            case id.MATCH:
                sysData.state = id.NOMATCH;
                break;
            case id.NOMATCH:
                sysData.state = id.EMPTY;
                break;
            default:
                throw new Error(`opNOT: invalid state ${sysData.state}`);
        }
    };
    const opExecute = (opIndex, phraseIndex)=>{
        const functionName = `${thisFileName}opExecute(): `;
        const op = opcodes[opIndex];
        nodeHits += 1;
        if (treeDepth > maxTreeDepth) {
            maxTreeDepth = treeDepth;
        }
        treeDepth += 1;
        sysData.refresh();
        if (p.trace) {
            p.trace.down(op, phraseIndex);
        }
        switch(op.type){
            case id.ALT:
                opALT(opIndex, phraseIndex);
                break;
            case id.CAT:
                opCAT(opIndex, phraseIndex);
                break;
            case id.REP:
                opREP(opIndex, phraseIndex);
                break;
            case id.RNM:
                opRNM(opIndex, phraseIndex);
                break;
            case id.TRG:
                opTRG(opIndex, phraseIndex);
                break;
            case id.TBS:
                opTBS(opIndex, phraseIndex);
                break;
            case id.TLS:
                opTLS(opIndex, phraseIndex);
                break;
            case id.UDT:
                opUDT(opIndex, phraseIndex);
                break;
            case id.AND:
                opAND(opIndex, phraseIndex);
                break;
            case id.NOT:
                opNOT(opIndex, phraseIndex);
                break;
            default:
                throw new Error(`${functionName}unrecognized operator`);
        }
        if (!lookAhead) {
            if (phraseIndex + sysData.phraseLength > maxMatched) {
                maxMatched = phraseIndex + sysData.phraseLength;
            }
        }
        if (p.stats) {
            p.stats.collect(op, sysData);
        }
        if (p.trace) {
            p.trace.up(op, sysData.state, phraseIndex, sysData.phraseLength);
        }
        treeDepth -= 1;
    };
};
const Ast = function fnast() {
    const thisFileName = 'parser.js: Ast()): ';
    const id = identifiers;
    const utils = utilities;
    const a = this;
    let rules = undefined;
    let udts = undefined;
    let chars = undefined;
    let nodeCount = 0;
    const nodeCallbacks = [];
    const stack = [];
    const records = [];
    a.callbacks = [];
    /* called by the parser to initialize the AST with the rules, UDTs and the input characters */ a.init = (rulesIn, udtsIn, charsIn)=>{
        stack.length = 0;
        records.length = 0;
        nodeCount = 0;
        rules = rulesIn;
        udts = udtsIn;
        chars = charsIn;
        let i;
        const list = [];
        for(i = 0; i < rules.length; i += 1){
            list.push(rules[i].lower);
        }
        for(i = 0; i < udts.length; i += 1){
            list.push(udts[i].lower);
        }
        nodeCount = rules.length + udts.length;
        for(i = 0; i < nodeCount; i += 1){
            nodeCallbacks[i] = undefined;
        }
        for(const index in a.callbacks){
            if (a.callbacks.hasOwnProperty(index)) {
                const lower = index.toLowerCase();
                i = list.indexOf(lower);
                if (i < 0) {
                    throw new Error(`${thisFileName}init: node '${index}' not a rule or udt name`);
                }
                nodeCallbacks[i] = a.callbacks[index];
            }
        }
    };
    /* AST node rule callbacks - called by the parser's `RNM` operator */ a.ruleDefined = (index)=>!!nodeCallbacks[index];
    /* AST node UDT callbacks - called by the parser's `UDT` operator */ a.udtDefined = (index)=>!!nodeCallbacks[rules.length + index];
    /* called by the parser's `RNM` & `UDT` operators
     builds a record for the downward traversal of the node */ a.down = (callbackIndex, name)=>{
        const thisIndex = records.length;
        stack.push(thisIndex);
        records.push({
            name,
            thisIndex,
            thatIndex: undefined,
            state: id.SEM_PRE,
            callbackIndex,
            phraseIndex: undefined,
            phraseLength: undefined,
            stack: stack.length
        });
        return thisIndex;
    };
    /* called by the parser's `RNM` & `UDT` operators */ /* builds a record for the upward traversal of the node */ a.up = (callbackIndex, name, phraseIndex, phraseLength)=>{
        const thisIndex = records.length;
        const thatIndex = stack.pop();
        records.push({
            name,
            thisIndex,
            thatIndex,
            state: id.SEM_POST,
            callbackIndex,
            phraseIndex,
            phraseLength,
            stack: stack.length
        });
        records[thatIndex].thatIndex = thisIndex;
        records[thatIndex].phraseIndex = phraseIndex;
        records[thatIndex].phraseLength = phraseLength;
        return thisIndex;
    };
    // Called by the user to translate the AST.
    // Translate means to associate or apply some semantic action to the
    // phrases that were syntactically matched to the AST nodes according
    // to the defining grammar.
    // ```
    // data - optional user-defined data
    //        passed to the callback functions by the translator
    // ```
    a.translate = (data)=>{
        let ret;
        let callback;
        let record;
        for(let i = 0; i < records.length; i += 1){
            record = records[i];
            callback = nodeCallbacks[record.callbackIndex];
            if (callback) {
                if (record.state === id.SEM_PRE) {
                    callback(id.SEM_PRE, chars, record.phraseIndex, record.phraseLength, data);
                } else if (callback) {
                    callback(id.SEM_POST, chars, record.phraseIndex, record.phraseLength, data);
                }
            }
        }
    };
    /* called by the parser to reset the length of the records array */ /* necessary on backtracking */ a.setLength = (length)=>{
        records.length = length;
        if (length > 0) {
            stack.length = records[length - 1].stack;
        } else {
            stack.length = 0;
        }
    };
    /* called by the parser to get the length of the records array */ a.getLength = ()=>records.length;
    /* helper for XML display */ function indent(n) {
        let ret = '';
        while(n-- > 0){
            ret += ' ';
        }
        return ret;
    }
    // Generate an `XML` version of the AST.
    // Useful if you want to use a special or favorite XML parser to translate the
    // AST. Node data are JavaScript strings.
    a.toXml = ()=>{
        let xml = '';
        let depth = 0;
        xml += '<?xml version="1.0" encoding="utf-8"?>\n';
        xml += `<root nodes="${records.length / 2}" characters="${chars.length}">\n`;
        xml += `<!-- input string -->\n`;
        xml += indent(depth + 2);
        xml += utils.charsToString(chars);
        xml += '\n';
        records.forEach((rec)=>{
            if (rec.state === id.SEM_PRE) {
                depth += 1;
                xml += indent(depth);
                xml += `<node name="${rec.name}" index="${rec.phraseIndex}" length="${rec.phraseLength}">\n`;
                xml += indent(depth + 2);
                xml += utils.charsToString(chars, rec.phraseIndex, rec.phraseLength);
                xml += '\n';
            } else {
                xml += indent(depth);
                xml += `</node><!-- name="${rec.name}" -->\n`;
                depth -= 1;
            }
        });
        xml += '</root>\n';
        return xml;
    };
};
const Trace = function fntrace() {
    const id = identifiers;
    const utils = utilities;
    const thisFile = 'parser.js: Trace(): ';
    let chars = undefined;
    let rules = undefined;
    let udts = undefined;
    let out = '';
    let treeDepth = 0;
    const MAX_PHRASE = 100;
    const t = this;
    const indent = (n)=>{
        let ret = '';
        let count = 0;
        if (n >= 0) {
            while(n--){
                count += 1;
                if (count === 5) {
                    ret += '|';
                    count = 0;
                } else {
                    ret += '.';
                }
            }
        }
        return ret;
    };
    t.init = (r, u, c)=>{
        rules = r;
        udts = u;
        chars = c;
    };
    const opName = (op)=>{
        let name;
        switch(op.type){
            case id.ALT:
                name = 'ALT';
                break;
            case id.CAT:
                name = 'CAT';
                break;
            case id.REP:
                if (op.max === Infinity) {
                    name = `REP(${op.min},inf)`;
                } else {
                    name = `REP(${op.min},${op.max})`;
                }
                break;
            case id.RNM:
                name = `RNM(${rules[op.index].name})`;
                break;
            case id.TRG:
                name = `TRG(${op.min},${op.max})`;
                break;
            case id.TBS:
                if (op.string.length > 6) {
                    name = `TBS(${utils.charsToString(op.string, 0, 3)}...)`;
                } else {
                    name = `TBS(${utils.charsToString(op.string, 0, 6)})`;
                }
                break;
            case id.TLS:
                if (op.string.length > 6) {
                    name = `TLS(${utils.charsToString(op.string, 0, 3)}...)`;
                } else {
                    name = `TLS(${utils.charsToString(op.string, 0, 6)})`;
                }
                break;
            case id.UDT:
                name = `UDT(${udts[op.index].name})`;
                break;
            case id.AND:
                name = 'AND';
                break;
            case id.NOT:
                name = 'NOT';
                break;
            default:
                throw new Error(`${thisFile}Trace: opName: unrecognized opcode`);
        }
        return name;
    };
    t.down = (op, offset)=>{
        const lead = indent(treeDepth);
        const len = Math.min(MAX_PHRASE, chars.length - offset);
        let phrase = utils.charsToString(chars, offset, len);
        if (len < chars.length - offset) {
            phrase += '...';
        }
        phrase = `${lead}|-|[${opName(op)}]${phrase}\n`;
        out += phrase;
        treeDepth += 1;
    };
    t.up = (op, state, offset, phraseLength)=>{
        const thisFunc = `${thisFile}trace.up: `;
        treeDepth -= 1;
        const lead = indent(treeDepth);
        let len;
        let phrase;
        let st;
        switch(state){
            case id.EMPTY:
                st = '|E|';
                phrase = `''`;
                break;
            case id.MATCH:
                st = '|M|';
                len = Math.min(MAX_PHRASE, phraseLength);
                if (len < phraseLength) {
                    phrase = `'${utils.charsToString(chars, offset, len)}...'`;
                } else {
                    phrase = `'${utils.charsToString(chars, offset, len)}'`;
                }
                break;
            case id.NOMATCH:
                st = '|N|';
                phrase = '';
                break;
            default:
                throw new Error(`${thisFunc} unrecognized state`);
        }
        phrase = `${lead}${st}[${opName(op)}]${phrase}\n`;
        out += phrase;
    };
    t.displayTrace = ()=>out;
};
const Stats = function fnstats() {
    const id = identifiers;
    const thisFileName = 'parser.js: Stats(): ';
    let rules;
    let udts;
    let totals;
    const stats = [];
    const ruleStats = [];
    const udtStats = [];
    /* called by parser to initialize the stats */ this.init = (r, u)=>{
        rules = r;
        udts = u;
        clear();
    };
    /* This function is the main interaction with the parser. */ /* The parser calls it after each node has been traversed. */ this.collect = (op, sys)=>{
        incStat(totals, sys.state, sys.phraseLength);
        incStat(stats[op.type], sys.state, sys.phraseLength);
        if (op.type === id.RNM) {
            incStat(ruleStats[op.index], sys.state, sys.phraseLength);
        }
        if (op.type === id.UDT) {
            incStat(udtStats[op.index], sys.state, sys.phraseLength);
        }
    };
    this.displayStats = ()=>{
        let out = '';
        const totals = {
            match: 0,
            empty: 0,
            nomatch: 0,
            total: 0
        };
        const displayRow = (op, m, e, n, t)=>{
            totals.match += m;
            totals.empty += e;
            totals.nomatch += n;
            totals.total += t;
            const mm = normalize(m);
            const ee = normalize(e);
            const nn = normalize(n);
            const tt = normalize(t);
            return `${op} | ${mm} | ${ee} | ${nn} | ${tt} |\n`;
        };
        out += '          OPERATOR STATS\n';
        out += '      |   MATCH |   EMPTY | NOMATCH |   TOTAL |\n';
        out += displayRow('  ALT', stats[id.ALT].match, stats[id.ALT].empty, stats[id.ALT].nomatch, stats[id.ALT].total);
        out += displayRow('  CAT', stats[id.CAT].match, stats[id.CAT].empty, stats[id.CAT].nomatch, stats[id.CAT].total);
        out += displayRow('  REP', stats[id.REP].match, stats[id.REP].empty, stats[id.REP].nomatch, stats[id.REP].total);
        out += displayRow('  RNM', stats[id.RNM].match, stats[id.RNM].empty, stats[id.RNM].nomatch, stats[id.RNM].total);
        out += displayRow('  TRG', stats[id.TRG].match, stats[id.TRG].empty, stats[id.TRG].nomatch, stats[id.TRG].total);
        out += displayRow('  TBS', stats[id.TBS].match, stats[id.TBS].empty, stats[id.TBS].nomatch, stats[id.TBS].total);
        out += displayRow('  TLS', stats[id.TLS].match, stats[id.TLS].empty, stats[id.TLS].nomatch, stats[id.TLS].total);
        out += displayRow('  UDT', stats[id.UDT].match, stats[id.UDT].empty, stats[id.UDT].nomatch, stats[id.UDT].total);
        out += displayRow('  AND', stats[id.AND].match, stats[id.AND].empty, stats[id.AND].nomatch, stats[id.AND].total);
        out += displayRow('  NOT', stats[id.NOT].match, stats[id.NOT].empty, stats[id.NOT].nomatch, stats[id.NOT].total);
        out += displayRow('TOTAL', totals.match, totals.empty, totals.nomatch, totals.total);
        return out;
    };
    /*
  Display rule/udt
  */ this.displayHits = (type)=>{
        let out = '';
        const displayRow = (m, e, n, t, name)=>{
            totals.match += m;
            totals.empty += e;
            totals.nomatch += n;
            totals.total += t;
            const mm = normalize(m);
            const ee = normalize(e);
            const nn = normalize(n);
            const tt = normalize(t);
            return `| ${mm} | ${ee} | ${nn} | ${tt} | ${name}\n`;
        };
        if (typeof type === 'string' && type.toLowerCase()[0] === 'a') {
            ruleStats.sort(sortAlpha);
            udtStats.sort(sortAlpha);
            out += '    RULES/UDTS ALPHABETICALLY\n';
        } else if (typeof type === 'string' && type.toLowerCase()[0] === 'i') {
            ruleStats.sort(sortIndex);
            udtStats.sort(sortIndex);
            out += '    RULES/UDTS BY INDEX\n';
        } else {
            ruleStats.sort(sortHits);
            udtStats.sort(sortHits);
            out += '    RULES/UDTS BY HIT COUNT\n';
        }
        out += '|   MATCH |   EMPTY | NOMATCH |   TOTAL | NAME\n';
        for(let i = 0; i < ruleStats.length; i += 1){
            let r = ruleStats[i];
            if (r.total) {
                out += displayRow(r.match, r.empty, r.nomatch, r.total, r.name);
            }
        }
        for(let i = 0; i < udtStats.length; i += 1){
            let r = udtStats[i];
            if (r.total) {
                out += displayRow(r.match, r.empty, r.nomatch, r.total, r.name);
            }
        }
        return out;
    };
    const normalize = (n)=>{
        if (n < 10) {
            return `      ${n}`;
        }
        if (n < 100) {
            return `     ${n}`;
        }
        if (n < 1000) {
            return `    ${n}`;
        }
        if (n < 10000) {
            return `   ${n}`;
        }
        if (n < 100000) {
            return `  ${n}`;
        }
        if (n < 1000000) {
            return ` ${n}`;
        }
        return `${n}`;
    };
    const sortAlpha = (lhs, rhs)=>{
        if (lhs.lower < rhs.lower) {
            return -1;
        }
        if (lhs.lower > rhs.lower) {
            return 1;
        }
        return 0;
    };
    const sortHits = (lhs, rhs)=>{
        if (lhs.total < rhs.total) {
            return 1;
        }
        if (lhs.total > rhs.total) {
            return -1;
        }
        return sortAlpha(lhs, rhs);
    };
    const sortIndex = (lhs, rhs)=>{
        if (lhs.index < rhs.index) {
            return -1;
        }
        if (lhs.index > rhs.index) {
            return 1;
        }
        return 0;
    };
    const EmptyStat = function fnempty() {
        this.empty = 0;
        this.match = 0;
        this.nomatch = 0;
        this.total = 0;
    };
    /* Zero out all stats */ const clear = ()=>{
        stats.length = 0;
        totals = new EmptyStat();
        stats[id.ALT] = new EmptyStat();
        stats[id.CAT] = new EmptyStat();
        stats[id.REP] = new EmptyStat();
        stats[id.RNM] = new EmptyStat();
        stats[id.TRG] = new EmptyStat();
        stats[id.TBS] = new EmptyStat();
        stats[id.TLS] = new EmptyStat();
        stats[id.UDT] = new EmptyStat();
        stats[id.AND] = new EmptyStat();
        stats[id.NOT] = new EmptyStat();
        ruleStats.length = 0;
        for(let i = 0; i < rules.length; i += 1){
            ruleStats.push({
                empty: 0,
                match: 0,
                nomatch: 0,
                total: 0,
                name: rules[i].name,
                lower: rules[i].lower,
                index: rules[i].index
            });
        }
        if (udts.length > 0) {
            udtStats.length = 0;
            for(let i = 0; i < udts.length; i += 1){
                udtStats.push({
                    empty: 0,
                    match: 0,
                    nomatch: 0,
                    total: 0,
                    name: udts[i].name,
                    lower: udts[i].lower,
                    index: udts[i].index
                });
            }
        }
    };
    /* increment the designated operator hit count by one */ const incStat = (stat, state)=>{
        stat.total += 1;
        switch(state){
            case id.EMPTY:
                stat.empty += 1;
                break;
            case id.MATCH:
                stat.match += 1;
                break;
            case id.NOMATCH:
                stat.nomatch += 1;
                break;
            default:
                throw new Error(`${thisFileName}collect(): incStat(): unrecognized state: ${state}`);
        }
    };
};
const utilities = {
    // utility functions
    stringToChars: (string)=>[
            ...string
        ].map((cp)=>cp.codePointAt(0)),
    charsToString: (chars, beg, len)=>{
        let subChars = chars;
        while(1){
            if (beg === undefined || beg < 0) {
                break;
            }
            if (len === undefined) {
                subChars = chars.slice(beg);
                break;
            }
            if (len <= 0) {
                // always an empty string
                return '';
            }
            subChars = chars.slice(beg, beg + len);
            break;
        }
        return String.fromCodePoint(...subChars);
    }
};
const identifiers = {
    // Identifies the operator type.
    // NB: These must match the values in apg-js 4.3.0, apg-lib/identifiers.
    /* the original ABNF operators */ ALT: 1 /* alternation */ ,
    CAT: 2 /* concatenation */ ,
    REP: 3 /* repetition */ ,
    RNM: 4 /* rule name */ ,
    TRG: 5 /* terminal range */ ,
    TBS: 6 /* terminal binary string, case sensitive */ ,
    TLS: 7 /* terminal literal string, case insensitive */ ,
    /* the super set, SABNF operators */ UDT: 11 /* user-defined terminal */ ,
    AND: 12 /* positive look ahead */ ,
    NOT: 13 /* negative look ahead */ ,
    // Used by the parser and the user's `RNM` and `UDT` callback functions.
    // Identifies the parser state as it traverses the parse tree nodes.
    // - *ACTIVE* - indicates the downward direction through the parse tree node.
    // - *MATCH* - indicates the upward direction and a phrase, of length \> 0, has been successfully matched
    // - *EMPTY* - indicates the upward direction and a phrase, of length = 0, has been successfully matched
    // - *NOMATCH* - indicates the upward direction and the parser failed to match any phrase at all
    ACTIVE: 100,
    MATCH: 101,
    EMPTY: 102,
    NOMATCH: 103,
    // Used by [`AST` translator](./ast.html) (semantic analysis) and the user's callback functions
    // to indicate the direction of flow through the `AST` nodes.
    // - *SEM_PRE* - indicates the downward (pre-branch) direction through the `AST` node.
    // - *SEM_POST* - indicates the upward (post-branch) direction through the `AST` node.
    SEM_PRE: 200,
    SEM_POST: 201,
    // Ignored. Retained for backwords compatibility.
    SEM_OK: 300,
    idName: (s)=>{
        switch(s){
            case identifiers.ALT:
                return 'ALT';
            case identifiers.CAT:
                return 'CAT';
            case identifiers.REP:
                return 'REP';
            case identifiers.RNM:
                return 'RNM';
            case identifiers.TRG:
                return 'TRG';
            case identifiers.TBS:
                return 'TBS';
            case identifiers.TLS:
                return 'TLS';
            case identifiers.UDT:
                return 'UDT';
            case identifiers.AND:
                return 'AND';
            case identifiers.NOT:
                return 'NOT';
            case identifiers.ACTIVE:
                return 'ACTIVE';
            case identifiers.EMPTY:
                return 'EMPTY';
            case identifiers.MATCH:
                return 'MATCH';
            case identifiers.NOMATCH:
                return 'NOMATCH';
            case identifiers.SEM_PRE:
                return 'SEM_PRE';
            case identifiers.SEM_POST:
                return 'SEM_POST';
            case identifiers.SEM_OK:
                return 'SEM_OK';
            default:
                return 'UNRECOGNIZED STATE';
        }
    }
};
}),
"[project]/node_modules/short-unique-id/dist/short-unique-id.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var ShortUniqueId = (()=>{
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
            enumerable: true,
            configurable: true,
            writable: true,
            value
        }) : obj[key] = value;
    var __spreadValues = (a, b)=>{
        for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
        if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
            if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
        }
        return a;
    };
    var __export = (target, all)=>{
        for(var name in all)__defProp(target, name, {
            get: all[name],
            enumerable: true
        });
    };
    var __copyProps = (to, from, except, desc)=>{
        if (from && typeof from === "object" || typeof from === "function") {
            for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
                get: ()=>from[key],
                enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
            });
        }
        return to;
    };
    var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
            value: true
        }), mod);
    var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    // src/index.ts
    var index_exports = {};
    __export(index_exports, {
        DEFAULT_OPTIONS: ()=>DEFAULT_OPTIONS,
        DEFAULT_UUID_LENGTH: ()=>DEFAULT_UUID_LENGTH,
        default: ()=>ShortUniqueId
    });
    // package.json
    var version = "5.3.2";
    // src/index.ts
    var DEFAULT_UUID_LENGTH = 6;
    var DEFAULT_OPTIONS = {
        dictionary: "alphanum",
        shuffle: true,
        debug: false,
        length: DEFAULT_UUID_LENGTH,
        counter: 0
    };
    var _ShortUniqueId = class _ShortUniqueId {
        constructor(argOptions = {}){
            __publicField(this, "counter");
            __publicField(this, "debug");
            __publicField(this, "dict");
            __publicField(this, "version");
            __publicField(this, "dictIndex", 0);
            __publicField(this, "dictRange", []);
            __publicField(this, "lowerBound", 0);
            __publicField(this, "upperBound", 0);
            __publicField(this, "dictLength", 0);
            __publicField(this, "uuidLength");
            __publicField(this, "_digit_first_ascii", 48);
            __publicField(this, "_digit_last_ascii", 58);
            __publicField(this, "_alpha_lower_first_ascii", 97);
            __publicField(this, "_alpha_lower_last_ascii", 123);
            __publicField(this, "_hex_last_ascii", 103);
            __publicField(this, "_alpha_upper_first_ascii", 65);
            __publicField(this, "_alpha_upper_last_ascii", 91);
            __publicField(this, "_number_dict_ranges", {
                digits: [
                    this._digit_first_ascii,
                    this._digit_last_ascii
                ]
            });
            __publicField(this, "_alpha_dict_ranges", {
                lowerCase: [
                    this._alpha_lower_first_ascii,
                    this._alpha_lower_last_ascii
                ],
                upperCase: [
                    this._alpha_upper_first_ascii,
                    this._alpha_upper_last_ascii
                ]
            });
            __publicField(this, "_alpha_lower_dict_ranges", {
                lowerCase: [
                    this._alpha_lower_first_ascii,
                    this._alpha_lower_last_ascii
                ]
            });
            __publicField(this, "_alpha_upper_dict_ranges", {
                upperCase: [
                    this._alpha_upper_first_ascii,
                    this._alpha_upper_last_ascii
                ]
            });
            __publicField(this, "_alphanum_dict_ranges", {
                digits: [
                    this._digit_first_ascii,
                    this._digit_last_ascii
                ],
                lowerCase: [
                    this._alpha_lower_first_ascii,
                    this._alpha_lower_last_ascii
                ],
                upperCase: [
                    this._alpha_upper_first_ascii,
                    this._alpha_upper_last_ascii
                ]
            });
            __publicField(this, "_alphanum_lower_dict_ranges", {
                digits: [
                    this._digit_first_ascii,
                    this._digit_last_ascii
                ],
                lowerCase: [
                    this._alpha_lower_first_ascii,
                    this._alpha_lower_last_ascii
                ]
            });
            __publicField(this, "_alphanum_upper_dict_ranges", {
                digits: [
                    this._digit_first_ascii,
                    this._digit_last_ascii
                ],
                upperCase: [
                    this._alpha_upper_first_ascii,
                    this._alpha_upper_last_ascii
                ]
            });
            __publicField(this, "_hex_dict_ranges", {
                decDigits: [
                    this._digit_first_ascii,
                    this._digit_last_ascii
                ],
                alphaDigits: [
                    this._alpha_lower_first_ascii,
                    this._hex_last_ascii
                ]
            });
            __publicField(this, "_dict_ranges", {
                _number_dict_ranges: this._number_dict_ranges,
                _alpha_dict_ranges: this._alpha_dict_ranges,
                _alpha_lower_dict_ranges: this._alpha_lower_dict_ranges,
                _alpha_upper_dict_ranges: this._alpha_upper_dict_ranges,
                _alphanum_dict_ranges: this._alphanum_dict_ranges,
                _alphanum_lower_dict_ranges: this._alphanum_lower_dict_ranges,
                _alphanum_upper_dict_ranges: this._alphanum_upper_dict_ranges,
                _hex_dict_ranges: this._hex_dict_ranges
            });
            /* tslint:disable consistent-return */ __publicField(this, "log", (...args)=>{
                const finalArgs = [
                    ...args
                ];
                finalArgs[0] = "[short-unique-id] ".concat(args[0]);
                if (this.debug === true) {
                    if (typeof console !== "undefined" && console !== null) {
                        console.log(...finalArgs);
                        return;
                    }
                }
            });
            /* tslint:enable consistent-return */ __publicField(this, "_normalizeDictionary", (dictionary, shuffle)=>{
                let finalDict;
                if (dictionary && Array.isArray(dictionary) && dictionary.length > 1) {
                    finalDict = dictionary;
                } else {
                    finalDict = [];
                    this.dictIndex = 0;
                    const rangesName = "_".concat(dictionary, "_dict_ranges");
                    const ranges = this._dict_ranges[rangesName];
                    let capacity = 0;
                    for (const [, rangeValue] of Object.entries(ranges)){
                        const [lower, upper] = rangeValue;
                        capacity += Math.abs(upper - lower);
                    }
                    finalDict = new Array(capacity);
                    let dictIdx = 0;
                    for (const [, rangeTypeValue] of Object.entries(ranges)){
                        this.dictRange = rangeTypeValue;
                        this.lowerBound = this.dictRange[0];
                        this.upperBound = this.dictRange[1];
                        const isAscending = this.lowerBound <= this.upperBound;
                        const start = this.lowerBound;
                        const end = this.upperBound;
                        if (isAscending) {
                            for(let i = start; i < end; i++){
                                finalDict[dictIdx++] = String.fromCharCode(i);
                                this.dictIndex = i;
                            }
                        } else {
                            for(let i = start; i > end; i--){
                                finalDict[dictIdx++] = String.fromCharCode(i);
                                this.dictIndex = i;
                            }
                        }
                    }
                    finalDict.length = dictIdx;
                }
                if (shuffle) {
                    const len = finalDict.length;
                    for(let i = len - 1; i > 0; i--){
                        const j = Math.floor(Math.random() * (i + 1));
                        [finalDict[i], finalDict[j]] = [
                            finalDict[j],
                            finalDict[i]
                        ];
                    }
                }
                return finalDict;
            });
            /** Change the dictionary after initialization. */ __publicField(this, "setDictionary", (dictionary, shuffle)=>{
                this.dict = this._normalizeDictionary(dictionary, shuffle);
                this.dictLength = this.dict.length;
                this.setCounter(0);
            });
            __publicField(this, "seq", ()=>{
                return this.sequentialUUID();
            });
            /**
       * Generates UUID based on internal counter that's incremented after each ID generation.
       * @alias `const uid = new ShortUniqueId(); uid.seq();`
       */ __publicField(this, "sequentialUUID", ()=>{
                const dictLen = this.dictLength;
                const dict = this.dict;
                let counterDiv = this.counter;
                const idParts = [];
                do {
                    const counterRem = counterDiv % dictLen;
                    counterDiv = Math.trunc(counterDiv / dictLen);
                    idParts.push(dict[counterRem]);
                }while (counterDiv !== 0)
                const id = idParts.join("");
                this.counter += 1;
                return id;
            });
            __publicField(this, "rnd", (uuidLength = this.uuidLength || DEFAULT_UUID_LENGTH)=>{
                return this.randomUUID(uuidLength);
            });
            /**
       * Generates UUID by creating each part randomly.
       * @alias `const uid = new ShortUniqueId(); uid.rnd(uuidLength: number);`
       */ __publicField(this, "randomUUID", (uuidLength = this.uuidLength || DEFAULT_UUID_LENGTH)=>{
                if (uuidLength === null || typeof uuidLength === "undefined" || uuidLength < 1) {
                    throw new Error("Invalid UUID Length Provided");
                }
                const result = new Array(uuidLength);
                const dictLen = this.dictLength;
                const dict = this.dict;
                for(let j = 0; j < uuidLength; j++){
                    const randomPartIdx = Math.floor(Math.random() * dictLen);
                    result[j] = dict[randomPartIdx];
                }
                return result.join("");
            });
            __publicField(this, "fmt", (format, date)=>{
                return this.formattedUUID(format, date);
            });
            /**
       * Generates custom UUID with the provided format string.
       * @alias `const uid = new ShortUniqueId(); uid.fmt(format: string);`
       */ __publicField(this, "formattedUUID", (format, date)=>{
                const fnMap = {
                    $r: this.randomUUID,
                    $s: this.sequentialUUID,
                    $t: this.stamp
                };
                const result = format.replace(/\$[rs]\d{0,}|\$t0|\$t[1-9]\d{1,}/g, (m)=>{
                    const fn = m.slice(0, 2);
                    const len = Number.parseInt(m.slice(2), 10);
                    if (fn === "$s") {
                        return fnMap[fn]().padStart(len, "0");
                    }
                    if (fn === "$t" && date) {
                        return fnMap[fn](len, date);
                    }
                    return fnMap[fn](len);
                });
                return result;
            });
            /**
       * Calculates total number of possible UUIDs.
       *
       * Given that:
       *
       * - `H` is the total number of possible UUIDs
       * - `n` is the number of unique characters in the dictionary
       * - `l` is the UUID length
       *
       * Then `H` is defined as `n` to the power of `l`:
       *
       * <div style="background: white; padding: 5px; border-radius: 5px; overflow: hidden;">
       *  <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOwAAABHCAYAAAAECKs5AAALxUlEQVR4Ae2dd+wFRRHHv1YsGHtXVLBjV9T4jw3FAoIFu2JH7ARFjSVqUCFo7CIIKKioMUrsMdagwdiNvTcs2LCLXe8Tb8lm2L3f/d7evtt7v5nkZe/u3e7OfW/2dmd3ZlZycgQcgVYQ2EXSzSXdX9Khko6QdKykd0k6TdIprTDqfDgCjoB0pKT/Dvy+6yA5Ao5AOwjcpGPleZKO7nvTv5rG+/p2WHVOHAFHwCLwEdNgH2Rv8HNHwBFoA4HzSvqtabBXboM158IRcAQsAjc2jfU79gY/dwQcgXYQeLJpsMe1w5pz4gg4AhYBlnLiGWPXXy1Cfu4INILAeST92jRY118beTnOhiNgEXD91SLi545Awwi4/trwy3HWHAGLgOuvFhE/dwQaRcD110ZfjLPlCKQQcP01hYpfcwQaRWAt+ut9JR0m6TGSHi7pQEn7S9p7xG+//v6D+vy4FZF/DOGKdLikg/u85OM3pt59+nsf2Od9gqRDJF1iTMV+jyNQCYHq+uttzHpRvNhbcjym4di1qpL6Qt4HV3oRXqwjsBUCa9Ff95T06c7p9ltd7/pjSWdJOnubjfgffb4fSMJmEqfdrYiHe6+kr0j6fm8o/cdt1ksjhd8z+jI+JskXqLdC3v+vhcBs+uv5Jd1U0ukDDeizku4iadeJn/7qkl42UC8eEI+WdKWJ6/XiHIFSBJ5i5Hbt9sPPNwyEYedvukZ18dKnG8h/i0y91H/XgXz+lyMwJwKnGrldu/3wWw0DocHW/nIwkRTqitMzJeFn6OQItIYAcklHFsvrVdfN5A8NA4EZZpBr0isz9Z5Qs1Iv2xEoQIDwMKF9kK7d/3U3w0Bg5t+SLlnwYGOyMhEV6otTnwEeg57fMwcCs+uvrMfGjSUcf6EyGpeWxEch1BenfEScHIEWEZhdf31jptG8tDJa98nU6yEiKwPvxa+MQBP6648yDeceKz/WuIyvztTrISLH4ed3rR+B2fXXa2QazTr0169l6l77FPn637vXuFAEZtdfH5FpNLX118tJ+k+mbrdgWqg07wC2Z9dfT8o0mtr6K04I8SRTOF77FPkOEDJ/xGkQSOmvV0kUfU1JF0xcn+TSXPrrazMNtrahxiSgeSE7EgFrP5yaHKWxMnJ8VA2Eds80mnXor9/M1O36a4037WVOgYD1f01Njj61l+u9pqjQlvHITKNx/dUi5eeOgHSyaS8PSYDyyd5s8XyJ/4ovWQaCHllbf2VPzVBXnLr+WvxKvYCKCHzYyO0NTV2XlfSvzrusmlqHT2zcYMJx7fXX12XqrfagBlg/dQRWQcA6yFzRFPKMXq5vba5PcrpHptGsQ3/9dqZuPHecdjYCLOnREEo9tZilpayrTejHbU14bxC9qot14Y9+0YU8+lR0bdJDZrFCjxqntfVXXkZcX3zs66+TvuLFFIZMMLr6UyQbhBRiUoeJ0TF0YUkP7TdX/llUTpCvX0p6W6GP9QUk0T5Cmax08GHBJv6Dkv4uCf/uKvSmqOLAAGlt/TXn/0qv67TzELhWF1WEBsbI7u1d+pw+DTL5Z0n3G4CFnpShKA2SPOyE/v7Oy+wVkp7V5WOX9I8aWT+t78UHis3+hcHPh6Lyftc3VD422BZUo7n0V76a4WXE6ZjYUNXA8IJnQeCiXa9IbLC/SLqd4eDISE7+KelO5n9OmfQJ7plf7xv2RRL3cQlHE8oJMof8Xz5z75jLt+ommJ7dxzQjZehdjVjcDYzH6Tr0Vxab4zrDseuv1V53swW/uJeFhyU4vI6RE4L37RLdd3dJBPJjGPpESWOWUWz8sA9E5TV9SGCz0FDitLb+SjC1uL742PXXpkVmcuZYAvmbpC9KIqqmpQslZOWe/U00Vhoqw+DtzMgySRTLHMf0lM3TmxOMw/znurCnT6/4y/nduv7avMhMzuAzexnMmfAxwWOdQ5iYotGh1xJR80bb5IoIoayTxo229pzNNllM3/5Tw3T8AHMcL0l/JZLju7vZxs9I+vyCf8xqPi4tHtWv0qMSQ+z3ktBjU4RRvZVFRoAY1zDBs+ps7M9NucTpbpqYlbNAcE6A8NoCaL9ugY8l6a+5NeTwLEtK6cEuNYO03rKXwZQtbmCHSaYclizfrEo/MeXi/NI05fTXj1fmesj/dUmBwnNWWjnhavn6l8xETmUROKf4MNl0wDlXzn3wNNOwAo6ocyXEsk8oixRjh6bpLYbhwDzrVTUpZz/MtiFLoyv0+hMbfC3xdzNJxNFNTfas4118uR/RDQWof2dCTtFbL1PAYGrS86sF5a0la05/tetgUzNzTOIF8LGgx3LaOQiwcRrLh+yNNERW10RWHj+UYcR/d07IIEYWzdK1EwwDBNPrmHbVpG9k6n5AzUq97OYQ2LeXgycNcMaeS2HkF1KGrqVRHDBwCOWFlOF5s8SesIHROP1EZY43RX+tDNOOKB7rJGbZradL/PAp81VcQUuJXj2We47vXVpozfynJBiGaTbCqknYglqgOF+i/loTJy/7/wgcn5AXggWWECaLjCRjOWTVYo5Z8tHPkfJi4AHuMLqE1W7MxW9y/XU1PDc9F/bFccPieKzXTg6blP7KWnqzZG0zAyCYeOUMpqd6GAyzQ31xysyxkyMQI4ARfSwjHLN2WkpHJco9orTQmvkPTjAMGLga1STXX2uiu3llp+KMTaG/Bq+e+GNw25bhs+EtAuMvqMx0Lv4wUROdHAGLQMpOoFR/TY0u8WMtnXW2vE96ntNf7zhpLecu7DWZnp11WSdHIEYAQw6Wb0JnEtJS/RVH9lBWSN8QV9za8XUTDMM4+mvO+HqqZ3D9dSokN7+cPRNyOoX+igtfaKghvVvLcD42wTCMVwsY1YOBz6N1kQqALcl+uOV3u0m84Yge5COkbCVTQmz2ZmWw+eEwwacCAHFae5bswEy9S9ZfcUnDNeyshf8w/WO7z5YoZT9cqr8Gv9tY7pseDvNCcvprKk7OlC8wt//rkvXX72U+QrFALOm4JK7RlLKC/vqrBLal+mtqS9N9tmB81wnCrG5RRf7v6yVAQKAISEUs1ZqUAou6h6Lg1eRnirLZO4Uh1ZIaZYpX3MywfCuN/zsFppRx/QSmZxQWbjdfBgcmtYg8kSPiRvHheHnuhtrXD0kAAeOnV67Y9dfKAG9Y8Sk5ZYmnhF6SkH0CsQ0RcaNoH2zcPAsR6zX1hX1RZW4IK5mqF68dJ0fAIpCyE8DYZ1Vi5JByJcV/eYjCOnAc1X/o/kn/Qy84M9NwthrHlzLyqky92BU7OQIWgdQ8C8uRq9LtE/K31WQnkRr/0MUwRpWbhVJ6Ab3eOvRXPPlTPeyS9ddZXuIOqDQVJ5uOpiQiRqrDYFeBISJWFDLLPMUsxBJEqtHUjhTHXiNEFbB1sx5GeBUnRyBG4KCErLwjvmGFY/ZptfJHAIchIswvPSxRMWahUxNM8xB4LtSke2Xqdf21JurLLZt4w7ZxlYaDIcBcXCbrzkNEQDjuZ4uQWQiXOQIux0yH49phWbBOCXXFKRMLTo6ARSBlvorBfgnFG1Yhg2zGnCPMc9lCBj16KDBcLv8k14/ONBqY32+SGtKF7G02HYob7FAc2nRpfnXTESDigzUdnMJ+GH01lj1WS3J0Yn9v2Aokd1/xdeLj0EAwAWSzWQJbEVTKDgdixjnmS4IXDTouijb58cgnyPgY2q3b1oP9TcjHJBK2yiwTvS+xFUJcN84G9LKHScLvkfyUw/4orSzgj3l+v2c6BEJQtlhOaEClxM4BcUgYdFpLTGoFx3bWbKsS0dPtlyl+6FWOecAxM3OpKfhV6ovz1F5mqvoyvPCVEXih6QmRial2gjg0KhvZjvfiwQoqDJtPGCn3Kz8kGffq99XkATGVwxidLfm288MEi3xhC433jOCInpD9TaiXfT3JzxBmO/XS4Ml3dl8O5+69MwL8DbzFeuigS05pMstoLvS0jPBwtQsGFcgvm7/56G4DBcsfqQ4CRH1gZhZXT4xqajgjEOf4uf3O7AReo2M6fItQq8VP+z8Ye9m2pZEsNQAAAABJRU5ErkJggg==" />
       * </div>
       *
       * This function returns `H`.
       */ __publicField(this, "availableUUIDs", (uuidLength = this.uuidLength)=>{
                return Number.parseFloat(([
                    ...new Set(this.dict)
                ].length ** uuidLength).toFixed(0));
            });
            /**
       * Calculates approximate number of hashes before first collision.
       *
       * Given that:
       *
       * - `H` is the total number of possible UUIDs, or in terms of this library,
       * the result of running `availableUUIDs()`
       * - the expected number of values we have to choose before finding the
       * first collision can be expressed as the quantity `Q(H)`
       *
       * Then `Q(H)` can be approximated as the square root of the product of half
       * of pi times `H`:
       *
       * <div style="background: white; padding: 5px; border-radius: 5px; overflow: hidden;">
       *  <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAM0AAABNCAYAAAAFDOCxAAAP5klEQVR4Ae2dBdD0SBGGX/xwdyjc3eHgkMLdpaCAw71wOeDQQwp3KdwKd3fncLfD3d0d9vlr+mdu/tmkJ8nut5uvuyq1m2Qy0hlpeXsiBQUHVsOBk0n6vKRDZ3ishmOR667nwC0l/WHBhYfM8Nj1LzcYsBoOPF/Sm1aTdeQaHJgnB74h6b7zbFq0KjgwPQdOKum/kvafPuvIMTgwTw5cV9LfJB1tns2LVgUHpufAEyV9cPpsI8fgwHw58ClJh8y3edGy4MC0HDimpH9KuvK02UZuwYH5cuBykv4t6XjzbWK0LDgwLQdwZn5u2iwjt+DAvDnwHklPnXcTo3XBgek4cGRJf5R0Q2eWR5F0Wkmndx4ncOYbyYIDW8OBCyWn5ql6asxgeYykP6f0OEI9x38knb0n77gdHNgqDtxD0nd6anxESW+W9DtJr5f07HT8OPvPtS8tBsirimv3kcSACwoOzIYDr12IWS/uac2DJL1B0omydGeR9NLsnL9vl4T5Oig4MGsO/FTSbTtaeA5JH5B01CLNQZIIJTBiNfq4ncRvcGCuHDhz0ku6dI4DJAHmLOmTkk6XXTynpLdm5/E3ODBLDtxK0q8lsUq00Gkkfbt44DaSnltci9PgwOw4QNAZukorHSzpecVDz5QE6DMoODBrDhB0du/GFrIqfVfSTYrn3ifpycW1OA0OzIoDFnR20cZWXTHpQaconjtsoeO8qLgWp8GBWXHgepL+UrGK9TUSszL+mJKwwkU8TsmVOJ8VB9A/3t/YorNJwsP/uMpzODoxKhypci8uJQ4cYxEee78d5gYixh12uA7bWjxBZw9rrDxef6AzhBKU9IV072LljW0+P+ECCnEBSTQKsF2rmTFv+7EkvXsJ8/J06/iPJecJ6yhoRmXw/gg6Qz/x0nGTOPezRYQnIM+SXpkGzcPLG9t2fsq0GuCpBTsE4I7YCfBB4I2essAJnbyxUQy2N/Z4kfMsr5A69aMl1Y5H5IkXDjIAhIgOtbRcY4DsVzwDnAMMVZCPA5eX9K8FnxkIXjp18s3cZckDrD5Y1ch7DLHBB+Lfsvd//yLzy/T0L/r8EYpnqqfgf0j8K0n3WvxHlCoJ6wdxFOyoeLXyZsc5g+4tHffLW3ibby6JxgJBZ3kHKUs+t6gwGdj5TRezGkA/5GTS84IfKwln3NUrqyQvnxcGA4P6OQDvP9OfbEdSnF/SgYv3/uC0GvL+f5P6D/3okkWtwMDdLC0Ov039hV11WPHoX1cq0ldPMSHSgWAKHbCLmLGBQ9ApL9uVMN1DEaTj9+Vby4oVCpQsTPA6wbDSkP51tQyLa/gNvhlbEBVcqZ8yWW66T4WJnn7J+y9Xl3qrJERH0qN7uekqaRb/qKRjO5+yeApMhn0IVZj9DGe+ZbLzpAbRqKuWNyvnBC8Rt076O1bul5cYlF/ZAONEWa9NO7egs+tvWsWK+iDu8e45Llzcq52eKUvvbhtiyz+S3NkaLffZVODdarVJ1zAi0ABWmyF01/Q8s4dnA4drZUzwlom8jbiJohtU5wAdkPdYOifrqXfuKuIV9eR91gwPZc3AvpEek3gNYFqmF3Idog8dstXDS2Ys1RT44X1y/v8FlO0x0G9ELMpAHPTQk1L6n3sVuYVhg8mCiSOHrHvK2k1pMJh8awsaTF+kv3iR0y9L6WuO132ayzaiiCUUMBTGcM/0PB2uNqoR9VCuHrBP6b4LWC9+mcrAQOEhs/u/wpM4S4NXGvF0KiLqkEkJM32NN55yaoYYz3OrSEPQ2QtXkfGEecIv+ht9GoOQh36U0rs2CGHmIPO/F/ENnoIszZ1THuTDh31Kuma675Ety2c5H6PPtDovH5iW6BPXKtJwDYscJvnfZ7z5U4pyZBC10JSDuKXcMi2TFyv3rcsbG3beqs/wPui7HMCDOgndAOgCicfMHmxHaoXmgUVWOLBvVqGhm2OjK5G/V5+5TlYfrz5jdcXESFnoREMJMe/LKR8scjjuWP6/mK4xQT3KYTihfHxlmM43gaxznXUTKtNRB+uPXn3mdum9oM+cpCPfPbesM9JJWry7Zb7EVdigqVnQ0GXoREOJzRjI36vPMMOTvkWfsbqxUvIsfp2h9JLU0TGulI4xVs13pTJ+IOkGHYXwLHkx6DaB8HMhJpdt2oS65XX4SOKvV595eUrv0mcscxgxVN6msnRmOhrO0JJgMEYGEAVDCFOwrYZfL3YqsV1Nyl9zarbqM9SP+v41oRaG1Be4EfI0g6OLWA2/l/j23uTnoq1G50tKLHAVLI+bQEyOHp/XTtYVfYaVnP7I9z/LvlE7x/lJ+qf1VRz4i/kxXt2XuOM+lUT0olBWhJIs7uI55Q3n+XlT3uSPvoENveuwpZb0rfqMVQnrEIaEIXSphKvzPAvvECVMaUWcYEW2SQK+4pXeFELUxOizyQQMh3fPgQuhq69wjyA6S9+rzwB9scReC0ONWabkk1etk9rmC16rV1nG3VM96UA10a9Mf+2sXUNl708n0a7M23POBhGt6O0zLJzJj09WTGJUWCnRgZgwpiZ0pCFkk99Fhjy8xmfAItIXmXjylXtZFdhJh/QufQYvuQ2aMfoMe16RD/CYGoAPLBD3W2Hk1khi0Hnea0Ea4p+xsuwXsZX2zI3OPUI/YhYG81duxdTFIyYtVv4pDu8EQj+hv9SknlpdzT+DkaaXzLdCAd4KlZliaWBmJA+U7xrhLOU+IL9WYqZAT+L5Es28LC/kWNKj3A0lgqvQa8YS1ibQtiik6HQYFy44IFNW27EELw9doMt/MjAj8H7oXi3E/s7gGKc4bu8oONdnutApeVbmn1nWf/O0e2RlOhcH4sEQYvXgeTo2CnCNmN1Ig4m1lVCGrY6ECPRRjjfzMHlZfnQujCNjCFnZAIPWBvvls+E4Oz2EcxQg4Vgyfxx16Nt3uVYWIutDazc26Bp9xHhM3+mjHG9GSEEvobBaARfvTb1vApDKOOvIA8j1MsJvQ5ohqFjTZ7AgeQCkOd5sqD5DOzAC9O1PvKy9XAdqTpsxLQMuRR9gS9ZLp729aA8rNPD1o3dllHZt+URPmr7bvCvaY+/b1UGyTC3obGysS5blSv4+MrURa60nbDrHm/X6Z6gxjkbr9MSflMRMyGwNZL50SmKWZYMEXkIfapmZkhl3iK+BYDXK+FhZuSXniBCkB3E9xpfAzI5eM4R4WSjyXeIoxgJEQOpKZ8aYUiMcrXSAO9VuNlzD9J5Pkq1GGQaLd+JqqNbkSekn8JR+4yHwkKR36TOWITgbHkJcyAmH27MWQWaXWMy6WKNKczGyOc+BQ/Ls6P79BkXe6oEMbvZzr2jH17io1xh9BkUXU3zZZqtX3y+GD0zWnpnuRmmAUWcca8yUKM1sGG6AQwaXh8fL6nXjxcAz+d78V627vjABsCfAJhOrobk+vFG4OJfhvUufscYD70Z2pzCTsRElyu1BMRqwkTWzN6BLCsLR5XWIMigxAbaQWd0oyxM9d/zM70THG0rnSu0bqnwT/VnuHtlVF8ROZn5WFNpqBzM78COU2zFE3jaADVmBhOF9d5RNHBRWyU0m208N/nmcwWfMeN0qru6JuMSUiPLLaGWVKYO8gIPge8D8CwARmb2FCJmmMezh6yWsTtaBGMh9xECx9ATGDSVEVfLxKJK1MtBRUDBbiecAGhKWgNPN0+bWMniHxiOvxZTBhfm9uWO1Vm5keiYq2oaU4JkQcJQbL4ZEEu8xg+KJ/mqyctHJjVDkn55s9GxKUaKYbRaz9LVfzKxUsNyKtExLQ9ilxsCO1iiWUcSVMmwVXxOiBulhlqVHJ8FeP2R2RCzDLDtGJyrbtSnnrILGI+9qbEFnrRuorKPNbKBBf2F7XGsXv+iJH6pE7NJ/uP61Ij1mZ3TYZusgnR/9BbQzChWWH5R99AN0F4CDNcIC5GEoMTvL8rB8GaDMgIiK+YFJnCW3jBbEu40Yl6e1/1yvIa6trGW/4MGYJOZIiIJmBke89hD6AZ1yFUSfo+94LKO18lnRwfjZO7dfRC/6S2kRQ9JBgrB0+S/ph5jia/Xacw2dpmZNwjfjdXiRB3L7WBl9aSUnuIHpnZkKvWauZJuNMIl5CICmd4B58iMNHRcLF1ZO6oF6gLEI6+dQmI+37LWlwxuPYprP9Cje6EHAxT2E4xFrWKs+5Ml7qjQvaJgEpipz3fkgfjIxgLXq22sBEZXwiinDvxHRscTlvkEwhYhOrIJso+Qx/Kybb83lmYkZnYfGAS4EBYCu0eecywsjwhP9wwOky59bx3+WbqAzQ6NL11HHKcog6tLkfwwPXWRBZ4BupyBEILYGq2EUyd/iu3D8giTZasoZbQxn5Wn1EGPVABu2SXB3ezEA91zx4fbAlv6aSZ332LdnA1LELyY0irytZ0NGJlO+kEbd3rGl/N1bbUQrZE4bMPhcemMP9j59+D/AWwDw5aLe4VOs/wyTOo5RT+jB+ms3bYl0TNu3oHRqlyUhrr6mvDjw/DgJgYKU0mXiNVQHotoyPOPAKqz/MRqN/4A4HPSZMYQfCFNxi2g3pryuZ7HAoBy3+JC68tuGewbhQV/pIoLOhjp5y3yBDtmk2zVYgQxZuk2P3SnbuPJzZvcSebDyQosCmAgQAzBR7ibKHcfLZn2cq3TeIaEMNV7aSkOeXe89D1nZv5bRbr8G8ncniZVuN4hkJY/z6FZiXmqE+N0Kt6nlk19jZyCwcF0SBtAhBhbWvbHbaOVlx//gwCgO4FA0EWjZt3lAU+BtXyflhgDwbkHBgY3iwA/TwFkWdkHQGWiPdZKBLrHMjsEPrrPOUdYu4gA7ELHa4Jsq4/4t6Mzz+ZSpWGbuCOrEZvdBwYGN44Ahz+mkpbJvQWcMnnWRhZx494JYV72inODAXg4ckOk1ZWQoaN+xIdZ7C3L8QSzDL4NzeY7ocgcLIsk2cADgLLoDKw3bcOUECBcn5DoI/w14M6JWg4IDG88BCw8/LKupBZ1hll41gWgGabJug8Oq2xX5z5gD7APBSoNPxCArAFZdu02O5AuoEja0WPZpRxAaY5EnI6sYjwcH9uUAwFkGDYfB8Qk6Y6P5VRLWOnxAywYMZaPfDAkbX2W9I+/ggPjcvA0aE5EIOuuCuYxlGw5MtvPqi6vCf+SJ9R9bn3g+ONDEASxVKOEMHGD7FnR2YFMubYlZQYjPIramdiAeEqhG3FVQcGAjOQBchUFDuAdhG/xfFYD1oGxlsxVu2e+mfwdnI19mVGo9HLBP7dF5QT8Tt78KQhTEwLBskJTXvRtErqKukWdwoJMD18g6Mns4jPnAV1dB6CdYw7zHfl2Zxb3gwE5ygG2O8lk+cF87+Tai7K3hAOHnNnDYLy4oOBAc6OEAXxVg0LD9bJh5e5gVt4MDcMC+A/TOYEdwIDjg4wCx+Kw0B/uSR6rgQHCAmH02GCGGP6jCgf8BynL2Ji/GeXEAAAAASUVORK5CYII=" />
       * </div>
       *
       * This function returns `Q(H)`.
       *
       * (see [Poisson distribution](https://en.wikipedia.org/wiki/Poisson_distribution))
       */ // Cache for memoization
            __publicField(this, "_collisionCache", /* @__PURE__ */ new Map());
            __publicField(this, "approxMaxBeforeCollision", (rounds = this.availableUUIDs(this.uuidLength))=>{
                const cacheKey = rounds;
                const cached = this._collisionCache.get(cacheKey);
                if (cached !== void 0) {
                    return cached;
                }
                const result = Number.parseFloat(Math.sqrt(Math.PI / 2 * rounds).toFixed(20));
                this._collisionCache.set(cacheKey, result);
                return result;
            });
            /**
       * Calculates probability of generating duplicate UUIDs (a collision) in a
       * given number of UUID generation rounds.
       *
       * Given that:
       *
       * - `r` is the maximum number of times that `randomUUID()` will be called,
       * or better said the number of _rounds_
       * - `H` is the total number of possible UUIDs, or in terms of this library,
       * the result of running `availableUUIDs()`
       *
       * Then the probability of collision `p(r; H)` can be approximated as the result
       * of dividing the square root of the product of half of pi times `r` by `H`:
       *
       * <div style="background: white; padding: 5px; border-radius: 5px; overflow: hidden;">
       *  <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANIAAABJCAYAAABIOHjCAAAO+klEQVR4Ae2dBfDsxg3GvzIzY8qMaVJMGVNmZpjSlJnbtCmkkDIzTxlSxpSbMjOnzMxwv9fVG42f9yz7zgd/SzOe89mL8pK0n7RSUnJgOzlwA0mflfSODbm2k4tZ6klz4JiSfiHpvZIO3pBr0h8kK7+dHLi7pF9KOtZ2Fj9LnRxYPweOIukHku6//qJkCZID28uB20n6naTjV6pwZEnXk3SApMfOue5WiZ+PkwM7ngNHkvRNSY+s1PQYRW76i6TvSPqNpMPL/c8lcfGc612VNPJxcmDHc+Amkv4s6SSVmr5I0j0lHbW8f52kE5X7+0m6dCVePk4OTIYDR5D0JUlPqtT4uJJu6d6x9PuY+/9GSad2//M2OTBJDlxzpmD4m6RTBWt/a0kHubA/Si2f40beTpYDh0l6do/aHyrpiiU8mr5/SzpFj/gZNDmw4zhwBUn/knTmYM32KbOX7TOxpPuvpL2D8TNYcmBHcoDZ5WU9avZqSe9z4U9XOtJd3LO8TQ5MigMXlvQfSecK1hoZ6p+S/D4RavM/SfpIMA063gskvVnSY2bX0Uq8E8w0go+ezYyvkPSSskdl74JJZ7DkwHo48HZJb+iR9XnLbNRUkT9E0qMC6bChSwciPvtSdMAnSzqDpEMknbukcaOC9yPdpOTARnPgfGU22neFpbzKDMd3Z5ffr8rG7nucsgJVPB0MuetxLmzeJgc2kgNsqK4agYAsdsLCDZZydBauyzY4dGBZ/lnYxuv8mxzYDA6craisL7HC4jDTvMXlh/qcTvRh9yxvkwNbxQGE+Y/3KPENi4IBJUP0AgDriY50evcATB8dKeUgx5S83R4OnFbSPyTt36PIr5H01Z7XhzrS/2jpSBfvCJevkwOjceA8ks46MPVnFjNyZoh10XFKZwZJnirudX2Fied706LVes4APpxcEo33ugPiLjPKlcts9P5lJpppJQciHDh6wcN9vTRCTB76arWeIOlrM8O8I0YyHDEMau2Uj0ZkcCbdzoETS3q3JEZyUAigEWiI920P3voU26E/SrpF69vVPkTRQfn3W222mdvUOYA8czLHBLBuNMTvzyxagehE6BGzTvQ9SaC1FyWMAN9U1Nmfk/TWGUTocsFE8VKEsoMZNeWjINMy2DgcuEbpSHSmaweywDAP0/A7BsJ2BXngrBPcZwYJAu4D0ZGfXsoTcZpyqRIWNENScmCtHEDGwTcCHekDgZLQwH9W8G2B4NUgZywOI60TWUD+4+8Bc4yz28PKL+bqlLvPsrSSVD5ODizOgXuVBkmjBExaI5QUP5lp+u5dC9DjOebm5MeGbpOeFuwgGABiYbtxy7oLFgRts2I7/T9CMx9kqoTfBJQHNOznzWECdkK/lsTezaJ0seKuC3mrSaaJe3DzxTb8x57kk5IAAE6NEMBfPlv733VqFXf1fVbpSOwNmUcf93qXYgGFxMP8w5HuAcDSqbG43So6TVknn2mDS/02SWh1Pt1yfVESbpw8vVjSF1rCEv/zMwcbj/eBy/LgU5Ku1Hg+lb/ncKrwJi/hwW3K5i3q8zEJOyL8NmDct07ERO86Imyii9/00fjYxWjrDmW0YsR6aRFI+bjNjUFUo3sVb56E5UK1yoc6aUXVC1wGp++n7M3FnREB7Rd8wtWwVwKgTfvGCmx68HNHB/qusynaGs7evmhJPOM2ufCgh61jYA3ZRaYiJc5FuwIXGYFl3hTp6o6313EMgOd/XcEAg3z25W30a4fQiGUhmKttIVvLM2pG6OGlcSBMRzYQ8QOAL4EpIomZ1b9d+PXBwlyWV5xvxP7OmIQpBObq7FNtHbGcQwuDWnNbCHwXswtubyNEgyA8B11FiQ/KMnCKZHsz8AxVOLMU6AEGmLEImQwnJn5VhImGnxXHynvhdBlpWPcOQf4unPnABJBtDBvm3d7WkmOAYElCo2gToGvxblw2BKPeQmvpbONzZoTfF549XxK2PtFBa0h9GcwxB28qFtiS4DtsPF2gMAuIyLaQl48iIyTO2OlEXBfqUUmUF2iOIjCVSLJg28CUsQN/s6I0icTzYUjDW4X6d8u+f0bhGegC+IA5+RiEfP7jMpgzoNuFGy1cF59/jEybaeKCqDZishfEu2Yv92k8qIzux/MP59wzG5Bnk9C0MA2vYncZV7h0iqh8xGYf4aPyka8bKnLvvNC/i96j7cK/Gr6wrUPzy6zKXsk5owkVbNsyEAWRLM/iZn4sWscg/CzQST1f/D3v2trbUstCIfDa/9zi+Z+KQ/wyDTOi0Lsx6cVtURuBqwJj1UUIoEzx2J+wX2N28XQgBES8uTA1v2rG/Ie2JMaoQl5oZCLCfksSux+Z/Ux0qYGJMh8HmacvkQeoYjt6pG98wlNn8mfvChgOB2sB9sTrDp0L2QO+RpACOPu4+ZBCDIxDR6cxjzUrMICjda1dkRXHwKr9Pxq9FHsSmwEYnVnH4oaIKdEjE2B8TQPF2Z7eE0utUDiooAFAwGhoGMDcX+tcH7GRyxTNO2YnT68vz3mHDcxQAldFGlwR+Qg+2UzQRz6y8jH6k9fQhoSqnaURS7o2ArSJQoM84B3haisINkOR9bz5Q1uay3xGva+2zAQ3LS2OW2edbcTmFUsFpuDmiM9o+ndJTecReKfkAzJzdRHeLO0D22YondCbGIPBIj00gGycejItEMcgNjuZD9d17+UjGp6d6Fb7/WEpE+XqIx9ZOeAzcYdqjgBe1s4Isjz4vapTOX9idnLdbWceS82PwrUkvbOUo2229+nkfU8OMBOYXEOjZdRjtEKGaSMaHVO0xSGMKRpsmdYWj2eMSvhUNnpq+ags4zyRNp2sJpSCJmi6pvXxI/cmHwGxZ9btuoAA0RH+0FCrRvIiDPtIxGcgGELMNgAzI4R2kY4Czo08/cX35YzVJnIjkm6GmcMBv+sOqA+m17xcMpOY+tc7N79kiXePOfnwis7hG8NhJd5FOuKN8RpVPXVFLoyQ7R8NkY9In0GE/CJ+qNvKwwzaV1jGbwIyFIMGy3Q2k2uDU1ue+WwgB9AI8bEfUImPIMd7Lq86RQHBsztV4rU9RiBG3hqiAWtLr88zLx/VZA6fnt8/Gmr0RQOGRwf7hBe8by57F0wuHB3n8oB+86qwjLM3+di1GeL65T0dwKMXWJcTzzshr2Sx+7HF6YMQ2B15wRs25igvF0j1LvL7R9hYDSGsM8kPrdoihM84ZheWmKTHQMQsyRGRfQjBn32XIYTi5Cl57eLBHvxjdEN9Om+GMLnCcFOWiDU0VLJRemJpCLXZL5rOkHAs52iE3wpGNnzdUPmIbGxpt4j9zeXdaQhg2PC9xkHFyD3UB7R1dOlGh/ZnCQVZkcG6OGCOw+fJR6jG+WDNJRwYKp7T4KIEcJE4tdkvms6QcCgYyHue9aZP1+QjljJDKSpH1tIHHfFbSZSlOStipmEbtWhVUSbMW/ZxJCTg4iHax1r58nnhANo0GldthjCt009bhF7wVH0aJlo5RtF5s99YH8bLRxGUOvtrpmAZKh9RFw6ogkd9l2DGB7zjYHHc3JKw9/xy1iqdnXwOLxuufgmOsgjQKCr+PGnBc26J9+YYr3kejGXB7jkfyDZT7bn9shdUm80sjP0uKh+x+TgUHo9ygXpwRfahvP1Rcyaw+kR+6YTkGV16NdOE/36vrfne/wfvyH4g+bEcxbiNZZ9tcuNDLlJ3n2beBzhgGjQYj4q6SaYWn2dDwkiIR5gImTOKISM8KnbKyTJz3vKlVg7gScSPwJlIA5nGGqSH5dfSrz3H+pbT3ubNKLW4PMc7Tg0L2RYPVTkyKzAsk6Gw1kVr2NedcFv6+ayFA/gVoLEwK6FFw6zaiFEYB36oPA2RYO/8r424LJ26yI7NGDLCgwmkrFzRZRIdgMaDUgQ5g7jIaGjS2nBpLOeQO5DfDNGAow78EOAhZwhhqbmITdIiG6ggUvwG+pDyZ5wABxBOaVwoC0Ap4PIVlAKjKJ2LpVgXce4naUTkDhonWqchIzyYMzrBZ2YQosix78xabL6iYGg6OgG0yszkvcswWIDURqPXDA9ol/B97Vo4aQHY1TK8iXZ9h3y/Rg6AyaITMGJDwPVBfvf18ELjfmVJY94P6fpZb17Y2jsQEkP3QWppjvX8VgXwWoNdjZXvtqfLDA5iHqUUqyK7kMe5mlpilu0sn4ljYfklLFrKCBZ0MM9MPkJtumjjRr4C3zV0+dOnEgBtayYdfdJZRdhDZ6bVuPNKGsYBzpNloOc6KLCSYdPawr+wAR4YVoJALDtYqYnoDkTdIwgCLhqhPgiHPRIJPmAPqM3xYDD6yoKBSUTYZ+mbNIwDtnVA54jYFRlAgPAr2yszDdpQMGWTNZxAgJq1L8Cymc68/8x4TOPbQNhPcaRj0nAOYFRKp0ClHyGzZF4EiRLJZ3cYtFPmRWeZvhZY245p7wJUaYjGb3fFV3RzmbIx6o0jV5T1jsrGkPos0yJklsyLIFEi+ewKgzbOgI/0dmyMmEkwBFuUaDhfmVnM7r1oQi3xWSotgldrSXKUR8yaDFIrW1qMUov1J+qRKJET/VgJmSUzaJDRqalYQBVNB1hkv8IXmh18fF+D65oasekKIruGApkaPxapr0fq4zK6i0DmMDFw7dsVeFveA+U5YFsKu8RyolHcf4npTTkpQ+pH5SMc6NCJViYfTfnjZN23hwOG1I/KR+AK6UiHbE8Vs6TJgXE5ALbQlmlsqXT51UCeYj+UOCuRj8atfqaeHFgOBzxSH2hW1wUo1zrejpGPlsPKTGXKHDCHmGAiI4Q8TkfC1zgwt6TkQHKgAIfpGOwbRsj2j1I+inArw0yCA5ix2DINiFAXeU9Pq/Jp3lWmfJ8cWDsHMMexjhQxaARFYuH3WXvpswDJgQ3hgFkyAw+KkOHrcGWd8lGEYxlmEhywIzOjnnAxVWFGWsQKeRKMzUpOhwPAymyZ1tcTbspH02knWdMODgCxso7U1xNuykcdzM3X0+EA1sR0JDZgI2T7R+DrUj6KcCzD7FgO4KEJb7T44cDnAh0Ja2t8+eGfo+kFCesCvANzWB3+GAjPeVqc2rHfAH8jO5axWbHpcAADUw6g43C7touTIM0xj3GFM7XawvKM8ByqNjr9D+9YuR11hSRCAAAAAElFTkSuQmCC" />
       * </div>
       *
       * This function returns `p(r; H)`.
       *
       * (see [Poisson distribution](https://en.wikipedia.org/wiki/Poisson_distribution))
       *
       * (Useful if you are wondering _"If I use this lib and expect to perform at most
       * `r` rounds of UUID generations, what is the probability that I will hit a duplicate UUID?"_.)
       */ __publicField(this, "collisionProbability", (rounds = this.availableUUIDs(this.uuidLength), uuidLength = this.uuidLength)=>{
                return Number.parseFloat((this.approxMaxBeforeCollision(rounds) / this.availableUUIDs(uuidLength)).toFixed(20));
            });
            /**
       * Calculate a "uniqueness" score (from 0 to 1) of UUIDs based on size of
       * dictionary and chosen UUID length.
       *
       * Given that:
       *
       * - `H` is the total number of possible UUIDs, or in terms of this library,
       * the result of running `availableUUIDs()`
       * - `Q(H)` is the approximate number of hashes before first collision,
       * or in terms of this library, the result of running `approxMaxBeforeCollision()`
       *
       * Then `uniqueness` can be expressed as the additive inverse of the probability of
       * generating a "word" I had previously generated (a duplicate) at any given iteration
       * up to the the total number of possible UUIDs expressed as the quotiend of `Q(H)` and `H`:
       *
       * <div style="background: white; padding: 5px; border-radius: 5px; overflow: hidden;">
       *  <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIcAAABDCAYAAAC2nhaoAAAJK0lEQVR4Ae2dB+w9RRHHvyCgYgUVxViCBQIRFRQEFVEERVGKggYwJiAkxCgqECkRJQqiCQjSYsEYCyrFggRDSywUpSN/ihXQINUCCigK4vvEmWS5XJm99/+/37t3O8nl3tudLTc7tzM7M7snFZgVBVaSdLikrWfVYEM7x0vaqCGvJAco8BhJW0raV9IRkg6V9B5JawfKNqGcKOljTZkzTH+apEslvXKGbS5EU8+T9FlJv5Z0jKQ3S3qZpNdJ+rikuySdIekFmU/7YUnfC5Z5iqRf2XWFpPT6paTfS9oqqeuxkq6zPqe4/L7G8LdP8Pm5nqTfSHpWJb38raHAKpL2l3SPzRRPrcEh6en21v3FGKYB7VHJm0q6U9IzH5Xa/udxkp4vCRHwiF0flLSWpNVrisIgMPZnEvyDbPCfUINP0n6T2fHHkhB3BRoosOZED7hI0t8kvb4BJ01mkP8sCQZZJ82o+b2yMdMBNXmRpBNssP8YQZZ0pOHTN0RjG6xqs8pubUhjznuOpOsl3SeJNzwK6A680V2iYg8TRXVve6StZdbO1yLIki4x/O8H8feR9CdJTwzijwbtyZJuNGK+K/OpX2zl/ivphS1l0RGObslvy3rGRM+hfphwzzZEy2OA/234Hwrgg0KZv0uCSQoYBZCzvF0Q/ts9qEJ5xBDl399QHqWR/I0b8ruSd7by1BFRgLdN8FGio/AtSZdFkceAx5sC0XnTIoSvowkrGur4Yl3mRBn8wuSNvGMKhS9X33BlFH0DXScK77XneEm0wCLjPckGjYHF9tAXbjGiNukd5PeZlbw/LE/pY1Tf+EVHf7ze6p1VDu2w3B49YK+AGFzr96QGYuVfVsdpNXW4TsJysg/k6hswfK6+kfbrbkmnpwlj/M2g3myDirLYFzAeOYMx/VdhR8t/ezUj+H+XpP6I2Htrgp+jb3h3fjZReqPLZS+zcHdMxj6omMT7wnZJPXUK6cGW39eH4foGff1r4Lrf2sP+kqNv+POfMnERPCxpNU8Y4/0TyaC+cQoCYGJ3JqsTTT64fX0x2F6o/8vBPv7c8L8bxK+iHWXl25bl1TIL9x+5CtF5S/Bh9AV8H9SDnQRRVQWUSPKxpeQCJnK3b+Ds64LUvoGjsA8cZv19RZ/Ci1LmJ0aE26d4IEQFA8/1gYZ6cM6Rj88jFzDIef2sJLoA56Djv7QLuSH/QKsDB+NoAUcThLx2Cgp83eq4tcXs7DMUDrRcYHlNH/G+RuDThp9r30jrPsTq2DxNHNtvlp0QHhtCH3hRsmTctaUCFytrtOA0Zbm+8ZUmhEq6+1P66htU90mjy6gNYT59YvrOBXSLC4yI32nQNbzOzxkebvccSPUNLJddgEPvQWsLl35fONbqiIixvm3MfTneDFf2mAVSwP3O6gBfA6uNqqcS/YJZ5ypJTTESXh8DBe5rPCF4f7eVo2yEsd6U4G8YbKMODTH4z4Cbv67sQqWdZQRlKnV4tkV4uRhY14J+PH+nSYjfQ5Iut4AfT2+6v8XaaBM9dWVPsnIY6iJACCOM1Ne+4W0QNjiNUdDrGfydNxJicrkdAjHw3MqTYRgC9ra3CpkeXZoSQMRymeCbHPAlctSfcrExR5N/J9I2RjPiWaJtRuocNM6rzPl2tYXXsQKpAlPtDwyPoJ1c4E08t6MQAwNTYvJ2fYiZgLZfXeMxBh/xt9kkEg3R5SLybBNhGLHq7C5t3djAGKxEhCVUYtZAxyBo+HcWYU5MxPtscJDBvPl1UVwMXBfgQses3bacfblFb50/Gdy6i5UISqoD4o60OlzSyIvoKl4fd5gMkUl8bBbAqZicI5pzVsVzhIxyCVPsZUYtjFAMAnK4znGGIktkehdQB282+sc8wzmTgKQf5nSQ6OvdTQFjmkuVt5x6hoz7W5tN0mcgSv1HkjZJE1t+Y3Rj2TuvQAwts8Y2kQ5+1aKqb7LlnAeQjJE5UFj/kCiqyHpWOtAkCq81ZZbV0DwC1tUro3oKQSOp29Z9BGNkDhiDWZM3C18MvxETuf6Hb9r+k3ljDgKK7jXltlffxswc7kOBKfz6aA8qovjih0H5nCfg+dg01RvGzBwMKkvE2ybbD4mU2qE3FaUtbFtjl2V1iiayir7DnimVElkVgDxm5sgmVkcBFHwMaawAlxLYKnFhn6VrtdOFOaoUme4/sRfs3l9KQDQ27QXO6ldhjixyjQu5MMe4xjvraQtzZJFrXMiFOcY13llPu7yYAxc2fgo260x79dm0w7KU5Vu54jTo3AC+vJgDZxZb7iIbdLpwzsti7/8jsyPsH+XKogGBR62wvJijtZGSOUwKFOYY5rjNpNeFOWZC5mE2UphjmOM2k17jC8Aj+amZtFYaGQwFCFQlEATm+MZgel06usIowK5uIp8JVuUwD49j4H7DJCKaZSRbCt+wwnpQKp5bCnBcEedxshW/6SIsfl7D3uaRsNCUs8GIdOdwufT60uToqVMr9GSrArvuTq7gejlezshpP/NIi9KnCgXY2sCxk8zKHpNLuCG71d422X9LnCmByw5sZWBmJv7Dj4xg5uY8U6zMBA5NFaTjDZX7fFHgTBPVbHuIAPGnLtIj+AVnoBRAwceFwGAza0TAj7M8LoJccIZLARyGMAYXu+O7AL3C8d/ZhVzyh00BziNnsP8z0R/YAtIFbMsEH/0k3RLZVa7kD5ACftY6O+MjgG0J5pjmiKpIOwVniSlAxDk76BjsqL7hm6qKvrHEg7eim2dDE4zBFdE32Kzt+EXfWNGjs8T1c+g8gx3VNzgwBnz0jeyjEZb4WUvzmRRwfeOBlrM10jM3XKQUfSOT0ENDR9/gjFBmAs4YbXJLpOmOX/SNoY12Zn/TE48jDkuObnJ9g4DoAgtMgY/YYPN9lscHnjO1bxR9I0CwIaO4P+WnwYfwox/K0Y9Bgg0VDX2DrRaIiegBOK6Mfn6oD136HaMAG4Ncf4h83yX1pxR9I0bjwWLxSXCYg/PJ646srD4Y348Fv9g3qpRZwP8c4chgc1hKBPxrC0XfiFBrwDh8S94/THx48DlK/EaQUENGQxF1EzgzB19cIK0JCBNMv9DEBwRhrgILRAE+icFXqLmqG8I5fH5Z5Vn5ymQVz/+Dz0G5q1bKzOzv/wAvzKhnhyEMfQAAAABJRU5ErkJggg==" />
       * </div>
       *
       * (Useful if you need a value to rate the "quality" of the combination of given dictionary
       * and UUID length. The closer to 1, higher the uniqueness and thus better the quality.)
       */ __publicField(this, "uniqueness", (rounds = this.availableUUIDs(this.uuidLength))=>{
                const score = Number.parseFloat((1 - this.approxMaxBeforeCollision(rounds) / rounds).toFixed(20));
                return score > 1 ? 1 : score < 0 ? 0 : score;
            });
            /**
       * Return the version of this module.
       */ __publicField(this, "getVersion", ()=>{
                return this.version;
            });
            /**
       * Generates a UUID with a timestamp that can be extracted using `uid.parseStamp(stampString);`.
       *
       * ```js
       *  const uidWithTimestamp = uid.stamp(32);
       *  console.log(uidWithTimestamp);
       *  // GDa608f973aRCHLXQYPTbKDbjDeVsSb3
       *
       *  console.log(uid.parseStamp(uidWithTimestamp));
       *  // 2021-05-03T06:24:58.000Z
       *  ```
       */ __publicField(this, "stamp", (finalLength, date)=>{
                const hexStamp = Math.floor(+(date || /* @__PURE__ */ new Date()) / 1e3).toString(16);
                if (typeof finalLength === "number" && finalLength === 0) {
                    return hexStamp;
                }
                if (typeof finalLength !== "number" || finalLength < 10) {
                    throw new Error([
                        "Param finalLength must be a number greater than or equal to 10,",
                        "or 0 if you want the raw hexadecimal timestamp"
                    ].join("\n"));
                }
                const idLength = finalLength - 9;
                const rndIdx = Math.round(Math.random() * (idLength > 15 ? 15 : idLength));
                const id = this.randomUUID(idLength);
                return "".concat(id.substring(0, rndIdx)).concat(hexStamp).concat(id.substring(rndIdx)).concat(rndIdx.toString(16));
            });
            /**
       * Extracts the date embeded in a UUID generated using the `uid.stamp(finalLength);` method.
       *
       * ```js
       *  const uidWithTimestamp = uid.stamp(32);
       *  console.log(uidWithTimestamp);
       *  // GDa608f973aRCHLXQYPTbKDbjDeVsSb3
       *
       *  console.log(uid.parseStamp(uidWithTimestamp));
       *  // 2021-05-03T06:24:58.000Z
       *  ```
       */ __publicField(this, "parseStamp", (suid, format)=>{
                if (format && !/t0|t[1-9]\d{1,}/.test(format)) {
                    throw new Error("Cannot extract date from a formated UUID with no timestamp in the format");
                }
                const stamp = format ? format.replace(/\$[rs]\d{0,}|\$t0|\$t[1-9]\d{1,}/g, (m)=>{
                    const fnMap = {
                        $r: (len2)=>[
                                ...Array(len2)
                            ].map(()=>"r").join(""),
                        $s: (len2)=>[
                                ...Array(len2)
                            ].map(()=>"s").join(""),
                        $t: (len2)=>[
                                ...Array(len2)
                            ].map(()=>"t").join("")
                    };
                    const fn = m.slice(0, 2);
                    const len = Number.parseInt(m.slice(2), 10);
                    return fnMap[fn](len);
                }).replace(/^(.*?)(t{8,})(.*)$/g, (_m, p1, p2)=>{
                    return suid.substring(p1.length, p1.length + p2.length);
                }) : suid;
                if (stamp.length === 8) {
                    return new Date(Number.parseInt(stamp, 16) * 1e3);
                }
                if (stamp.length < 10) {
                    throw new Error("Stamp length invalid");
                }
                const rndIdx = Number.parseInt(stamp.substring(stamp.length - 1), 16);
                return new Date(Number.parseInt(stamp.substring(rndIdx, rndIdx + 8), 16) * 1e3);
            });
            /**
       * Set the counter to a specific value.
       */ __publicField(this, "setCounter", (counter)=>{
                this.counter = counter;
            });
            /**
       * Validate given UID contains only characters from the instanced dictionary or optionally provided dictionary.
       */ __publicField(this, "validate", (uid, dictionary)=>{
                const finalDictionary = dictionary ? this._normalizeDictionary(dictionary) : this.dict;
                return uid.split("").every((c)=>finalDictionary.includes(c));
            });
            const options = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS), argOptions);
            this.counter = 0;
            this.debug = false;
            this.dict = [];
            this.version = version;
            const { dictionary, shuffle, length, counter } = options;
            this.uuidLength = length;
            this.setDictionary(dictionary, shuffle);
            this.setCounter(counter);
            this.debug = options.debug;
            this.log(this.dict);
            this.log("Generator instantiated with Dictionary Size ".concat(this.dictLength, " and counter set to ").concat(this.counter));
            this.log = this.log.bind(this);
            this.setDictionary = this.setDictionary.bind(this);
            this.setCounter = this.setCounter.bind(this);
            this.seq = this.seq.bind(this);
            this.sequentialUUID = this.sequentialUUID.bind(this);
            this.rnd = this.rnd.bind(this);
            this.randomUUID = this.randomUUID.bind(this);
            this.fmt = this.fmt.bind(this);
            this.formattedUUID = this.formattedUUID.bind(this);
            this.availableUUIDs = this.availableUUIDs.bind(this);
            this.approxMaxBeforeCollision = this.approxMaxBeforeCollision.bind(this);
            this.collisionProbability = this.collisionProbability.bind(this);
            this.uniqueness = this.uniqueness.bind(this);
            this.getVersion = this.getVersion.bind(this);
            this.stamp = this.stamp.bind(this);
            this.parseStamp = this.parseStamp.bind(this);
        }
    };
    /** @hidden */ __publicField(_ShortUniqueId, "default", _ShortUniqueId);
    var ShortUniqueId = _ShortUniqueId;
    return __toCommonJS(index_exports);
})();
//# sourceMappingURL=short-unique-id.js.map
'undefined' != ("TURBOPACK compile-time value", "object") && (module.exports = ShortUniqueId.default), 'undefined' != typeof window && (ShortUniqueId = ShortUniqueId.default);
}),
"[project]/node_modules/openapi-server-url-templating/es/server-url-templating.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// copyright: Copyright (c) 2024 Lowell D. Thomas, all rights reserved<br>
//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>
//
// Generated by apg-js, Version 4.4.0 [apg-js](https://github.com/ldthomas/apg-js)
__turbopack_context__.s([
    "default",
    ()=>grammar
]);
function grammar() {
    // ```
    // SUMMARY
    //      rules = 9
    //       udts = 0
    //    opcodes = 62
    //        ---   ABNF original opcodes
    //        ALT = 6
    //        CAT = 2
    //        REP = 3
    //        RNM = 9
    //        TLS = 9
    //        TBS = 6
    //        TRG = 27
    //        ---   SABNF superset opcodes
    //        UDT = 0
    //        AND = 0
    //        NOT = 0
    // characters = [0 - 1114111]
    // ```
    /* OBJECT IDENTIFIER (for internal parser use) */ this.grammarObject = 'grammarObject';
    /* RULES */ this.rules = [];
    this.rules[0] = {
        name: 'server-url-template',
        lower: 'server-url-template',
        index: 0,
        isBkr: false
    };
    this.rules[1] = {
        name: 'server-variable',
        lower: 'server-variable',
        index: 1,
        isBkr: false
    };
    this.rules[2] = {
        name: 'server-variable-name',
        lower: 'server-variable-name',
        index: 2,
        isBkr: false
    };
    this.rules[3] = {
        name: 'literals',
        lower: 'literals',
        index: 3,
        isBkr: false
    };
    this.rules[4] = {
        name: 'DIGIT',
        lower: 'digit',
        index: 4,
        isBkr: false
    };
    this.rules[5] = {
        name: 'HEXDIG',
        lower: 'hexdig',
        index: 5,
        isBkr: false
    };
    this.rules[6] = {
        name: 'pct-encoded',
        lower: 'pct-encoded',
        index: 6,
        isBkr: false
    };
    this.rules[7] = {
        name: 'ucschar',
        lower: 'ucschar',
        index: 7,
        isBkr: false
    };
    this.rules[8] = {
        name: 'iprivate',
        lower: 'iprivate',
        index: 8,
        isBkr: false
    };
    /* UDTS */ this.udts = [];
    /* OPCODES */ /* server-url-template */ this.rules[0].opcodes = [];
    this.rules[0].opcodes[0] = {
        type: 3,
        min: 1,
        max: Infinity
    }; // REP
    this.rules[0].opcodes[1] = {
        type: 1,
        children: [
            2,
            3
        ]
    }; // ALT
    this.rules[0].opcodes[2] = {
        type: 4,
        index: 3
    }; // RNM(literals)
    this.rules[0].opcodes[3] = {
        type: 4,
        index: 1
    }; // RNM(server-variable)
    /* server-variable */ this.rules[1].opcodes = [];
    this.rules[1].opcodes[0] = {
        type: 2,
        children: [
            1,
            2,
            3
        ]
    }; // CAT
    this.rules[1].opcodes[1] = {
        type: 7,
        string: [
            123
        ]
    }; // TLS
    this.rules[1].opcodes[2] = {
        type: 4,
        index: 2
    }; // RNM(server-variable-name)
    this.rules[1].opcodes[3] = {
        type: 7,
        string: [
            125
        ]
    }; // TLS
    /* server-variable-name */ this.rules[2].opcodes = [];
    this.rules[2].opcodes[0] = {
        type: 3,
        min: 1,
        max: Infinity
    }; // REP
    this.rules[2].opcodes[1] = {
        type: 1,
        children: [
            2,
            3,
            4
        ]
    }; // ALT
    this.rules[2].opcodes[2] = {
        type: 5,
        min: 0,
        max: 122
    }; // TRG
    this.rules[2].opcodes[3] = {
        type: 6,
        string: [
            124
        ]
    }; // TBS
    this.rules[2].opcodes[4] = {
        type: 5,
        min: 126,
        max: 1114111
    }; // TRG
    /* literals */ this.rules[3].opcodes = [];
    this.rules[3].opcodes[0] = {
        type: 3,
        min: 1,
        max: Infinity
    }; // REP
    this.rules[3].opcodes[1] = {
        type: 1,
        children: [
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13
        ]
    }; // ALT
    this.rules[3].opcodes[2] = {
        type: 6,
        string: [
            33
        ]
    }; // TBS
    this.rules[3].opcodes[3] = {
        type: 5,
        min: 35,
        max: 36
    }; // TRG
    this.rules[3].opcodes[4] = {
        type: 5,
        min: 38,
        max: 59
    }; // TRG
    this.rules[3].opcodes[5] = {
        type: 6,
        string: [
            61
        ]
    }; // TBS
    this.rules[3].opcodes[6] = {
        type: 5,
        min: 63,
        max: 91
    }; // TRG
    this.rules[3].opcodes[7] = {
        type: 6,
        string: [
            93
        ]
    }; // TBS
    this.rules[3].opcodes[8] = {
        type: 6,
        string: [
            95
        ]
    }; // TBS
    this.rules[3].opcodes[9] = {
        type: 5,
        min: 97,
        max: 122
    }; // TRG
    this.rules[3].opcodes[10] = {
        type: 6,
        string: [
            126
        ]
    }; // TBS
    this.rules[3].opcodes[11] = {
        type: 4,
        index: 7
    }; // RNM(ucschar)
    this.rules[3].opcodes[12] = {
        type: 4,
        index: 8
    }; // RNM(iprivate)
    this.rules[3].opcodes[13] = {
        type: 4,
        index: 6
    }; // RNM(pct-encoded)
    /* DIGIT */ this.rules[4].opcodes = [];
    this.rules[4].opcodes[0] = {
        type: 5,
        min: 48,
        max: 57
    }; // TRG
    /* HEXDIG */ this.rules[5].opcodes = [];
    this.rules[5].opcodes[0] = {
        type: 1,
        children: [
            1,
            2,
            3,
            4,
            5,
            6,
            7
        ]
    }; // ALT
    this.rules[5].opcodes[1] = {
        type: 4,
        index: 4
    }; // RNM(DIGIT)
    this.rules[5].opcodes[2] = {
        type: 7,
        string: [
            97
        ]
    }; // TLS
    this.rules[5].opcodes[3] = {
        type: 7,
        string: [
            98
        ]
    }; // TLS
    this.rules[5].opcodes[4] = {
        type: 7,
        string: [
            99
        ]
    }; // TLS
    this.rules[5].opcodes[5] = {
        type: 7,
        string: [
            100
        ]
    }; // TLS
    this.rules[5].opcodes[6] = {
        type: 7,
        string: [
            101
        ]
    }; // TLS
    this.rules[5].opcodes[7] = {
        type: 7,
        string: [
            102
        ]
    }; // TLS
    /* pct-encoded */ this.rules[6].opcodes = [];
    this.rules[6].opcodes[0] = {
        type: 2,
        children: [
            1,
            2,
            3
        ]
    }; // CAT
    this.rules[6].opcodes[1] = {
        type: 7,
        string: [
            37
        ]
    }; // TLS
    this.rules[6].opcodes[2] = {
        type: 4,
        index: 5
    }; // RNM(HEXDIG)
    this.rules[6].opcodes[3] = {
        type: 4,
        index: 5
    }; // RNM(HEXDIG)
    /* ucschar */ this.rules[7].opcodes = [];
    this.rules[7].opcodes[0] = {
        type: 1,
        children: [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17
        ]
    }; // ALT
    this.rules[7].opcodes[1] = {
        type: 5,
        min: 160,
        max: 55295
    }; // TRG
    this.rules[7].opcodes[2] = {
        type: 5,
        min: 63744,
        max: 64975
    }; // TRG
    this.rules[7].opcodes[3] = {
        type: 5,
        min: 65008,
        max: 65519
    }; // TRG
    this.rules[7].opcodes[4] = {
        type: 5,
        min: 65536,
        max: 131069
    }; // TRG
    this.rules[7].opcodes[5] = {
        type: 5,
        min: 131072,
        max: 196605
    }; // TRG
    this.rules[7].opcodes[6] = {
        type: 5,
        min: 196608,
        max: 262141
    }; // TRG
    this.rules[7].opcodes[7] = {
        type: 5,
        min: 262144,
        max: 327677
    }; // TRG
    this.rules[7].opcodes[8] = {
        type: 5,
        min: 327680,
        max: 393213
    }; // TRG
    this.rules[7].opcodes[9] = {
        type: 5,
        min: 393216,
        max: 458749
    }; // TRG
    this.rules[7].opcodes[10] = {
        type: 5,
        min: 458752,
        max: 524285
    }; // TRG
    this.rules[7].opcodes[11] = {
        type: 5,
        min: 524288,
        max: 589821
    }; // TRG
    this.rules[7].opcodes[12] = {
        type: 5,
        min: 589824,
        max: 655357
    }; // TRG
    this.rules[7].opcodes[13] = {
        type: 5,
        min: 655360,
        max: 720893
    }; // TRG
    this.rules[7].opcodes[14] = {
        type: 5,
        min: 720896,
        max: 786429
    }; // TRG
    this.rules[7].opcodes[15] = {
        type: 5,
        min: 786432,
        max: 851965
    }; // TRG
    this.rules[7].opcodes[16] = {
        type: 5,
        min: 851968,
        max: 917501
    }; // TRG
    this.rules[7].opcodes[17] = {
        type: 5,
        min: 921600,
        max: 983037
    }; // TRG
    /* iprivate */ this.rules[8].opcodes = [];
    this.rules[8].opcodes[0] = {
        type: 1,
        children: [
            1,
            2,
            3
        ]
    }; // ALT
    this.rules[8].opcodes[1] = {
        type: 5,
        min: 57344,
        max: 63743
    }; // TRG
    this.rules[8].opcodes[2] = {
        type: 5,
        min: 983040,
        max: 1048573
    }; // TRG
    this.rules[8].opcodes[3] = {
        type: 5,
        min: 1048576,
        max: 1114109
    }; // TRG
    // The `toString()` function will display the original grammar file(s) that produced these opcodes.
    this.toString = function toString() {
        let str = "";
        str += "; OpenAPI Server URL templating ABNF syntax\n";
        str += "server-url-template    = 1*( literals / server-variable ) ; variant of https://www.rfc-editor.org/rfc/rfc6570#section-2\n";
        str += "server-variable        = \"{\" server-variable-name \"}\"\n";
        str += "server-variable-name   = 1*( %x00-7A / %x7C / %x7E-10FFFF ) ; every UTF8 character except { and } (from OpenAPI)\n";
        str += "\n";
        str += "; https://www.rfc-editor.org/rfc/rfc6570#section-2.1\n";
        str += "; https://www.rfc-editor.org/errata/eid6937\n";
        str += "literals               = 1*( %x21 / %x23-24 / %x26-3B / %x3D / %x3F-5B\n";
        str += "                       / %x5D / %x5F / %x61-7A / %x7E / ucschar / iprivate\n";
        str += "                       / pct-encoded)\n";
        str += "                            ; any Unicode character except: CTL, SP,\n";
        str += "                            ;  DQUOTE, \"%\" (aside from pct-encoded),\n";
        str += "                            ;  \"<\", \">\", \"\\\", \"^\", \"`\", \"{\", \"|\", \"}\"\n";
        str += "\n";
        str += "; https://www.rfc-editor.org/rfc/rfc6570#section-1.5\n";
        str += "DIGIT          =  %x30-39             ; 0-9\n";
        str += "HEXDIG         =  DIGIT / \"A\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\" ; case-insensitive\n";
        str += "\n";
        str += "pct-encoded    =  \"%\" HEXDIG HEXDIG\n";
        str += "\n";
        str += "ucschar        =  %xA0-D7FF / %xF900-FDCF / %xFDF0-FFEF\n";
        str += "               /  %x10000-1FFFD / %x20000-2FFFD / %x30000-3FFFD\n";
        str += "               /  %x40000-4FFFD / %x50000-5FFFD / %x60000-6FFFD\n";
        str += "               /  %x70000-7FFFD / %x80000-8FFFD / %x90000-9FFFD\n";
        str += "               /  %xA0000-AFFFD / %xB0000-BFFFD / %xC0000-CFFFD\n";
        str += "               /  %xD0000-DFFFD / %xE1000-EFFFD\n";
        str += "\n";
        str += "iprivate       =  %xE000-F8FF / %xF0000-FFFFD / %x100000-10FFFD\n";
        return str;
    };
}
}),
"[project]/node_modules/openapi-server-url-templating/es/parse/callbacks/server-url-template.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/apg-lite/lib/parser.js [app-client] (ecmascript)");
;
const serverUrlTemplate = (state, chars, phraseIndex, phraseLength, data)=>{
    if (state === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identifiers"].SEM_PRE) {
        if (Array.isArray(data) === false) {
            throw new Error("parser's user data must be an array");
        }
        data.push([
            'server-url-template',
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["utilities"].charsToString(chars, phraseIndex, phraseLength)
        ]);
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identifiers"].SEM_OK;
};
const __TURBOPACK__default__export__ = serverUrlTemplate;
}),
"[project]/node_modules/openapi-server-url-templating/es/parse/callbacks/server-variable.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/apg-lite/lib/parser.js [app-client] (ecmascript)");
;
const serverVariable = (state, chars, phraseIndex, phraseLength, data)=>{
    if (state === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identifiers"].SEM_PRE) {
        if (Array.isArray(data) === false) {
            throw new Error("parser's user data must be an array");
        }
        data.push([
            'server-variable',
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["utilities"].charsToString(chars, phraseIndex, phraseLength)
        ]);
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identifiers"].SEM_OK;
};
const __TURBOPACK__default__export__ = serverVariable;
}),
"[project]/node_modules/openapi-server-url-templating/es/parse/callbacks/server-variable-name.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/apg-lite/lib/parser.js [app-client] (ecmascript)");
;
const serverVariableName = (state, chars, phraseIndex, phraseLength, data)=>{
    if (state === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identifiers"].SEM_PRE) {
        if (Array.isArray(data) === false) {
            throw new Error("parser's user data must be an array");
        }
        data.push([
            'server-variable-name',
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["utilities"].charsToString(chars, phraseIndex, phraseLength)
        ]);
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identifiers"].SEM_OK;
};
const __TURBOPACK__default__export__ = serverVariableName;
}),
"[project]/node_modules/openapi-server-url-templating/es/parse/callbacks/literals.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/apg-lite/lib/parser.js [app-client] (ecmascript)");
;
const literals = (state, chars, phraseIndex, phraseLength, data)=>{
    if (state === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identifiers"].SEM_PRE) {
        if (Array.isArray(data) === false) {
            throw new Error("parser's user data must be an array");
        }
        data.push([
            'literals',
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["utilities"].charsToString(chars, phraseIndex, phraseLength)
        ]);
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identifiers"].SEM_OK;
};
const __TURBOPACK__default__export__ = literals;
}),
"[project]/node_modules/openapi-server-url-templating/es/parse/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/apg-lite/lib/parser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$server$2d$url$2d$templating$2f$es$2f$server$2d$url$2d$templating$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-server-url-templating/es/server-url-templating.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$server$2d$url$2d$templating$2f$es$2f$parse$2f$callbacks$2f$server$2d$url$2d$template$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-server-url-templating/es/parse/callbacks/server-url-template.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$server$2d$url$2d$templating$2f$es$2f$parse$2f$callbacks$2f$server$2d$variable$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-server-url-templating/es/parse/callbacks/server-variable.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$server$2d$url$2d$templating$2f$es$2f$parse$2f$callbacks$2f$server$2d$variable$2d$name$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-server-url-templating/es/parse/callbacks/server-variable-name.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$server$2d$url$2d$templating$2f$es$2f$parse$2f$callbacks$2f$literals$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-server-url-templating/es/parse/callbacks/literals.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
const grammar = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$server$2d$url$2d$templating$2f$es$2f$server$2d$url$2d$templating$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const parse = (serverURLTemplate)=>{
    const parser = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Parser"]();
    parser.ast = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Ast"]();
    parser.ast.callbacks['server-url-template'] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$server$2d$url$2d$templating$2f$es$2f$parse$2f$callbacks$2f$server$2d$url$2d$template$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
    parser.ast.callbacks['server-variable'] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$server$2d$url$2d$templating$2f$es$2f$parse$2f$callbacks$2f$server$2d$variable$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
    parser.ast.callbacks['server-variable-name'] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$server$2d$url$2d$templating$2f$es$2f$parse$2f$callbacks$2f$server$2d$variable$2d$name$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
    parser.ast.callbacks['literals'] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$server$2d$url$2d$templating$2f$es$2f$parse$2f$callbacks$2f$literals$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
    const result = parser.parse(grammar, 'server-url-template', serverURLTemplate);
    return {
        result,
        ast: parser.ast
    };
};
const __TURBOPACK__default__export__ = parse;
}),
"[project]/node_modules/openapi-server-url-templating/es/test.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$server$2d$url$2d$templating$2f$es$2f$parse$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-server-url-templating/es/parse/index.mjs [app-client] (ecmascript)");
;
/**
 * Test if a string is a server URL template.
 *
 * @param {string} serverURLTemplate
 * @param {Object} [options={}] - An object.
 * @param {boolean} [options.strict=true] - A boolean indicating presence of at least one `Server Variable` AST node.
 * @returns {boolean}
 */ const test = (serverURLTemplate, { strict = false } = {})=>{
    try {
        const parseResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$server$2d$url$2d$templating$2f$es$2f$parse$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(serverURLTemplate);
        if (!parseResult.result.success) return false;
        const parts = [];
        parseResult.ast.translate(parts);
        const hasServerVariable = parts.some(([type])=>type === 'server-variable');
        if (!strict && !hasServerVariable) {
            try {
                new URL(serverURLTemplate, 'https://vladimirgorej.com');
                return true;
            } catch  {
                return false;
            }
        }
        return strict ? hasServerVariable : true;
    } catch  {
        return false;
    }
};
const __TURBOPACK__default__export__ = test;
}),
"[project]/node_modules/openapi-server-url-templating/es/substitute.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__,
    "encodeServerVariable",
    ()=>encodeServerVariable
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$server$2d$url$2d$templating$2f$es$2f$parse$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-server-url-templating/es/parse/index.mjs [app-client] (ecmascript)");
;
const isEncoded = (serverVariableValue)=>{
    try {
        return typeof serverVariableValue === 'string' && decodeURIComponent(serverVariableValue) !== serverVariableValue;
    } catch  {
        return false;
    }
};
const encodeServerVariable = (serverVariableValue)=>{
    if (isEncoded(serverVariableValue)) {
        return serverVariableValue;
    }
    return encodeURIComponent(serverVariableValue).replace(/%5B/g, '[').replace(/%5D/g, ']');
};
const significantTypes = [
    'literals',
    'server-variable-name'
];
const substitute = (serverURLTemplate, serverVariables, options = {})=>{
    const defaultOptions = {
        encoder: encodeServerVariable
    };
    const mergedOptions = {
        ...defaultOptions,
        ...options
    };
    const parseResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$server$2d$url$2d$templating$2f$es$2f$parse$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(serverURLTemplate);
    if (!parseResult.result.success) return serverURLTemplate;
    const parts = [];
    parseResult.ast.translate(parts);
    const substitutedParts = parts.filter(([type])=>significantTypes.includes(type)).map(([type, value])=>{
        if (type === 'server-variable-name') {
            return Object.hasOwn(serverVariables, value) ? mergedOptions.encoder(serverVariables[value], value) : `{${value}}`;
        }
        return value;
    });
    return substitutedParts.join('');
};
const __TURBOPACK__default__export__ = substitute;
}),
"[project]/node_modules/openapi-server-url-templating/es/index.mjs [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$server$2d$url$2d$templating$2f$es$2f$server$2d$url$2d$templating$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-server-url-templating/es/server-url-templating.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$server$2d$url$2d$templating$2f$es$2f$test$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-server-url-templating/es/test.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$server$2d$url$2d$templating$2f$es$2f$parse$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-server-url-templating/es/parse/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$server$2d$url$2d$templating$2f$es$2f$substitute$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-server-url-templating/es/substitute.mjs [app-client] (ecmascript)");
;
;
;
;
}),
"[project]/node_modules/openapi-server-url-templating/es/test.mjs [app-client] (ecmascript) <export default as test>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "test",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$server$2d$url$2d$templating$2f$es$2f$test$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$server$2d$url$2d$templating$2f$es$2f$test$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-server-url-templating/es/test.mjs [app-client] (ecmascript)");
}),
"[project]/node_modules/openapi-server-url-templating/es/substitute.mjs [app-client] (ecmascript) <export default as substitute>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "substitute",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$server$2d$url$2d$templating$2f$es$2f$substitute$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$server$2d$url$2d$templating$2f$es$2f$substitute$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-server-url-templating/es/substitute.mjs [app-client] (ecmascript)");
}),
"[project]/node_modules/openapi-path-templating/es/path-templating.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// copyright: Copyright (c) 2024 Lowell D. Thomas, all rights reserved<br>
//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>
//
// Generated by apg-js, Version 4.4.0 [apg-js](https://github.com/ldthomas/apg-js)
__turbopack_context__.s([
    "default",
    ()=>grammar
]);
function grammar() {
    // ```
    // SUMMARY
    //      rules = 13
    //       udts = 0
    //    opcodes = 65
    //        ---   ABNF original opcodes
    //        ALT = 7
    //        CAT = 4
    //        REP = 5
    //        RNM = 16
    //        TLS = 27
    //        TBS = 1
    //        TRG = 5
    //        ---   SABNF superset opcodes
    //        UDT = 0
    //        AND = 0
    //        NOT = 0
    // characters = [0 - 1114111]
    // ```
    /* OBJECT IDENTIFIER (for internal parser use) */ this.grammarObject = 'grammarObject';
    /* RULES */ this.rules = [];
    this.rules[0] = {
        name: 'path-template',
        lower: 'path-template',
        index: 0,
        isBkr: false
    };
    this.rules[1] = {
        name: 'path-segment',
        lower: 'path-segment',
        index: 1,
        isBkr: false
    };
    this.rules[2] = {
        name: 'slash',
        lower: 'slash',
        index: 2,
        isBkr: false
    };
    this.rules[3] = {
        name: 'path-literal',
        lower: 'path-literal',
        index: 3,
        isBkr: false
    };
    this.rules[4] = {
        name: 'template-expression',
        lower: 'template-expression',
        index: 4,
        isBkr: false
    };
    this.rules[5] = {
        name: 'template-expression-param-name',
        lower: 'template-expression-param-name',
        index: 5,
        isBkr: false
    };
    this.rules[6] = {
        name: 'pchar',
        lower: 'pchar',
        index: 6,
        isBkr: false
    };
    this.rules[7] = {
        name: 'unreserved',
        lower: 'unreserved',
        index: 7,
        isBkr: false
    };
    this.rules[8] = {
        name: 'pct-encoded',
        lower: 'pct-encoded',
        index: 8,
        isBkr: false
    };
    this.rules[9] = {
        name: 'sub-delims',
        lower: 'sub-delims',
        index: 9,
        isBkr: false
    };
    this.rules[10] = {
        name: 'ALPHA',
        lower: 'alpha',
        index: 10,
        isBkr: false
    };
    this.rules[11] = {
        name: 'DIGIT',
        lower: 'digit',
        index: 11,
        isBkr: false
    };
    this.rules[12] = {
        name: 'HEXDIG',
        lower: 'hexdig',
        index: 12,
        isBkr: false
    };
    /* UDTS */ this.udts = [];
    /* OPCODES */ /* path-template */ this.rules[0].opcodes = [];
    this.rules[0].opcodes[0] = {
        type: 2,
        children: [
            1,
            2,
            6
        ]
    }; // CAT
    this.rules[0].opcodes[1] = {
        type: 4,
        index: 2
    }; // RNM(slash)
    this.rules[0].opcodes[2] = {
        type: 3,
        min: 0,
        max: Infinity
    }; // REP
    this.rules[0].opcodes[3] = {
        type: 2,
        children: [
            4,
            5
        ]
    }; // CAT
    this.rules[0].opcodes[4] = {
        type: 4,
        index: 1
    }; // RNM(path-segment)
    this.rules[0].opcodes[5] = {
        type: 4,
        index: 2
    }; // RNM(slash)
    this.rules[0].opcodes[6] = {
        type: 3,
        min: 0,
        max: 1
    }; // REP
    this.rules[0].opcodes[7] = {
        type: 4,
        index: 1
    }; // RNM(path-segment)
    /* path-segment */ this.rules[1].opcodes = [];
    this.rules[1].opcodes[0] = {
        type: 3,
        min: 1,
        max: Infinity
    }; // REP
    this.rules[1].opcodes[1] = {
        type: 1,
        children: [
            2,
            3
        ]
    }; // ALT
    this.rules[1].opcodes[2] = {
        type: 4,
        index: 3
    }; // RNM(path-literal)
    this.rules[1].opcodes[3] = {
        type: 4,
        index: 4
    }; // RNM(template-expression)
    /* slash */ this.rules[2].opcodes = [];
    this.rules[2].opcodes[0] = {
        type: 7,
        string: [
            47
        ]
    }; // TLS
    /* path-literal */ this.rules[3].opcodes = [];
    this.rules[3].opcodes[0] = {
        type: 3,
        min: 1,
        max: Infinity
    }; // REP
    this.rules[3].opcodes[1] = {
        type: 4,
        index: 6
    }; // RNM(pchar)
    /* template-expression */ this.rules[4].opcodes = [];
    this.rules[4].opcodes[0] = {
        type: 2,
        children: [
            1,
            2,
            3
        ]
    }; // CAT
    this.rules[4].opcodes[1] = {
        type: 7,
        string: [
            123
        ]
    }; // TLS
    this.rules[4].opcodes[2] = {
        type: 4,
        index: 5
    }; // RNM(template-expression-param-name)
    this.rules[4].opcodes[3] = {
        type: 7,
        string: [
            125
        ]
    }; // TLS
    /* template-expression-param-name */ this.rules[5].opcodes = [];
    this.rules[5].opcodes[0] = {
        type: 3,
        min: 1,
        max: Infinity
    }; // REP
    this.rules[5].opcodes[1] = {
        type: 1,
        children: [
            2,
            3,
            4
        ]
    }; // ALT
    this.rules[5].opcodes[2] = {
        type: 5,
        min: 0,
        max: 122
    }; // TRG
    this.rules[5].opcodes[3] = {
        type: 6,
        string: [
            124
        ]
    }; // TBS
    this.rules[5].opcodes[4] = {
        type: 5,
        min: 126,
        max: 1114111
    }; // TRG
    /* pchar */ this.rules[6].opcodes = [];
    this.rules[6].opcodes[0] = {
        type: 1,
        children: [
            1,
            2,
            3,
            4,
            5
        ]
    }; // ALT
    this.rules[6].opcodes[1] = {
        type: 4,
        index: 7
    }; // RNM(unreserved)
    this.rules[6].opcodes[2] = {
        type: 4,
        index: 8
    }; // RNM(pct-encoded)
    this.rules[6].opcodes[3] = {
        type: 4,
        index: 9
    }; // RNM(sub-delims)
    this.rules[6].opcodes[4] = {
        type: 7,
        string: [
            58
        ]
    }; // TLS
    this.rules[6].opcodes[5] = {
        type: 7,
        string: [
            64
        ]
    }; // TLS
    /* unreserved */ this.rules[7].opcodes = [];
    this.rules[7].opcodes[0] = {
        type: 1,
        children: [
            1,
            2,
            3,
            4,
            5,
            6
        ]
    }; // ALT
    this.rules[7].opcodes[1] = {
        type: 4,
        index: 10
    }; // RNM(ALPHA)
    this.rules[7].opcodes[2] = {
        type: 4,
        index: 11
    }; // RNM(DIGIT)
    this.rules[7].opcodes[3] = {
        type: 7,
        string: [
            45
        ]
    }; // TLS
    this.rules[7].opcodes[4] = {
        type: 7,
        string: [
            46
        ]
    }; // TLS
    this.rules[7].opcodes[5] = {
        type: 7,
        string: [
            95
        ]
    }; // TLS
    this.rules[7].opcodes[6] = {
        type: 7,
        string: [
            126
        ]
    }; // TLS
    /* pct-encoded */ this.rules[8].opcodes = [];
    this.rules[8].opcodes[0] = {
        type: 2,
        children: [
            1,
            2,
            3
        ]
    }; // CAT
    this.rules[8].opcodes[1] = {
        type: 7,
        string: [
            37
        ]
    }; // TLS
    this.rules[8].opcodes[2] = {
        type: 4,
        index: 12
    }; // RNM(HEXDIG)
    this.rules[8].opcodes[3] = {
        type: 4,
        index: 12
    }; // RNM(HEXDIG)
    /* sub-delims */ this.rules[9].opcodes = [];
    this.rules[9].opcodes[0] = {
        type: 1,
        children: [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11
        ]
    }; // ALT
    this.rules[9].opcodes[1] = {
        type: 7,
        string: [
            33
        ]
    }; // TLS
    this.rules[9].opcodes[2] = {
        type: 7,
        string: [
            36
        ]
    }; // TLS
    this.rules[9].opcodes[3] = {
        type: 7,
        string: [
            38
        ]
    }; // TLS
    this.rules[9].opcodes[4] = {
        type: 7,
        string: [
            39
        ]
    }; // TLS
    this.rules[9].opcodes[5] = {
        type: 7,
        string: [
            40
        ]
    }; // TLS
    this.rules[9].opcodes[6] = {
        type: 7,
        string: [
            41
        ]
    }; // TLS
    this.rules[9].opcodes[7] = {
        type: 7,
        string: [
            42
        ]
    }; // TLS
    this.rules[9].opcodes[8] = {
        type: 7,
        string: [
            43
        ]
    }; // TLS
    this.rules[9].opcodes[9] = {
        type: 7,
        string: [
            44
        ]
    }; // TLS
    this.rules[9].opcodes[10] = {
        type: 7,
        string: [
            59
        ]
    }; // TLS
    this.rules[9].opcodes[11] = {
        type: 7,
        string: [
            61
        ]
    }; // TLS
    /* ALPHA */ this.rules[10].opcodes = [];
    this.rules[10].opcodes[0] = {
        type: 1,
        children: [
            1,
            2
        ]
    }; // ALT
    this.rules[10].opcodes[1] = {
        type: 5,
        min: 65,
        max: 90
    }; // TRG
    this.rules[10].opcodes[2] = {
        type: 5,
        min: 97,
        max: 122
    }; // TRG
    /* DIGIT */ this.rules[11].opcodes = [];
    this.rules[11].opcodes[0] = {
        type: 5,
        min: 48,
        max: 57
    }; // TRG
    /* HEXDIG */ this.rules[12].opcodes = [];
    this.rules[12].opcodes[0] = {
        type: 1,
        children: [
            1,
            2,
            3,
            4,
            5,
            6,
            7
        ]
    }; // ALT
    this.rules[12].opcodes[1] = {
        type: 4,
        index: 11
    }; // RNM(DIGIT)
    this.rules[12].opcodes[2] = {
        type: 7,
        string: [
            97
        ]
    }; // TLS
    this.rules[12].opcodes[3] = {
        type: 7,
        string: [
            98
        ]
    }; // TLS
    this.rules[12].opcodes[4] = {
        type: 7,
        string: [
            99
        ]
    }; // TLS
    this.rules[12].opcodes[5] = {
        type: 7,
        string: [
            100
        ]
    }; // TLS
    this.rules[12].opcodes[6] = {
        type: 7,
        string: [
            101
        ]
    }; // TLS
    this.rules[12].opcodes[7] = {
        type: 7,
        string: [
            102
        ]
    }; // TLS
    // The `toString()` function will display the original grammar file(s) that produced these opcodes.
    this.toString = function toString() {
        let str = "";
        str += "; OpenAPI Path Templating ABNF syntax\n";
        str += "; variant of https://datatracker.ietf.org/doc/html/rfc3986#section-3.3\n";
        str += "path-template                  = slash *( path-segment slash ) [ path-segment ]\n";
        str += "path-segment                   = 1*( path-literal / template-expression )\n";
        str += "slash                          = \"/\"\n";
        str += "path-literal                   = 1*pchar\n";
        str += "template-expression            = \"{\" template-expression-param-name \"}\"\n";
        str += "template-expression-param-name = 1*( %x00-7A / %x7C / %x7E-10FFFF ) ; every UTF8 character except { and } (from OpenAPI)\n";
        str += "\n";
        str += "; https://datatracker.ietf.org/doc/html/rfc3986#section-3.3\n";
        str += "pchar               = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n";
        str += "unreserved          = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n";
        str += "                    ; https://datatracker.ietf.org/doc/html/rfc3986#section-2.3\n";
        str += "pct-encoded         = \"%\" HEXDIG HEXDIG\n";
        str += "                    ; https://datatracker.ietf.org/doc/html/rfc3986#section-2.1\n";
        str += "sub-delims          = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n";
        str += "                    / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n";
        str += "                    ; https://datatracker.ietf.org/doc/html/rfc3986#section-2.2\n";
        str += "\n";
        str += "; https://datatracker.ietf.org/doc/html/rfc5234#appendix-B.1\n";
        str += "ALPHA               = %x41-5A / %x61-7A   ; A-Z / a-z\n";
        str += "DIGIT               = %x30-39            ; 0-9\n";
        str += "HEXDIG              = DIGIT / \"A\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\"\n";
        return str;
    };
}
}),
"[project]/node_modules/openapi-path-templating/es/parse/callbacks/slash.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/apg-lite/lib/parser.js [app-client] (ecmascript)");
;
const slash = (state, chars, phraseIndex, phraseLength, data)=>{
    if (state === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identifiers"].SEM_PRE) {
        data.push([
            'slash',
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["utilities"].charsToString(chars, phraseIndex, phraseLength)
        ]);
    } else if (state === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identifiers"].SEM_POST) {
    /* not used in this example */ }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identifiers"].SEM_OK;
};
const __TURBOPACK__default__export__ = slash;
}),
"[project]/node_modules/openapi-path-templating/es/parse/callbacks/path-template.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/apg-lite/lib/parser.js [app-client] (ecmascript)");
;
const pathTemplate = (state, chars, phraseIndex, phraseLength, data)=>{
    if (state === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identifiers"].SEM_PRE) {
        if (Array.isArray(data) === false) {
            throw new Error("parser's user data must be an array");
        }
        data.push([
            'path-template',
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["utilities"].charsToString(chars, phraseIndex, phraseLength)
        ]);
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identifiers"].SEM_OK;
};
const __TURBOPACK__default__export__ = pathTemplate;
}),
"[project]/node_modules/openapi-path-templating/es/parse/callbacks/path-literal.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/apg-lite/lib/parser.js [app-client] (ecmascript)");
;
const pathLiteral = (state, chars, phraseIndex, phraseLength, data)=>{
    if (state === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identifiers"].SEM_PRE) {
        data.push([
            'path-literal',
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["utilities"].charsToString(chars, phraseIndex, phraseLength)
        ]);
    } else if (state === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identifiers"].SEM_POST) {
    /* not used in this example */ }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identifiers"].SEM_OK;
};
const __TURBOPACK__default__export__ = pathLiteral;
}),
"[project]/node_modules/openapi-path-templating/es/parse/callbacks/template-expression.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/apg-lite/lib/parser.js [app-client] (ecmascript)");
;
const templateExpression = (state, chars, phraseIndex, phraseLength, data)=>{
    if (state === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identifiers"].SEM_PRE) {
        data.push([
            'template-expression',
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["utilities"].charsToString(chars, phraseIndex, phraseLength)
        ]);
    } else if (state === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identifiers"].SEM_POST) {
    /* not used in this example */ }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identifiers"].SEM_OK;
};
const __TURBOPACK__default__export__ = templateExpression;
}),
"[project]/node_modules/openapi-path-templating/es/parse/callbacks/template-expression-param-name.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/apg-lite/lib/parser.js [app-client] (ecmascript)");
;
const templateExpressionParamName = (state, chars, phraseIndex, phraseLength, data)=>{
    if (state === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identifiers"].SEM_PRE) {
        data.push([
            'template-expression-param-name',
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["utilities"].charsToString(chars, phraseIndex, phraseLength)
        ]);
    } else if (state === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identifiers"].SEM_POST) {
    /* not used in this example */ }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identifiers"].SEM_OK;
};
const __TURBOPACK__default__export__ = templateExpressionParamName;
}),
"[project]/node_modules/openapi-path-templating/es/parse/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/apg-lite/lib/parser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$path$2d$templating$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-path-templating/es/path-templating.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$parse$2f$callbacks$2f$slash$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-path-templating/es/parse/callbacks/slash.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$parse$2f$callbacks$2f$path$2d$template$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-path-templating/es/parse/callbacks/path-template.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$parse$2f$callbacks$2f$path$2d$literal$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-path-templating/es/parse/callbacks/path-literal.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$parse$2f$callbacks$2f$template$2d$expression$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-path-templating/es/parse/callbacks/template-expression.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$parse$2f$callbacks$2f$template$2d$expression$2d$param$2d$name$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-path-templating/es/parse/callbacks/template-expression-param-name.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
;
const grammar = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$path$2d$templating$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const parse = (pathTemplate)=>{
    const parser = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Parser"]();
    parser.ast = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Ast"]();
    parser.ast.callbacks['path-template'] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$parse$2f$callbacks$2f$path$2d$template$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
    parser.ast.callbacks['slash'] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$parse$2f$callbacks$2f$slash$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
    parser.ast.callbacks['path-literal'] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$parse$2f$callbacks$2f$path$2d$literal$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
    parser.ast.callbacks['template-expression'] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$parse$2f$callbacks$2f$template$2d$expression$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
    parser.ast.callbacks['template-expression-param-name'] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$parse$2f$callbacks$2f$template$2d$expression$2d$param$2d$name$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
    const result = parser.parse(grammar, 'path-template', pathTemplate);
    return {
        result,
        ast: parser.ast
    };
};
const __TURBOPACK__default__export__ = parse;
}),
"[project]/node_modules/openapi-path-templating/es/test.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$parse$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-path-templating/es/parse/index.mjs [app-client] (ecmascript)");
;
/**
 * Test if a string is a path template.
 *
 * @param {string} pathTemplate
 * @param {Object} [options={}] - An object.
 * @param {boolean} [options.strict=true] - A boolean indicating presence of at least one `template-expression` AST node.
 * @returns {boolean}
 */ const test = (pathTemplate, { strict = false } = {})=>{
    try {
        const parseResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$parse$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(pathTemplate);
        if (!parseResult.result.success) return false;
        if (!strict) return true;
        const parts = [];
        parseResult.ast.translate(parts);
        return parts.some(([type])=>type === 'template-expression');
    } catch  {
        return false;
    }
};
const __TURBOPACK__default__export__ = test;
}),
"[project]/node_modules/openapi-path-templating/es/resolve.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__,
    "encodePathComponent",
    ()=>encodePathComponent
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$parse$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-path-templating/es/parse/index.mjs [app-client] (ecmascript)");
;
const isEncoded = (parameterValue)=>{
    try {
        return typeof parameterValue === 'string' && decodeURIComponent(parameterValue) !== parameterValue;
    } catch  {
        return false;
    }
};
const encodePathComponent = (parameterValue)=>{
    if (isEncoded(parameterValue)) {
        return parameterValue;
    }
    return encodeURIComponent(parameterValue).replace(/%5B/g, '[').replace(/%5D/g, ']');
};
const significantTypes = [
    'slash',
    'path-literal',
    'template-expression-param-name'
];
const resolve = (pathTemplate, parameters, options = {})=>{
    const defaultOptions = {
        encoder: encodePathComponent
    };
    const mergedOptions = {
        ...defaultOptions,
        ...options
    };
    const parseResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$parse$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(pathTemplate);
    if (!parseResult.result.success) return pathTemplate;
    const parts = [];
    parseResult.ast.translate(parts);
    const resolvedParts = parts.filter(([type])=>significantTypes.includes(type)).map(([type, value])=>{
        if (type === 'template-expression-param-name') {
            return Object.prototype.hasOwnProperty.call(parameters, value) ? mergedOptions.encoder(parameters[value], value) : `{${value}}`;
        }
        return value;
    });
    return resolvedParts.join('');
};
const __TURBOPACK__default__export__ = resolve;
}),
"[project]/node_modules/openapi-path-templating/es/normalization/percent-encoding.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/apg-lite/lib/parser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$path$2d$templating$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-path-templating/es/path-templating.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$parse$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-path-templating/es/parse/index.mjs [app-client] (ecmascript)");
;
;
;
/**
 * Implementation of https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.2
 */ const significantTypes = [
    'slash',
    'path-literal',
    'template-expression'
];
const grammar = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$path$2d$templating$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const parser = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$apg$2d$lite$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Parser"]();
const percentEndingNormalizer = (pathTemplate)=>{
    const parseResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$parse$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(pathTemplate);
    if (!parseResult.result.success) return pathTemplate;
    const parts = [];
    parseResult.ast.translate(parts);
    return parts.reduce((pathTemplateNormalized, [type, value])=>{
        let normalizedValue = value;
        if (type === 'path-literal') {
            normalizedValue = value.replace(/%[0-9a-fA-F]{2}/g, (match)=>{
                try {
                    const char = decodeURIComponent(match);
                    const { success } = parser.parse(grammar, 'unreserved', char);
                    return success ? char : match;
                } catch  {
                    return match;
                }
            });
        }
        if (significantTypes.includes(type)) {
            return `${pathTemplateNormalized}${normalizedValue}`;
        }
        return pathTemplateNormalized;
    }, '');
};
const __TURBOPACK__default__export__ = percentEndingNormalizer;
}),
"[project]/node_modules/openapi-path-templating/es/normalization/case.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$parse$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-path-templating/es/parse/index.mjs [app-client] (ecmascript)");
;
const significantTypes = [
    'slash',
    'path-literal',
    'template-expression'
];
/**
 * Implementation of https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.1
 */ const caseNormalizer = (pathTemplate)=>{
    const parseResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$parse$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(pathTemplate);
    if (!parseResult.result.success) return pathTemplate;
    const parts = [];
    parseResult.ast.translate(parts);
    return parts.reduce((pathTemplateNormalized, [type, value])=>{
        let normalizedValue = value;
        if (type === 'path-literal') {
            normalizedValue = value.replace(/%[0-9a-fA-F]{2}/g, (match)=>match.toUpperCase());
        }
        if (significantTypes.includes(type)) {
            return `${pathTemplateNormalized}${normalizedValue}`;
        }
        return pathTemplateNormalized;
    }, '');
};
const __TURBOPACK__default__export__ = caseNormalizer;
}),
"[project]/node_modules/openapi-path-templating/es/normalization/path-segment.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$parse$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-path-templating/es/parse/index.mjs [app-client] (ecmascript)");
;
/**
 * Implementation of https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.3
 */ const significantTypes = [
    'slash',
    'path-literal',
    'template-expression'
];
const pathSegmentNormalizer = (pathTemplate)=>{
    const parseResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$parse$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(pathTemplate);
    if (!parseResult.result.success) return pathTemplate;
    const parts = [];
    const stack = [];
    parseResult.ast.translate(parts);
    for(let i = 0; i < parts.length; i += 1){
        let [type, value] = parts[i];
        // remove `template-expression-param-name` and treat `template-expression` as `path-literal`
        if (type === 'template-expression-param-name') {
            continue; // skip this segment
        }
        if (type === 'path-literal' || type === 'template-expression') {
            if (value === '.') continue; // ignore '.' segments
            if (value === '..') {
                // handle '..' segments
                if (stack.length > 1) {
                    let last = stack.pop(); // remove preceding segment
                    if (last[0] === 'slash' && stack.length > 0) {
                        stack.pop(); // remove preceding slash if present
                    }
                }
                continue; // move to the next segment
            }
            stack.push([
                type,
                value
            ]); // push valid path-literals
        } else if (type === 'slash') {
            var _stack;
            // only add slash if the last item on the stack is not a slash
            if (((_stack = stack[stack.length - 1]) === null || _stack === void 0 ? void 0 : _stack[0]) !== 'slash') {
                stack.push([
                    type,
                    value
                ]);
            }
        } else {
            stack.push([
                type,
                value
            ]); // preserve all other types
        }
    }
    const normalizedPathTemplate = stack.reduce((pathTemplateNormalized, [type, value])=>{
        if (significantTypes.includes(type)) {
            return `${pathTemplateNormalized}${value}`;
        }
        return pathTemplateNormalized;
    }, '');
    // makes sure the root path is represented as '/'
    return normalizedPathTemplate === '' ? '/' : normalizedPathTemplate;
};
const __TURBOPACK__default__export__ = pathSegmentNormalizer;
}),
"[project]/node_modules/openapi-path-templating/es/normalization/identity.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
const identityNormalizer = (pathTemplate)=>pathTemplate;
const __TURBOPACK__default__export__ = identityNormalizer;
}),
"[project]/node_modules/openapi-path-templating/es/normalization/index.mjs [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$normalization$2f$percent$2d$encoding$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-path-templating/es/normalization/percent-encoding.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$normalization$2f$case$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-path-templating/es/normalization/case.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$normalization$2f$path$2d$segment$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-path-templating/es/normalization/path-segment.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$normalization$2f$identity$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-path-templating/es/normalization/identity.mjs [app-client] (ecmascript)");
;
;
;
/**
 * Implementing https://datatracker.ietf.org/doc/html/rfc3986#section-6.2
 */ const normalize = (pathTemplate)=>{
    const decodedPath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$normalization$2f$percent$2d$encoding$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(pathTemplate);
    const caseNormalizedPath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$normalization$2f$case$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(decodedPath);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$normalization$2f$path$2d$segment$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(caseNormalizedPath);
};
;
;
const __TURBOPACK__default__export__ = normalize;
}),
"[project]/node_modules/openapi-path-templating/es/equivalence/is-identical.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$parse$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-path-templating/es/parse/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$normalization$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/openapi-path-templating/es/normalization/index.mjs [app-client] (ecmascript) <locals>");
;
;
const isIdentical = (pathTemplate1, pathTemplate2, { normalizer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$normalization$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"] } = {})=>{
    if (typeof pathTemplate1 !== 'string') return false;
    if (typeof pathTemplate2 !== 'string') return false;
    const parseResult1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$parse$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(normalizer(pathTemplate1));
    const parseResult2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$parse$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(normalizer(pathTemplate2));
    if (!parseResult1.result.success) return false;
    if (!parseResult2.result.success) return false;
    const parts1 = [];
    const parts2 = [];
    parseResult1.ast.translate(parts1);
    parseResult2.ast.translate(parts2);
    if (parts1.length !== parts2.length) return false;
    for(let i = 1; i < parts1.length; i++){
        const [type1, value1] = parts1[i];
        const [type2, value2] = parts2[i];
        if (type1 !== type2) return false;
        if (type1 === 'template-expression' || type1 === 'template-expression-param-name') continue;
        if (value1 !== value2) return false;
    }
    return true;
};
const __TURBOPACK__default__export__ = isIdentical;
}),
"[project]/node_modules/openapi-path-templating/es/index.mjs [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$path$2d$templating$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-path-templating/es/path-templating.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$test$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-path-templating/es/test.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$parse$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-path-templating/es/parse/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$resolve$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-path-templating/es/resolve.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$normalization$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/openapi-path-templating/es/normalization/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$equivalence$2f$is$2d$identical$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-path-templating/es/equivalence/is-identical.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
}),
"[project]/node_modules/openapi-path-templating/es/resolve.mjs [app-client] (ecmascript) <export default as resolve>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "resolve",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$resolve$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openapi$2d$path$2d$templating$2f$es$2f$resolve$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/openapi-path-templating/es/resolve.mjs [app-client] (ecmascript)");
}),
"[project]/node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @license React
 * use-sync-external-store-with-selector.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore = React.useSyncExternalStore, useRef = React.useRef, useEffect = React.useEffect, useMemo = React.useMemo, useDebugValue = React.useDebugValue;
    exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
        var instRef = useRef(null);
        if (null === instRef.current) {
            var inst = {
                hasValue: !1,
                value: null
            };
            instRef.current = inst;
        } else inst = instRef.current;
        instRef = useMemo(function() {
            function memoizedSelector(nextSnapshot) {
                if (!hasMemo) {
                    hasMemo = !0;
                    memoizedSnapshot = nextSnapshot;
                    nextSnapshot = selector(nextSnapshot);
                    if (void 0 !== isEqual && inst.hasValue) {
                        var currentSelection = inst.value;
                        if (isEqual(currentSelection, nextSnapshot)) return memoizedSelection = currentSelection;
                    }
                    return memoizedSelection = nextSnapshot;
                }
                currentSelection = memoizedSelection;
                if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
                var nextSelection = selector(nextSnapshot);
                if (void 0 !== isEqual && isEqual(currentSelection, nextSelection)) return memoizedSnapshot = nextSnapshot, currentSelection;
                memoizedSnapshot = nextSnapshot;
                return memoizedSelection = nextSelection;
            }
            var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
                function() {
                    return memoizedSelector(getSnapshot());
                },
                null === maybeGetServerSnapshot ? void 0 : function() {
                    return memoizedSelector(maybeGetServerSnapshot());
                }
            ];
        }, [
            getSnapshot,
            getServerSnapshot,
            selector,
            isEqual
        ]);
        var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
        useEffect(function() {
            inst.hasValue = !0;
            inst.value = value;
        }, [
            value
        ]);
        useDebugValue(value);
        return value;
    };
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
}();
}),
"[project]/node_modules/use-sync-external-store/with-selector.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js [app-client] (ecmascript)");
}
}),
"[project]/node_modules/react-redux/dist/react-redux.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/utils/react.ts
__turbopack_context__.s([
    "Provider",
    ()=>Provider_default,
    "ReactReduxContext",
    ()=>ReactReduxContext,
    "batch",
    ()=>batch,
    "connect",
    ()=>connect_default,
    "createDispatchHook",
    ()=>createDispatchHook,
    "createSelectorHook",
    ()=>createSelectorHook,
    "createStoreHook",
    ()=>createStoreHook,
    "shallowEqual",
    ()=>shallowEqual,
    "useDispatch",
    ()=>useDispatch,
    "useSelector",
    ()=>useSelector,
    "useStore",
    ()=>useStore
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
// src/hooks/useSelector.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$with$2d$selector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/use-sync-external-store/with-selector.js [app-client] (ecmascript)");
;
// src/utils/react-is.ts
var IS_REACT_19 = /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"].startsWith("19");
var REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for(IS_REACT_19 ? "react.transitional.element" : "react.element");
var REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for("react.portal");
var REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for("react.fragment");
var REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for("react.strict_mode");
var REACT_PROFILER_TYPE = /* @__PURE__ */ Symbol.for("react.profiler");
var REACT_CONSUMER_TYPE = /* @__PURE__ */ Symbol.for("react.consumer");
var REACT_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for("react.context");
var REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for("react.forward_ref");
var REACT_SUSPENSE_TYPE = /* @__PURE__ */ Symbol.for("react.suspense");
var REACT_SUSPENSE_LIST_TYPE = /* @__PURE__ */ Symbol.for("react.suspense_list");
var REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for("react.memo");
var REACT_LAZY_TYPE = /* @__PURE__ */ Symbol.for("react.lazy");
var REACT_OFFSCREEN_TYPE = /* @__PURE__ */ Symbol.for("react.offscreen");
var REACT_CLIENT_REFERENCE = /* @__PURE__ */ Symbol.for("react.client.reference");
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Memo = REACT_MEMO_TYPE;
function isValidElementType(type) {
    return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0) ? true : false;
}
function typeOf(object) {
    if (typeof object === "object" && object !== null) {
        const { $$typeof } = object;
        switch($$typeof){
            case REACT_ELEMENT_TYPE:
                switch(object = object.type, object){
                    case REACT_FRAGMENT_TYPE:
                    case REACT_PROFILER_TYPE:
                    case REACT_STRICT_MODE_TYPE:
                    case REACT_SUSPENSE_TYPE:
                    case REACT_SUSPENSE_LIST_TYPE:
                        return object;
                    default:
                        switch(object = object && object.$$typeof, object){
                            case REACT_CONTEXT_TYPE:
                            case REACT_FORWARD_REF_TYPE:
                            case REACT_LAZY_TYPE:
                            case REACT_MEMO_TYPE:
                                return object;
                            case REACT_CONSUMER_TYPE:
                                return object;
                            default:
                                return $$typeof;
                        }
                }
            case REACT_PORTAL_TYPE:
                return $$typeof;
        }
    }
}
function isContextConsumer(object) {
    return IS_REACT_19 ? typeOf(object) === REACT_CONSUMER_TYPE : typeOf(object) === REACT_CONTEXT_TYPE;
}
function isMemo(object) {
    return typeOf(object) === REACT_MEMO_TYPE;
}
// src/utils/warning.ts
function warning(message) {
    if (typeof console !== "undefined" && typeof console.error === "function") {
        console.error(message);
    }
    try {
        throw new Error(message);
    } catch (e) {}
}
// src/connect/verifySubselectors.ts
function verify(selector, methodName) {
    if (!selector) {
        throw new Error(`Unexpected value for ${methodName} in connect.`);
    } else if (methodName === "mapStateToProps" || methodName === "mapDispatchToProps") {
        if (!Object.prototype.hasOwnProperty.call(selector, "dependsOnOwnProps")) {
            warning(`The selector for ${methodName} of connect did not specify a value for dependsOnOwnProps.`);
        }
    }
}
function verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps) {
    verify(mapStateToProps, "mapStateToProps");
    verify(mapDispatchToProps, "mapDispatchToProps");
    verify(mergeProps, "mergeProps");
}
// src/connect/selectorFactory.ts
function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, { areStatesEqual, areOwnPropsEqual, areStatePropsEqual }) {
    let hasRunAtLeastOnce = false;
    let state;
    let ownProps;
    let stateProps;
    let dispatchProps;
    let mergedProps;
    function handleFirstCall(firstState, firstOwnProps) {
        state = firstState;
        ownProps = firstOwnProps;
        stateProps = mapStateToProps(state, ownProps);
        dispatchProps = mapDispatchToProps(dispatch, ownProps);
        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
        hasRunAtLeastOnce = true;
        return mergedProps;
    }
    function handleNewPropsAndNewState() {
        stateProps = mapStateToProps(state, ownProps);
        if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
        return mergedProps;
    }
    function handleNewProps() {
        if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);
        if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
        return mergedProps;
    }
    function handleNewState() {
        const nextStateProps = mapStateToProps(state, ownProps);
        const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
        stateProps = nextStateProps;
        if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
        return mergedProps;
    }
    function handleSubsequentCalls(nextState, nextOwnProps) {
        const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
        const stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);
        state = nextState;
        ownProps = nextOwnProps;
        if (propsChanged && stateChanged) return handleNewPropsAndNewState();
        if (propsChanged) return handleNewProps();
        if (stateChanged) return handleNewState();
        return mergedProps;
    }
    return function pureFinalPropsSelector(nextState, nextOwnProps) {
        return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
    };
}
function finalPropsSelectorFactory(dispatch, { initMapStateToProps, initMapDispatchToProps, initMergeProps, ...options }) {
    const mapStateToProps = initMapStateToProps(dispatch, options);
    const mapDispatchToProps = initMapDispatchToProps(dispatch, options);
    const mergeProps = initMergeProps(dispatch, options);
    if ("TURBOPACK compile-time truthy", 1) {
        verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps);
    }
    return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
}
// src/utils/bindActionCreators.ts
function bindActionCreators(actionCreators, dispatch) {
    const boundActionCreators = {};
    for(const key in actionCreators){
        const actionCreator = actionCreators[key];
        if (typeof actionCreator === "function") {
            boundActionCreators[key] = (...args)=>dispatch(actionCreator(...args));
        }
    }
    return boundActionCreators;
}
// src/utils/isPlainObject.ts
function isPlainObject(obj) {
    if (typeof obj !== "object" || obj === null) return false;
    const proto = Object.getPrototypeOf(obj);
    if (proto === null) return true;
    let baseProto = proto;
    while(Object.getPrototypeOf(baseProto) !== null){
        baseProto = Object.getPrototypeOf(baseProto);
    }
    return proto === baseProto;
}
// src/utils/verifyPlainObject.ts
function verifyPlainObject(value, displayName, methodName) {
    if (!isPlainObject(value)) {
        warning(`${methodName}() in ${displayName} must return a plain object. Instead received ${value}.`);
    }
}
// src/connect/wrapMapToProps.ts
function wrapMapToPropsConstant(getConstant) {
    return function initConstantSelector(dispatch) {
        const constant = getConstant(dispatch);
        function constantSelector() {
            return constant;
        }
        constantSelector.dependsOnOwnProps = false;
        return constantSelector;
    };
}
function getDependsOnOwnProps(mapToProps) {
    return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
}
function wrapMapToPropsFunc(mapToProps, methodName) {
    return function initProxySelector(dispatch, { displayName }) {
        const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
            return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);
        };
        proxy.dependsOnOwnProps = true;
        proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
            proxy.mapToProps = mapToProps;
            proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
            let props = proxy(stateOrDispatch, ownProps);
            if (typeof props === "function") {
                proxy.mapToProps = props;
                proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
                props = proxy(stateOrDispatch, ownProps);
            }
            if ("TURBOPACK compile-time truthy", 1) verifyPlainObject(props, displayName, methodName);
            return props;
        };
        return proxy;
    };
}
// src/connect/invalidArgFactory.ts
function createInvalidArgFactory(arg, name) {
    return (dispatch, options)=>{
        throw new Error(`Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options.wrappedComponentName}.`);
    };
}
// src/connect/mapDispatchToProps.ts
function mapDispatchToPropsFactory(mapDispatchToProps) {
    return mapDispatchToProps && typeof mapDispatchToProps === "object" ? wrapMapToPropsConstant((dispatch)=>// @ts-ignore
        bindActionCreators(mapDispatchToProps, dispatch)) : !mapDispatchToProps ? wrapMapToPropsConstant((dispatch)=>({
            dispatch
        })) : typeof mapDispatchToProps === "function" ? // @ts-ignore
    wrapMapToPropsFunc(mapDispatchToProps, "mapDispatchToProps") : createInvalidArgFactory(mapDispatchToProps, "mapDispatchToProps");
}
// src/connect/mapStateToProps.ts
function mapStateToPropsFactory(mapStateToProps) {
    return !mapStateToProps ? wrapMapToPropsConstant(()=>({})) : typeof mapStateToProps === "function" ? // @ts-ignore
    wrapMapToPropsFunc(mapStateToProps, "mapStateToProps") : createInvalidArgFactory(mapStateToProps, "mapStateToProps");
}
// src/connect/mergeProps.ts
function defaultMergeProps(stateProps, dispatchProps, ownProps) {
    return {
        ...ownProps,
        ...stateProps,
        ...dispatchProps
    };
}
function wrapMergePropsFunc(mergeProps) {
    return function initMergePropsProxy(dispatch, { displayName, areMergedPropsEqual }) {
        let hasRunOnce = false;
        let mergedProps;
        return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
            const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);
            if (hasRunOnce) {
                if (!areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;
            } else {
                hasRunOnce = true;
                mergedProps = nextMergedProps;
                if ("TURBOPACK compile-time truthy", 1) verifyPlainObject(mergedProps, displayName, "mergeProps");
            }
            return mergedProps;
        };
    };
}
function mergePropsFactory(mergeProps) {
    return !mergeProps ? ()=>defaultMergeProps : typeof mergeProps === "function" ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, "mergeProps");
}
// src/utils/batch.ts
function defaultNoopBatch(callback) {
    callback();
}
// src/utils/Subscription.ts
function createListenerCollection() {
    let first = null;
    let last = null;
    return {
        clear () {
            first = null;
            last = null;
        },
        notify () {
            defaultNoopBatch(()=>{
                let listener = first;
                while(listener){
                    listener.callback();
                    listener = listener.next;
                }
            });
        },
        get () {
            const listeners = [];
            let listener = first;
            while(listener){
                listeners.push(listener);
                listener = listener.next;
            }
            return listeners;
        },
        subscribe (callback) {
            let isSubscribed = true;
            const listener = last = {
                callback,
                next: null,
                prev: last
            };
            if (listener.prev) {
                listener.prev.next = listener;
            } else {
                first = listener;
            }
            return function unsubscribe() {
                if (!isSubscribed || first === null) return;
                isSubscribed = false;
                if (listener.next) {
                    listener.next.prev = listener.prev;
                } else {
                    last = listener.prev;
                }
                if (listener.prev) {
                    listener.prev.next = listener.next;
                } else {
                    first = listener.next;
                }
            };
        }
    };
}
var nullListeners = {
    notify () {},
    get: ()=>[]
};
function createSubscription(store, parentSub) {
    let unsubscribe;
    let listeners = nullListeners;
    let subscriptionsAmount = 0;
    let selfSubscribed = false;
    function addNestedSub(listener) {
        trySubscribe();
        const cleanupListener = listeners.subscribe(listener);
        let removed = false;
        return ()=>{
            if (!removed) {
                removed = true;
                cleanupListener();
                tryUnsubscribe();
            }
        };
    }
    function notifyNestedSubs() {
        listeners.notify();
    }
    function handleChangeWrapper() {
        if (subscription.onStateChange) {
            subscription.onStateChange();
        }
    }
    function isSubscribed() {
        return selfSubscribed;
    }
    function trySubscribe() {
        subscriptionsAmount++;
        if (!unsubscribe) {
            unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
            listeners = createListenerCollection();
        }
    }
    function tryUnsubscribe() {
        subscriptionsAmount--;
        if (unsubscribe && subscriptionsAmount === 0) {
            unsubscribe();
            unsubscribe = void 0;
            listeners.clear();
            listeners = nullListeners;
        }
    }
    function trySubscribeSelf() {
        if (!selfSubscribed) {
            selfSubscribed = true;
            trySubscribe();
        }
    }
    function tryUnsubscribeSelf() {
        if (selfSubscribed) {
            selfSubscribed = false;
            tryUnsubscribe();
        }
    }
    const subscription = {
        addNestedSub,
        notifyNestedSubs,
        handleChangeWrapper,
        isSubscribed,
        trySubscribe: trySubscribeSelf,
        tryUnsubscribe: tryUnsubscribeSelf,
        getListeners: ()=>listeners
    };
    return subscription;
}
// src/utils/useIsomorphicLayoutEffect.ts
var canUseDOM = ()=>!!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
var isDOM = /* @__PURE__ */ canUseDOM();
var isRunningInReactNative = ()=>typeof navigator !== "undefined" && navigator.product === "ReactNative";
var isReactNative = /* @__PURE__ */ isRunningInReactNative();
var getUseIsomorphicLayoutEffect = ()=>isDOM || isReactNative ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLayoutEffect"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"];
var useIsomorphicLayoutEffect = /* @__PURE__ */ getUseIsomorphicLayoutEffect();
// src/utils/shallowEqual.ts
function is(x, y) {
    if (x === y) {
        return x !== 0 || y !== 0 || 1 / x === 1 / y;
    } else {
        return x !== x && y !== y;
    }
}
function shallowEqual(objA, objB) {
    if (is(objA, objB)) return true;
    if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
        return false;
    }
    const keysA = Object.keys(objA);
    const keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) return false;
    for(let i = 0; i < keysA.length; i++){
        if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
            return false;
        }
    }
    return true;
}
// src/utils/hoistStatics.ts
var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
};
var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
};
var FORWARD_REF_STATICS = {
    $$typeof: true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
};
var MEMO_STATICS = {
    $$typeof: true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
};
var TYPE_STATICS = {
    [ForwardRef]: FORWARD_REF_STATICS,
    [Memo]: MEMO_STATICS
};
function getStatics(component) {
    if (isMemo(component)) {
        return MEMO_STATICS;
    }
    return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
}
var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent) {
    if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
            const inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent);
            }
        }
        let keys = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }
        const targetStatics = getStatics(targetComponent);
        const sourceStatics = getStatics(sourceComponent);
        for(let i = 0; i < keys.length; ++i){
            const key = keys[i];
            if (!KNOWN_STATICS[key] && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
                const descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try {
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }
    }
    return targetComponent;
}
// src/components/Context.ts
var ContextKey = /* @__PURE__ */ Symbol.for(`react-redux-context`);
var gT = typeof globalThis !== "undefined" ? globalThis : /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */ {};
function getContext() {
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"]) return {};
    const contextMap = gT[ContextKey] ??= /* @__PURE__ */ new Map();
    let realContext = contextMap.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"]);
    if (!realContext) {
        realContext = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"](null);
        if ("TURBOPACK compile-time truthy", 1) {
            realContext.displayName = "ReactRedux";
        }
        contextMap.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"], realContext);
    }
    return realContext;
}
var ReactReduxContext = /* @__PURE__ */ getContext();
// src/components/connect.tsx
var NO_SUBSCRIPTION_ARRAY = [
    null,
    null
];
var stringifyComponent = (Comp)=>{
    try {
        return JSON.stringify(Comp);
    } catch (err) {
        return String(Comp);
    }
};
function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
    useIsomorphicLayoutEffect({
        "useIsomorphicLayoutEffectWithArgs.useIsomorphicLayoutEffect": ()=>effectFunc(...effectArgs)
    }["useIsomorphicLayoutEffectWithArgs.useIsomorphicLayoutEffect"], dependencies);
}
function captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {
    lastWrapperProps.current = wrapperProps;
    renderIsScheduled.current = false;
    if (childPropsFromStoreUpdate.current) {
        childPropsFromStoreUpdate.current = null;
        notifyNestedSubs();
    }
}
function subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {
    if (!shouldHandleStateChanges) return ()=>{};
    let didUnsubscribe = false;
    let lastThrownError = null;
    const checkForUpdates = ()=>{
        if (didUnsubscribe || !isMounted.current) {
            return;
        }
        const latestStoreState = store.getState();
        let newChildProps, error;
        try {
            newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);
        } catch (e) {
            error = e;
            lastThrownError = e;
        }
        if (!error) {
            lastThrownError = null;
        }
        if (newChildProps === lastChildProps.current) {
            if (!renderIsScheduled.current) {
                notifyNestedSubs();
            }
        } else {
            lastChildProps.current = newChildProps;
            childPropsFromStoreUpdate.current = newChildProps;
            renderIsScheduled.current = true;
            additionalSubscribeListener();
        }
    };
    subscription.onStateChange = checkForUpdates;
    subscription.trySubscribe();
    checkForUpdates();
    const unsubscribeWrapper = ()=>{
        didUnsubscribe = true;
        subscription.tryUnsubscribe();
        subscription.onStateChange = null;
        if (lastThrownError) {
            throw lastThrownError;
        }
    };
    return unsubscribeWrapper;
}
function strictEqual(a, b) {
    return a === b;
}
var hasWarnedAboutDeprecatedPureOption = false;
function connect(mapStateToProps, mapDispatchToProps, mergeProps, { // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.
// @ts-ignore
pure, areStatesEqual = strictEqual, areOwnPropsEqual = shallowEqual, areStatePropsEqual = shallowEqual, areMergedPropsEqual = shallowEqual, // use React's forwardRef to expose a ref of the wrapped component
forwardRef = false, // the context consumer to use
context = ReactReduxContext } = {}) {
    if ("TURBOPACK compile-time truthy", 1) {
        if (pure !== void 0 && !hasWarnedAboutDeprecatedPureOption) {
            hasWarnedAboutDeprecatedPureOption = true;
            warning('The `pure` option has been removed. `connect` is now always a "pure/memoized" component');
        }
    }
    const Context = context;
    const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);
    const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);
    const initMergeProps = mergePropsFactory(mergeProps);
    const shouldHandleStateChanges = Boolean(mapStateToProps);
    const wrapWithConnect = (WrappedComponent)=>{
        if ("TURBOPACK compile-time truthy", 1) {
            const isValid = /* @__PURE__ */ isValidElementType(WrappedComponent);
            if (!isValid) throw new Error(`You must pass a component to the function returned by connect. Instead received ${stringifyComponent(WrappedComponent)}`);
        }
        const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
        const displayName = `Connect(${wrappedComponentName})`;
        const selectorFactoryOptions = {
            shouldHandleStateChanges,
            displayName,
            wrappedComponentName,
            WrappedComponent,
            // @ts-ignore
            initMapStateToProps,
            initMapDispatchToProps,
            initMergeProps,
            areStatesEqual,
            areStatePropsEqual,
            areOwnPropsEqual,
            areMergedPropsEqual
        };
        function ConnectFunction(props) {
            const [propsContext, reactReduxForwardedRef, wrapperProps] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
                "connect.wrapWithConnect.ConnectFunction.useMemo": ()=>{
                    const { reactReduxForwardedRef: reactReduxForwardedRef2, ...wrapperProps2 } = props;
                    return [
                        props.context,
                        reactReduxForwardedRef2,
                        wrapperProps2
                    ];
                }
            }["connect.wrapWithConnect.ConnectFunction.useMemo"], [
                props
            ]);
            const ContextToUse = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
                "connect.wrapWithConnect.ConnectFunction.useMemo[ContextToUse]": ()=>{
                    let ResultContext = Context;
                    if (propsContext?.Consumer) {
                        if ("TURBOPACK compile-time truthy", 1) {
                            const isValid = /* @__PURE__ */ isContextConsumer(// @ts-ignore
                            /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](propsContext.Consumer, null));
                            if (!isValid) {
                                throw new Error("You must pass a valid React context consumer as `props.context`");
                            }
                            ResultContext = propsContext;
                        }
                    }
                    return ResultContext;
                }
            }["connect.wrapWithConnect.ConnectFunction.useMemo[ContextToUse]"], [
                propsContext,
                Context
            ]);
            const contextValue = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"](ContextToUse);
            const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);
            const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);
            if (("TURBOPACK compile-time value", "development") !== "production" && !didStoreComeFromProps && !didStoreComeFromContext) {
                throw new Error(`Could not find "store" in the context of "${displayName}". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to ${displayName} in connect options.`);
            }
            const store = didStoreComeFromProps ? props.store : contextValue.store;
            const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;
            const childPropsSelector = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
                "connect.wrapWithConnect.ConnectFunction.useMemo[childPropsSelector]": ()=>{
                    return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);
                }
            }["connect.wrapWithConnect.ConnectFunction.useMemo[childPropsSelector]"], [
                store
            ]);
            const [subscription, notifyNestedSubs] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
                "connect.wrapWithConnect.ConnectFunction.useMemo": ()=>{
                    if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;
                    const subscription2 = createSubscription(store, didStoreComeFromProps ? void 0 : contextValue.subscription);
                    const notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);
                    return [
                        subscription2,
                        notifyNestedSubs2
                    ];
                }
            }["connect.wrapWithConnect.ConnectFunction.useMemo"], [
                store,
                didStoreComeFromProps,
                contextValue
            ]);
            const overriddenContextValue = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
                "connect.wrapWithConnect.ConnectFunction.useMemo[overriddenContextValue]": ()=>{
                    if (didStoreComeFromProps) {
                        return contextValue;
                    }
                    return {
                        ...contextValue,
                        subscription
                    };
                }
            }["connect.wrapWithConnect.ConnectFunction.useMemo[overriddenContextValue]"], [
                didStoreComeFromProps,
                contextValue,
                subscription
            ]);
            const lastChildProps = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](void 0);
            const lastWrapperProps = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](wrapperProps);
            const childPropsFromStoreUpdate = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](void 0);
            const renderIsScheduled = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](false);
            const isMounted = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](false);
            const latestSubscriptionCallbackError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](void 0);
            useIsomorphicLayoutEffect({
                "connect.wrapWithConnect.ConnectFunction.useIsomorphicLayoutEffect": ()=>{
                    isMounted.current = true;
                    return ({
                        "connect.wrapWithConnect.ConnectFunction.useIsomorphicLayoutEffect": ()=>{
                            isMounted.current = false;
                        }
                    })["connect.wrapWithConnect.ConnectFunction.useIsomorphicLayoutEffect"];
                }
            }["connect.wrapWithConnect.ConnectFunction.useIsomorphicLayoutEffect"], []);
            const actualChildPropsSelector = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
                "connect.wrapWithConnect.ConnectFunction.useMemo[actualChildPropsSelector]": ()=>{
                    const selector = {
                        "connect.wrapWithConnect.ConnectFunction.useMemo[actualChildPropsSelector].selector": ()=>{
                            if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {
                                return childPropsFromStoreUpdate.current;
                            }
                            return childPropsSelector(store.getState(), wrapperProps);
                        }
                    }["connect.wrapWithConnect.ConnectFunction.useMemo[actualChildPropsSelector].selector"];
                    return selector;
                }
            }["connect.wrapWithConnect.ConnectFunction.useMemo[actualChildPropsSelector]"], [
                store,
                wrapperProps
            ]);
            const subscribeForReact = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
                "connect.wrapWithConnect.ConnectFunction.useMemo[subscribeForReact]": ()=>{
                    const subscribe = {
                        "connect.wrapWithConnect.ConnectFunction.useMemo[subscribeForReact].subscribe": (reactListener)=>{
                            if (!subscription) {
                                return ({
                                    "connect.wrapWithConnect.ConnectFunction.useMemo[subscribeForReact].subscribe": ()=>{}
                                })["connect.wrapWithConnect.ConnectFunction.useMemo[subscribeForReact].subscribe"];
                            }
                            return subscribeUpdates(shouldHandleStateChanges, store, subscription, // @ts-ignore
                            childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, reactListener);
                        }
                    }["connect.wrapWithConnect.ConnectFunction.useMemo[subscribeForReact].subscribe"];
                    return subscribe;
                }
            }["connect.wrapWithConnect.ConnectFunction.useMemo[subscribeForReact]"], [
                subscription
            ]);
            useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [
                lastWrapperProps,
                lastChildProps,
                renderIsScheduled,
                wrapperProps,
                childPropsFromStoreUpdate,
                notifyNestedSubs
            ]);
            let actualChildProps;
            try {
                actualChildProps = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"](// TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing
                subscribeForReact, // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,
                // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.
                actualChildPropsSelector, getServerState ? ({
                    "connect.wrapWithConnect.ConnectFunction.useSyncExternalStore": ()=>childPropsSelector(getServerState(), wrapperProps)
                })["connect.wrapWithConnect.ConnectFunction.useSyncExternalStore"] : actualChildPropsSelector);
            } catch (err) {
                if (latestSubscriptionCallbackError.current) {
                    ;
                    err.message += `
The error may be correlated with this previous error:
${latestSubscriptionCallbackError.current.stack}

`;
                }
                throw err;
            }
            useIsomorphicLayoutEffect({
                "connect.wrapWithConnect.ConnectFunction.useIsomorphicLayoutEffect": ()=>{
                    latestSubscriptionCallbackError.current = void 0;
                    childPropsFromStoreUpdate.current = void 0;
                    lastChildProps.current = actualChildProps;
                }
            }["connect.wrapWithConnect.ConnectFunction.useIsomorphicLayoutEffect"]);
            const renderedWrappedComponent = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
                "connect.wrapWithConnect.ConnectFunction.useMemo[renderedWrappedComponent]": ()=>{
                    return(// @ts-ignore
                    /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](WrappedComponent, {
                        ...actualChildProps,
                        ref: reactReduxForwardedRef
                    }));
                }
            }["connect.wrapWithConnect.ConnectFunction.useMemo[renderedWrappedComponent]"], [
                reactReduxForwardedRef,
                WrappedComponent,
                actualChildProps
            ]);
            const renderedChild = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
                "connect.wrapWithConnect.ConnectFunction.useMemo[renderedChild]": ()=>{
                    if (shouldHandleStateChanges) {
                        return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](ContextToUse.Provider, {
                            value: overriddenContextValue
                        }, renderedWrappedComponent);
                    }
                    return renderedWrappedComponent;
                }
            }["connect.wrapWithConnect.ConnectFunction.useMemo[renderedChild]"], [
                ContextToUse,
                renderedWrappedComponent,
                overriddenContextValue
            ]);
            return renderedChild;
        }
        const _Connect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["memo"](ConnectFunction);
        const Connect = _Connect;
        Connect.WrappedComponent = WrappedComponent;
        Connect.displayName = ConnectFunction.displayName = displayName;
        if (forwardRef) {
            const _forwarded = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"](function forwardConnectRef(props, ref) {
                return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](Connect, {
                    ...props,
                    reactReduxForwardedRef: ref
                });
            });
            const forwarded = _forwarded;
            forwarded.displayName = displayName;
            forwarded.WrappedComponent = WrappedComponent;
            return /* @__PURE__ */ hoistNonReactStatics(forwarded, WrappedComponent);
        }
        return /* @__PURE__ */ hoistNonReactStatics(Connect, WrappedComponent);
    };
    return wrapWithConnect;
}
var connect_default = connect;
// src/components/Provider.tsx
function Provider(providerProps) {
    const { children, context, serverState, store } = providerProps;
    const contextValue = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
        "Provider.useMemo[contextValue]": ()=>{
            const subscription = createSubscription(store);
            const baseContextValue = {
                store,
                subscription,
                getServerState: serverState ? ({
                    "Provider.useMemo[contextValue]": ()=>serverState
                })["Provider.useMemo[contextValue]"] : void 0
            };
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
            else {
                const { identityFunctionCheck = "once", stabilityCheck = "once" } = providerProps;
                return /* @__PURE__ */ Object.assign(baseContextValue, {
                    stabilityCheck,
                    identityFunctionCheck
                });
            }
        }
    }["Provider.useMemo[contextValue]"], [
        store,
        serverState
    ]);
    const previousState = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
        "Provider.useMemo[previousState]": ()=>store.getState()
    }["Provider.useMemo[previousState]"], [
        store
    ]);
    useIsomorphicLayoutEffect({
        "Provider.useIsomorphicLayoutEffect": ()=>{
            const { subscription } = contextValue;
            subscription.onStateChange = subscription.notifyNestedSubs;
            subscription.trySubscribe();
            if (previousState !== store.getState()) {
                subscription.notifyNestedSubs();
            }
            return ({
                "Provider.useIsomorphicLayoutEffect": ()=>{
                    subscription.tryUnsubscribe();
                    subscription.onStateChange = void 0;
                }
            })["Provider.useIsomorphicLayoutEffect"];
        }
    }["Provider.useIsomorphicLayoutEffect"], [
        contextValue,
        previousState
    ]);
    const Context = context || ReactReduxContext;
    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](Context.Provider, {
        value: contextValue
    }, children);
}
var Provider_default = Provider;
// src/hooks/useReduxContext.ts
function createReduxContextHook(context = ReactReduxContext) {
    return function useReduxContext2() {
        const contextValue = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"](context);
        if (("TURBOPACK compile-time value", "development") !== "production" && !contextValue) {
            throw new Error("could not find react-redux context value; please ensure the component is wrapped in a <Provider>");
        }
        return contextValue;
    };
}
var useReduxContext = /* @__PURE__ */ createReduxContextHook();
// src/hooks/useStore.ts
function createStoreHook(context = ReactReduxContext) {
    const useReduxContext2 = context === ReactReduxContext ? useReduxContext : // @ts-ignore
    createReduxContextHook(context);
    const useStore2 = ()=>{
        const { store } = useReduxContext2();
        return store;
    };
    Object.assign(useStore2, {
        withTypes: ()=>useStore2
    });
    return useStore2;
}
var useStore = /* @__PURE__ */ createStoreHook();
// src/hooks/useDispatch.ts
function createDispatchHook(context = ReactReduxContext) {
    const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);
    const useDispatch2 = ()=>{
        const store = useStore2();
        return store.dispatch;
    };
    Object.assign(useDispatch2, {
        withTypes: ()=>useDispatch2
    });
    return useDispatch2;
}
var useDispatch = /* @__PURE__ */ createDispatchHook();
;
var refEquality = (a, b)=>a === b;
function createSelectorHook(context = ReactReduxContext) {
    const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);
    const useSelector2 = (selector, equalityFnOrOptions = {})=>{
        const { equalityFn = refEquality } = typeof equalityFnOrOptions === "function" ? {
            equalityFn: equalityFnOrOptions
        } : equalityFnOrOptions;
        if ("TURBOPACK compile-time truthy", 1) {
            if (!selector) {
                throw new Error(`You must pass a selector to useSelector`);
            }
            if (typeof selector !== "function") {
                throw new Error(`You must pass a function as a selector to useSelector`);
            }
            if (typeof equalityFn !== "function") {
                throw new Error(`You must pass a function as an equality function to useSelector`);
            }
        }
        const reduxContext = useReduxContext2();
        const { store, subscription, getServerState } = reduxContext;
        const firstRun = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](true);
        const wrappedSelector = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
            [selector.name] (state) {
                const selected = selector(state);
                if ("TURBOPACK compile-time truthy", 1) {
                    const { devModeChecks = {} } = typeof equalityFnOrOptions === "function" ? {} : equalityFnOrOptions;
                    const { identityFunctionCheck, stabilityCheck } = reduxContext;
                    const { identityFunctionCheck: finalIdentityFunctionCheck, stabilityCheck: finalStabilityCheck } = {
                        stabilityCheck,
                        identityFunctionCheck,
                        ...devModeChecks
                    };
                    if (finalStabilityCheck === "always" || finalStabilityCheck === "once" && firstRun.current) {
                        const toCompare = selector(state);
                        if (!equalityFn(selected, toCompare)) {
                            let stack = void 0;
                            try {
                                throw new Error();
                            } catch (e) {
                                ;
                                ({ stack } = e);
                            }
                            console.warn("Selector " + (selector.name || "unknown") + " returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization", {
                                state,
                                selected,
                                selected2: toCompare,
                                stack
                            });
                        }
                    }
                    if (finalIdentityFunctionCheck === "always" || finalIdentityFunctionCheck === "once" && firstRun.current) {
                        if (selected === state) {
                            let stack = void 0;
                            try {
                                throw new Error();
                            } catch (e) {
                                ;
                                ({ stack } = e);
                            }
                            console.warn("Selector " + (selector.name || "unknown") + " returned the root state when called. This can lead to unnecessary rerenders.\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.", {
                                stack
                            });
                        }
                    }
                    if (firstRun.current) firstRun.current = false;
                }
                return selected;
            }
        }[selector.name], [
            selector
        ]);
        const selectedState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$with$2d$selector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStoreWithSelector"])(subscription.addNestedSub, store.getState, getServerState || store.getState, wrappedSelector, equalityFn);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useDebugValue"](selectedState);
        return selectedState;
    };
    Object.assign(useSelector2, {
        withTypes: ()=>useSelector2
    });
    return useSelector2;
}
var useSelector = /* @__PURE__ */ createSelectorHook();
// src/exports.ts
var batch = defaultNoopBatch;
;
 //# sourceMappingURL=react-redux.mjs.map
}),
"[project]/node_modules/react-syntax-highlighter/dist/esm/create-element.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createChildren",
    ()=>createChildren,
    "createClassNameString",
    ()=>createClassNameString,
    "createStyleObject",
    ()=>createStyleObject,
    "default",
    ()=>createElement
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/extends.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$defineProperty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/defineProperty.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
;
;
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$defineProperty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
;
// Get all possible permutations of all power sets
//
// Super simple, non-algorithmic solution since the
// number of class names will not be greater than 4
function powerSetPermutations(arr) {
    var arrLength = arr.length;
    if (arrLength === 0 || arrLength === 1) return arr;
    if (arrLength === 2) {
        // prettier-ignore
        return [
            arr[0],
            arr[1],
            "".concat(arr[0], ".").concat(arr[1]),
            "".concat(arr[1], ".").concat(arr[0])
        ];
    }
    if (arrLength === 3) {
        return [
            arr[0],
            arr[1],
            arr[2],
            "".concat(arr[0], ".").concat(arr[1]),
            "".concat(arr[0], ".").concat(arr[2]),
            "".concat(arr[1], ".").concat(arr[0]),
            "".concat(arr[1], ".").concat(arr[2]),
            "".concat(arr[2], ".").concat(arr[0]),
            "".concat(arr[2], ".").concat(arr[1]),
            "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]),
            "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]),
            "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]),
            "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]),
            "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]),
            "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])
        ];
    }
    if (arrLength >= 4) {
        // Currently does not support more than 4 extra
        // class names (after `.token` has been removed)
        return [
            arr[0],
            arr[1],
            arr[2],
            arr[3],
            "".concat(arr[0], ".").concat(arr[1]),
            "".concat(arr[0], ".").concat(arr[2]),
            "".concat(arr[0], ".").concat(arr[3]),
            "".concat(arr[1], ".").concat(arr[0]),
            "".concat(arr[1], ".").concat(arr[2]),
            "".concat(arr[1], ".").concat(arr[3]),
            "".concat(arr[2], ".").concat(arr[0]),
            "".concat(arr[2], ".").concat(arr[1]),
            "".concat(arr[2], ".").concat(arr[3]),
            "".concat(arr[3], ".").concat(arr[0]),
            "".concat(arr[3], ".").concat(arr[1]),
            "".concat(arr[3], ".").concat(arr[2]),
            "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]),
            "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]),
            "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]),
            "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]),
            "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]),
            "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]),
            "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]),
            "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]),
            "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]),
            "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]),
            "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]),
            "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]),
            "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]),
            "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]),
            "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0]),
            "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]),
            "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]),
            "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]),
            "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]),
            "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]),
            "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]),
            "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]),
            "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]),
            "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]),
            "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]),
            "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]),
            "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]),
            "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]),
            "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]),
            "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]),
            "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]),
            "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]),
            "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]),
            "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]),
            "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]),
            "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]),
            "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]),
            "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]),
            "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]),
            "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]),
            "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]),
            "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]),
            "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]),
            "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]),
            "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]),
            "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]),
            "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]),
            "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])
        ];
    }
}
var classNameCombinations = {};
function getClassNameCombinations(classNames) {
    if (classNames.length === 0 || classNames.length === 1) return classNames;
    var key = classNames.join('.');
    if (!classNameCombinations[key]) {
        classNameCombinations[key] = powerSetPermutations(classNames);
    }
    return classNameCombinations[key];
}
function createStyleObject(classNames) {
    var elementStyle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var stylesheet = arguments.length > 2 ? arguments[2] : undefined;
    var nonTokenClassNames = classNames.filter(function(className) {
        return className !== 'token';
    });
    var classNamesCombinations = getClassNameCombinations(nonTokenClassNames);
    return classNamesCombinations.reduce(function(styleObject, className) {
        return _objectSpread(_objectSpread({}, styleObject), stylesheet[className]);
    }, elementStyle);
}
function createClassNameString(classNames) {
    return classNames.join(' ');
}
function createChildren(stylesheet, useInlineStyles) {
    var childrenCount = 0;
    return function(children) {
        childrenCount += 1;
        return children.map(function(child, i) {
            return createElement({
                node: child,
                stylesheet: stylesheet,
                useInlineStyles: useInlineStyles,
                key: "code-segment-".concat(childrenCount, "-").concat(i)
            });
        });
    };
}
function createElement(_ref) {
    var node = _ref.node, stylesheet = _ref.stylesheet, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style, useInlineStyles = _ref.useInlineStyles, key = _ref.key;
    var properties = node.properties, type = node.type, TagName = node.tagName, value = node.value;
    if (type === 'text') {
        return value;
    } else if (TagName) {
        var childrenCreator = createChildren(stylesheet, useInlineStyles);
        var props;
        if (!useInlineStyles) {
            props = _objectSpread(_objectSpread({}, properties), {}, {
                className: createClassNameString(properties.className)
            });
        } else {
            var allStylesheetSelectors = Object.keys(stylesheet).reduce(function(classes, selector) {
                selector.split('.').forEach(function(className) {
                    if (!classes.includes(className)) classes.push(className);
                });
                return classes;
            }, []);
            // For compatibility with older versions of react-syntax-highlighter
            var startingClassName = properties.className && properties.className.includes('token') ? [
                'token'
            ] : [];
            var className = properties.className && startingClassName.concat(properties.className.filter(function(className) {
                return !allStylesheetSelectors.includes(className);
            }));
            props = _objectSpread(_objectSpread({}, properties), {}, {
                className: createClassNameString(className) || undefined,
                style: createStyleObject(properties.className, Object.assign({}, properties.style, style), stylesheet)
            });
        }
        var children = childrenCreator(node.children);
        return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(TagName, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({
            key: key
        }, props), children);
    }
}
}),
"[project]/node_modules/react-syntax-highlighter/dist/esm/checkForListedLanguage.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
const __TURBOPACK__default__export__ = function(astGenerator, language) {
    var langs = astGenerator.listLanguages();
    return langs.indexOf(language) !== -1;
};
}),
"[project]/node_modules/react-syntax-highlighter/dist/esm/highlight.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$objectWithoutProperties$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$toConsumableArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$defineProperty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/defineProperty.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$syntax$2d$highlighter$2f$dist$2f$esm$2f$create$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-syntax-highlighter/dist/esm/create-element.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$syntax$2d$highlighter$2f$dist$2f$esm$2f$checkForListedLanguage$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-syntax-highlighter/dist/esm/checkForListedLanguage.js [app-client] (ecmascript)");
;
;
;
var _excluded = [
    "language",
    "children",
    "style",
    "customStyle",
    "codeTagProps",
    "useInlineStyles",
    "showLineNumbers",
    "showInlineLineNumbers",
    "startingLineNumber",
    "lineNumberContainerStyle",
    "lineNumberStyle",
    "wrapLines",
    "wrapLongLines",
    "lineProps",
    "renderer",
    "PreTag",
    "CodeTag",
    "code",
    "astGenerator"
];
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$defineProperty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
;
;
;
var newLineRegex = /\n/g;
function getNewLines(str) {
    return str.match(newLineRegex);
}
function getAllLineNumbers(_ref) {
    var lines = _ref.lines, startingLineNumber = _ref.startingLineNumber, style = _ref.style;
    return lines.map(function(_, i) {
        var number = i + startingLineNumber;
        return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("span", {
            key: "line-".concat(i),
            className: "react-syntax-highlighter-line-number",
            style: typeof style === 'function' ? style(number) : style
        }, "".concat(number, "\n"));
    });
}
function AllLineNumbers(_ref2) {
    var codeString = _ref2.codeString, codeStyle = _ref2.codeStyle, _ref2$containerStyle = _ref2.containerStyle, containerStyle = _ref2$containerStyle === void 0 ? {
        "float": 'left',
        paddingRight: '10px'
    } : _ref2$containerStyle, _ref2$numberStyle = _ref2.numberStyle, numberStyle = _ref2$numberStyle === void 0 ? {} : _ref2$numberStyle, startingLineNumber = _ref2.startingLineNumber;
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("code", {
        style: Object.assign({}, codeStyle, containerStyle)
    }, getAllLineNumbers({
        lines: codeString.replace(/\n$/, '').split('\n'),
        style: numberStyle,
        startingLineNumber: startingLineNumber
    }));
}
function getEmWidthOfNumber(num) {
    return "".concat(num.toString().length, ".25em");
}
function getInlineLineNumber(lineNumber, inlineLineNumberStyle) {
    return {
        type: 'element',
        tagName: 'span',
        properties: {
            key: "line-number--".concat(lineNumber),
            className: [
                'comment',
                'linenumber',
                'react-syntax-highlighter-line-number'
            ],
            style: inlineLineNumberStyle
        },
        children: [
            {
                type: 'text',
                value: lineNumber
            }
        ]
    };
}
function assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber) {
    // minimally necessary styling for line numbers
    var defaultLineNumberStyle = {
        display: 'inline-block',
        minWidth: getEmWidthOfNumber(largestLineNumber),
        paddingRight: '1em',
        textAlign: 'right',
        userSelect: 'none'
    };
    // prep custom styling
    var customLineNumberStyle = typeof lineNumberStyle === 'function' ? lineNumberStyle(lineNumber) : lineNumberStyle;
    // combine
    var assembledStyle = _objectSpread(_objectSpread({}, defaultLineNumberStyle), customLineNumberStyle);
    return assembledStyle;
}
function createLineElement(_ref3) {
    var children = _ref3.children, lineNumber = _ref3.lineNumber, lineNumberStyle = _ref3.lineNumberStyle, largestLineNumber = _ref3.largestLineNumber, showInlineLineNumbers = _ref3.showInlineLineNumbers, _ref3$lineProps = _ref3.lineProps, lineProps = _ref3$lineProps === void 0 ? {} : _ref3$lineProps, _ref3$className = _ref3.className, className = _ref3$className === void 0 ? [] : _ref3$className, showLineNumbers = _ref3.showLineNumbers, wrapLongLines = _ref3.wrapLongLines, _ref3$wrapLines = _ref3.wrapLines, wrapLines = _ref3$wrapLines === void 0 ? false : _ref3$wrapLines;
    var properties = wrapLines ? _objectSpread({}, typeof lineProps === 'function' ? lineProps(lineNumber) : lineProps) : {};
    properties['className'] = properties['className'] ? [].concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$toConsumableArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(properties['className'].trim().split(/\s+/)), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$toConsumableArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(className)) : className;
    if (lineNumber && showInlineLineNumbers) {
        var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber);
        children.unshift(getInlineLineNumber(lineNumber, inlineLineNumberStyle));
    }
    if (wrapLongLines & showLineNumbers) {
        properties.style = _objectSpread({
            display: 'flex'
        }, properties.style);
    }
    return {
        type: 'element',
        tagName: 'span',
        properties: properties,
        children: children
    };
}
function flattenCodeTree(tree) {
    var className = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var newTree = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    if (tree.length === undefined) {
        tree = [
            tree
        ];
    }
    for(var i = 0; i < tree.length; i++){
        var node = tree[i];
        if (node.type === 'text') {
            newTree.push(createLineElement({
                children: [
                    node
                ],
                className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$toConsumableArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(new Set(className))
            }));
        } else if (node.children) {
            var _node$properties;
            var classNames = className.concat(((_node$properties = node.properties) === null || _node$properties === void 0 ? void 0 : _node$properties.className) || []);
            flattenCodeTree(node.children, classNames).forEach(function(i) {
                return newTree.push(i);
            });
        }
    }
    return newTree;
}
function processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines) {
    var _ref4;
    var tree = flattenCodeTree(codeTree.value);
    var newTree = [];
    var lastLineBreakIndex = -1;
    var index = 0;
    function createWrappedLine(children, lineNumber) {
        var className = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        return createLineElement({
            children: children,
            lineNumber: lineNumber,
            lineNumberStyle: lineNumberStyle,
            largestLineNumber: largestLineNumber,
            showInlineLineNumbers: showInlineLineNumbers,
            lineProps: lineProps,
            className: className,
            showLineNumbers: showLineNumbers,
            wrapLongLines: wrapLongLines,
            wrapLines: wrapLines
        });
    }
    function createUnwrappedLine(children, lineNumber) {
        if (showLineNumbers && lineNumber && showInlineLineNumbers) {
            var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber);
            children.unshift(getInlineLineNumber(lineNumber, inlineLineNumberStyle));
        }
        return children;
    }
    function createLine(children, lineNumber) {
        var className = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        return wrapLines || className.length > 0 ? createWrappedLine(children, lineNumber, className) : createUnwrappedLine(children, lineNumber);
    }
    var _loop = function _loop() {
        var node = tree[index];
        var value = node.children[0].value;
        var newLines = getNewLines(value);
        if (newLines) {
            var splitValue = value.split('\n');
            splitValue.forEach(function(text, i) {
                var lineNumber = showLineNumbers && newTree.length + startingLineNumber;
                var newChild = {
                    type: 'text',
                    value: "".concat(text, "\n")
                };
                // if it's the first line
                if (i === 0) {
                    var _children = tree.slice(lastLineBreakIndex + 1, index).concat(createLineElement({
                        children: [
                            newChild
                        ],
                        className: node.properties.className
                    }));
                    var _line = createLine(_children, lineNumber);
                    newTree.push(_line);
                // if it's the last line
                } else if (i === splitValue.length - 1) {
                    var stringChild = tree[index + 1] && tree[index + 1].children && tree[index + 1].children[0];
                    var lastLineInPreviousSpan = {
                        type: 'text',
                        value: "".concat(text)
                    };
                    if (stringChild) {
                        var newElem = createLineElement({
                            children: [
                                lastLineInPreviousSpan
                            ],
                            className: node.properties.className
                        });
                        tree.splice(index + 1, 0, newElem);
                    } else {
                        var _children2 = [
                            lastLineInPreviousSpan
                        ];
                        var _line2 = createLine(_children2, lineNumber, node.properties.className);
                        newTree.push(_line2);
                    }
                // if it's neither the first nor the last line
                } else {
                    var _children3 = [
                        newChild
                    ];
                    var _line3 = createLine(_children3, lineNumber, node.properties.className);
                    newTree.push(_line3);
                }
            });
            lastLineBreakIndex = index;
        }
        index++;
    };
    while(index < tree.length){
        _loop();
    }
    if (lastLineBreakIndex !== tree.length - 1) {
        var children = tree.slice(lastLineBreakIndex + 1, tree.length);
        if (children && children.length) {
            var lineNumber = showLineNumbers && newTree.length + startingLineNumber;
            var line = createLine(children, lineNumber);
            newTree.push(line);
        }
    }
    return wrapLines ? newTree : (_ref4 = []).concat.apply(_ref4, newTree);
}
function defaultRenderer(_ref5) {
    var rows = _ref5.rows, stylesheet = _ref5.stylesheet, useInlineStyles = _ref5.useInlineStyles;
    return rows.map(function(node, i) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$syntax$2d$highlighter$2f$dist$2f$esm$2f$create$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({
            node: node,
            stylesheet: stylesheet,
            useInlineStyles: useInlineStyles,
            key: "code-segment-".concat(i)
        });
    });
}
// only highlight.js has the highlightAuto method
function isHighlightJs(astGenerator) {
    return astGenerator && typeof astGenerator.highlightAuto !== 'undefined';
}
function getCodeTree(_ref6) {
    var astGenerator = _ref6.astGenerator, language = _ref6.language, code = _ref6.code, defaultCodeValue = _ref6.defaultCodeValue;
    // figure out whether we're using lowlight/highlight or refractor/prism
    // then attempt highlighting accordingly
    // lowlight/highlight?
    if (isHighlightJs(astGenerator)) {
        var hasLanguage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$syntax$2d$highlighter$2f$dist$2f$esm$2f$checkForListedLanguage$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(astGenerator, language);
        if (language === 'text') {
            return {
                value: defaultCodeValue,
                language: 'text'
            };
        } else if (hasLanguage) {
            return astGenerator.highlight(language, code);
        } else {
            return astGenerator.highlightAuto(code);
        }
    }
    // must be refractor/prism, then
    try {
        return language && language !== 'text' ? {
            value: astGenerator.highlight(code, language)
        } : {
            value: defaultCodeValue
        };
    } catch (e) {
        return {
            value: defaultCodeValue
        };
    }
}
function __TURBOPACK__default__export__(defaultAstGenerator, defaultStyle) {
    return function SyntaxHighlighter(_ref7) {
        var _code$match$length, _code$match;
        var language = _ref7.language, children = _ref7.children, _ref7$style = _ref7.style, style = _ref7$style === void 0 ? defaultStyle : _ref7$style, _ref7$customStyle = _ref7.customStyle, customStyle = _ref7$customStyle === void 0 ? {} : _ref7$customStyle, _ref7$codeTagProps = _ref7.codeTagProps, codeTagProps = _ref7$codeTagProps === void 0 ? {
            className: language ? "language-".concat(language) : undefined,
            style: _objectSpread(_objectSpread({}, style['code[class*="language-"]']), style["code[class*=\"language-".concat(language, "\"]")])
        } : _ref7$codeTagProps, _ref7$useInlineStyles = _ref7.useInlineStyles, useInlineStyles = _ref7$useInlineStyles === void 0 ? true : _ref7$useInlineStyles, _ref7$showLineNumbers = _ref7.showLineNumbers, showLineNumbers = _ref7$showLineNumbers === void 0 ? false : _ref7$showLineNumbers, _ref7$showInlineLineN = _ref7.showInlineLineNumbers, showInlineLineNumbers = _ref7$showInlineLineN === void 0 ? true : _ref7$showInlineLineN, _ref7$startingLineNum = _ref7.startingLineNumber, startingLineNumber = _ref7$startingLineNum === void 0 ? 1 : _ref7$startingLineNum, lineNumberContainerStyle = _ref7.lineNumberContainerStyle, _ref7$lineNumberStyle = _ref7.lineNumberStyle, lineNumberStyle = _ref7$lineNumberStyle === void 0 ? {} : _ref7$lineNumberStyle, wrapLines = _ref7.wrapLines, _ref7$wrapLongLines = _ref7.wrapLongLines, wrapLongLines = _ref7$wrapLongLines === void 0 ? false : _ref7$wrapLongLines, _ref7$lineProps = _ref7.lineProps, lineProps = _ref7$lineProps === void 0 ? {} : _ref7$lineProps, renderer = _ref7.renderer, _ref7$PreTag = _ref7.PreTag, PreTag = _ref7$PreTag === void 0 ? 'pre' : _ref7$PreTag, _ref7$CodeTag = _ref7.CodeTag, CodeTag = _ref7$CodeTag === void 0 ? 'code' : _ref7$CodeTag, _ref7$code = _ref7.code, code = _ref7$code === void 0 ? (Array.isArray(children) ? children[0] : children) || '' : _ref7$code, astGenerator = _ref7.astGenerator, rest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$objectWithoutProperties$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(_ref7, _excluded);
        astGenerator = astGenerator || defaultAstGenerator;
        var allLineNumbers = showLineNumbers ? /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(AllLineNumbers, {
            containerStyle: lineNumberContainerStyle,
            codeStyle: codeTagProps.style || {},
            numberStyle: lineNumberStyle,
            startingLineNumber: startingLineNumber,
            codeString: code
        }) : null;
        var defaultPreStyle = style.hljs || style['pre[class*="language-"]'] || {
            backgroundColor: '#fff'
        };
        var generatorClassName = isHighlightJs(astGenerator) ? 'hljs' : 'prismjs';
        var preProps = useInlineStyles ? Object.assign({}, rest, {
            style: Object.assign({}, defaultPreStyle, customStyle)
        }) : Object.assign({}, rest, {
            className: rest.className ? "".concat(generatorClassName, " ").concat(rest.className) : generatorClassName,
            style: Object.assign({}, customStyle)
        });
        if (wrapLongLines) {
            codeTagProps.style = _objectSpread({
                whiteSpace: 'pre-wrap'
            }, codeTagProps.style);
        } else {
            codeTagProps.style = _objectSpread({
                whiteSpace: 'pre'
            }, codeTagProps.style);
        }
        if (!astGenerator) {
            return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(PreTag, preProps, allLineNumbers, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(CodeTag, codeTagProps, code));
        }
        /*
     * Some custom renderers rely on individual row elements so we need to turn wrapLines on
     * if renderer is provided and wrapLines is undefined.
     */ if (wrapLines === undefined && renderer || wrapLongLines) wrapLines = true;
        renderer = renderer || defaultRenderer;
        var defaultCodeValue = [
            {
                type: 'text',
                value: code
            }
        ];
        var codeTree = getCodeTree({
            astGenerator: astGenerator,
            language: language,
            code: code,
            defaultCodeValue: defaultCodeValue
        });
        if (codeTree.language === null) {
            codeTree.value = defaultCodeValue;
        }
        // pre-determine largest line number so that we can force minWidth on all linenumber elements
        var lineBreakCount = (_code$match$length = (_code$match = code.match(/\n/g)) === null || _code$match === void 0 ? void 0 : _code$match.length) !== null && _code$match$length !== void 0 ? _code$match$length : 0;
        var largestLineNumber = startingLineNumber + lineBreakCount;
        var rows = processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines);
        return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(PreTag, preProps, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(CodeTag, codeTagProps, !showInlineLineNumbers && allLineNumbers, renderer({
            rows: rows,
            stylesheet: style,
            useInlineStyles: useInlineStyles
        })));
    };
}
}),
"[project]/node_modules/react-syntax-highlighter/dist/esm/light.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$syntax$2d$highlighter$2f$dist$2f$esm$2f$highlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-syntax-highlighter/dist/esm/highlight.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lowlight$2f$lib$2f$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lowlight/lib/core.js [app-client] (ecmascript)");
;
;
var SyntaxHighlighter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$syntax$2d$highlighter$2f$dist$2f$esm$2f$highlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lowlight$2f$lib$2f$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], {});
SyntaxHighlighter.registerLanguage = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lowlight$2f$lib$2f$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].registerLanguage;
const __TURBOPACK__default__export__ = SyntaxHighlighter;
}),
"[project]/node_modules/react-syntax-highlighter/dist/esm/languages/hljs/javascript.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highlight$2e$js$2f$lib$2f$languages$2f$javascript$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highlight.js/lib/languages/javascript.js [app-client] (ecmascript)");
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highlight$2e$js$2f$lib$2f$languages$2f$javascript$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
}),
"[project]/node_modules/react-syntax-highlighter/dist/esm/languages/hljs/json.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highlight$2e$js$2f$lib$2f$languages$2f$json$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highlight.js/lib/languages/json.js [app-client] (ecmascript)");
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highlight$2e$js$2f$lib$2f$languages$2f$json$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
}),
"[project]/node_modules/react-syntax-highlighter/dist/esm/languages/hljs/xml.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highlight$2e$js$2f$lib$2f$languages$2f$xml$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highlight.js/lib/languages/xml.js [app-client] (ecmascript)");
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highlight$2e$js$2f$lib$2f$languages$2f$xml$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
}),
"[project]/node_modules/react-syntax-highlighter/dist/esm/languages/hljs/bash.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highlight$2e$js$2f$lib$2f$languages$2f$bash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highlight.js/lib/languages/bash.js [app-client] (ecmascript)");
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highlight$2e$js$2f$lib$2f$languages$2f$bash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
}),
"[project]/node_modules/react-syntax-highlighter/dist/esm/languages/hljs/yaml.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highlight$2e$js$2f$lib$2f$languages$2f$yaml$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highlight.js/lib/languages/yaml.js [app-client] (ecmascript)");
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highlight$2e$js$2f$lib$2f$languages$2f$yaml$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
}),
"[project]/node_modules/react-syntax-highlighter/dist/esm/languages/hljs/http.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highlight$2e$js$2f$lib$2f$languages$2f$http$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highlight.js/lib/languages/http.js [app-client] (ecmascript)");
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highlight$2e$js$2f$lib$2f$languages$2f$http$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
}),
"[project]/node_modules/react-syntax-highlighter/dist/esm/languages/hljs/powershell.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highlight$2e$js$2f$lib$2f$languages$2f$powershell$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highlight.js/lib/languages/powershell.js [app-client] (ecmascript)");
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highlight$2e$js$2f$lib$2f$languages$2f$powershell$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
}),
"[project]/node_modules/react-syntax-highlighter/dist/esm/styles/hljs/agate.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
const __TURBOPACK__default__export__ = {
    "hljs": {
        "display": "block",
        "overflowX": "auto",
        "padding": "0.5em",
        "background": "#333",
        "color": "white"
    },
    "hljs-name": {
        "fontWeight": "bold"
    },
    "hljs-strong": {
        "fontWeight": "bold"
    },
    "hljs-code": {
        "fontStyle": "italic",
        "color": "#888"
    },
    "hljs-emphasis": {
        "fontStyle": "italic"
    },
    "hljs-tag": {
        "color": "#62c8f3"
    },
    "hljs-variable": {
        "color": "#ade5fc"
    },
    "hljs-template-variable": {
        "color": "#ade5fc"
    },
    "hljs-selector-id": {
        "color": "#ade5fc"
    },
    "hljs-selector-class": {
        "color": "#ade5fc"
    },
    "hljs-string": {
        "color": "#a2fca2"
    },
    "hljs-bullet": {
        "color": "#d36363"
    },
    "hljs-type": {
        "color": "#ffa"
    },
    "hljs-title": {
        "color": "#ffa"
    },
    "hljs-section": {
        "color": "#ffa"
    },
    "hljs-attribute": {
        "color": "#ffa"
    },
    "hljs-quote": {
        "color": "#ffa"
    },
    "hljs-built_in": {
        "color": "#ffa"
    },
    "hljs-builtin-name": {
        "color": "#ffa"
    },
    "hljs-number": {
        "color": "#d36363"
    },
    "hljs-symbol": {
        "color": "#d36363"
    },
    "hljs-keyword": {
        "color": "#fcc28c"
    },
    "hljs-selector-tag": {
        "color": "#fcc28c"
    },
    "hljs-literal": {
        "color": "#fcc28c"
    },
    "hljs-comment": {
        "color": "#888"
    },
    "hljs-deletion": {
        "color": "#333",
        "backgroundColor": "#fc9b9b"
    },
    "hljs-regexp": {
        "color": "#c6b4f0"
    },
    "hljs-link": {
        "color": "#c6b4f0"
    },
    "hljs-meta": {
        "color": "#fc9b9b"
    },
    "hljs-addition": {
        "backgroundColor": "#a2fca2",
        "color": "#333"
    }
};
}),
"[project]/node_modules/react-syntax-highlighter/dist/esm/styles/hljs/arta.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
const __TURBOPACK__default__export__ = {
    "hljs": {
        "display": "block",
        "overflowX": "auto",
        "padding": "0.5em",
        "background": "#222",
        "color": "#aaa"
    },
    "hljs-subst": {
        "color": "#aaa"
    },
    "hljs-section": {
        "color": "#fff",
        "fontWeight": "bold"
    },
    "hljs-comment": {
        "color": "#444"
    },
    "hljs-quote": {
        "color": "#444"
    },
    "hljs-meta": {
        "color": "#444"
    },
    "hljs-string": {
        "color": "#ffcc33"
    },
    "hljs-symbol": {
        "color": "#ffcc33"
    },
    "hljs-bullet": {
        "color": "#ffcc33"
    },
    "hljs-regexp": {
        "color": "#ffcc33"
    },
    "hljs-number": {
        "color": "#00cc66"
    },
    "hljs-addition": {
        "color": "#00cc66"
    },
    "hljs-built_in": {
        "color": "#32aaee"
    },
    "hljs-builtin-name": {
        "color": "#32aaee"
    },
    "hljs-literal": {
        "color": "#32aaee"
    },
    "hljs-type": {
        "color": "#32aaee"
    },
    "hljs-template-variable": {
        "color": "#32aaee"
    },
    "hljs-attribute": {
        "color": "#32aaee"
    },
    "hljs-link": {
        "color": "#32aaee"
    },
    "hljs-keyword": {
        "color": "#6644aa"
    },
    "hljs-selector-tag": {
        "color": "#6644aa"
    },
    "hljs-name": {
        "color": "#6644aa"
    },
    "hljs-selector-id": {
        "color": "#6644aa"
    },
    "hljs-selector-class": {
        "color": "#6644aa"
    },
    "hljs-title": {
        "color": "#bb1166"
    },
    "hljs-variable": {
        "color": "#bb1166"
    },
    "hljs-deletion": {
        "color": "#bb1166"
    },
    "hljs-template-tag": {
        "color": "#bb1166"
    },
    "hljs-doctag": {
        "fontWeight": "bold"
    },
    "hljs-strong": {
        "fontWeight": "bold"
    },
    "hljs-emphasis": {
        "fontStyle": "italic"
    }
};
}),
"[project]/node_modules/react-syntax-highlighter/dist/esm/styles/hljs/monokai.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
const __TURBOPACK__default__export__ = {
    "hljs": {
        "display": "block",
        "overflowX": "auto",
        "padding": "0.5em",
        "background": "#272822",
        "color": "#ddd"
    },
    "hljs-tag": {
        "color": "#f92672"
    },
    "hljs-keyword": {
        "color": "#f92672",
        "fontWeight": "bold"
    },
    "hljs-selector-tag": {
        "color": "#f92672",
        "fontWeight": "bold"
    },
    "hljs-literal": {
        "color": "#f92672",
        "fontWeight": "bold"
    },
    "hljs-strong": {
        "color": "#f92672"
    },
    "hljs-name": {
        "color": "#f92672"
    },
    "hljs-code": {
        "color": "#66d9ef"
    },
    "hljs-class .hljs-title": {
        "color": "white"
    },
    "hljs-attribute": {
        "color": "#bf79db"
    },
    "hljs-symbol": {
        "color": "#bf79db"
    },
    "hljs-regexp": {
        "color": "#bf79db"
    },
    "hljs-link": {
        "color": "#bf79db"
    },
    "hljs-string": {
        "color": "#a6e22e"
    },
    "hljs-bullet": {
        "color": "#a6e22e"
    },
    "hljs-subst": {
        "color": "#a6e22e"
    },
    "hljs-title": {
        "color": "#a6e22e",
        "fontWeight": "bold"
    },
    "hljs-section": {
        "color": "#a6e22e",
        "fontWeight": "bold"
    },
    "hljs-emphasis": {
        "color": "#a6e22e"
    },
    "hljs-type": {
        "color": "#a6e22e",
        "fontWeight": "bold"
    },
    "hljs-built_in": {
        "color": "#a6e22e"
    },
    "hljs-builtin-name": {
        "color": "#a6e22e"
    },
    "hljs-selector-attr": {
        "color": "#a6e22e"
    },
    "hljs-selector-pseudo": {
        "color": "#a6e22e"
    },
    "hljs-addition": {
        "color": "#a6e22e"
    },
    "hljs-variable": {
        "color": "#a6e22e"
    },
    "hljs-template-tag": {
        "color": "#a6e22e"
    },
    "hljs-template-variable": {
        "color": "#a6e22e"
    },
    "hljs-comment": {
        "color": "#75715e"
    },
    "hljs-quote": {
        "color": "#75715e"
    },
    "hljs-deletion": {
        "color": "#75715e"
    },
    "hljs-meta": {
        "color": "#75715e"
    },
    "hljs-doctag": {
        "fontWeight": "bold"
    },
    "hljs-selector-id": {
        "fontWeight": "bold"
    }
};
}),
"[project]/node_modules/react-syntax-highlighter/dist/esm/styles/hljs/nord.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
const __TURBOPACK__default__export__ = {
    "hljs": {
        "display": "block",
        "overflowX": "auto",
        "padding": "0.5em",
        "background": "#2E3440",
        "color": "#D8DEE9"
    },
    "hljs-subst": {
        "color": "#D8DEE9"
    },
    "hljs-selector-tag": {
        "color": "#81A1C1"
    },
    "hljs-selector-id": {
        "color": "#8FBCBB",
        "fontWeight": "bold"
    },
    "hljs-selector-class": {
        "color": "#8FBCBB"
    },
    "hljs-selector-attr": {
        "color": "#8FBCBB"
    },
    "hljs-selector-pseudo": {
        "color": "#88C0D0"
    },
    "hljs-addition": {
        "backgroundColor": "rgba(163, 190, 140, 0.5)"
    },
    "hljs-deletion": {
        "backgroundColor": "rgba(191, 97, 106, 0.5)"
    },
    "hljs-built_in": {
        "color": "#8FBCBB"
    },
    "hljs-type": {
        "color": "#8FBCBB"
    },
    "hljs-class": {
        "color": "#8FBCBB"
    },
    "hljs-function": {
        "color": "#88C0D0"
    },
    "hljs-function > .hljs-title": {
        "color": "#88C0D0"
    },
    "hljs-keyword": {
        "color": "#81A1C1"
    },
    "hljs-literal": {
        "color": "#81A1C1"
    },
    "hljs-symbol": {
        "color": "#81A1C1"
    },
    "hljs-number": {
        "color": "#B48EAD"
    },
    "hljs-regexp": {
        "color": "#EBCB8B"
    },
    "hljs-string": {
        "color": "#A3BE8C"
    },
    "hljs-title": {
        "color": "#8FBCBB"
    },
    "hljs-params": {
        "color": "#D8DEE9"
    },
    "hljs-bullet": {
        "color": "#81A1C1"
    },
    "hljs-code": {
        "color": "#8FBCBB"
    },
    "hljs-emphasis": {
        "fontStyle": "italic"
    },
    "hljs-formula": {
        "color": "#8FBCBB"
    },
    "hljs-strong": {
        "fontWeight": "bold"
    },
    "hljs-link:hover": {
        "textDecoration": "underline"
    },
    "hljs-quote": {
        "color": "#4C566A"
    },
    "hljs-comment": {
        "color": "#4C566A"
    },
    "hljs-doctag": {
        "color": "#8FBCBB"
    },
    "hljs-meta": {
        "color": "#5E81AC"
    },
    "hljs-meta-keyword": {
        "color": "#5E81AC"
    },
    "hljs-meta-string": {
        "color": "#A3BE8C"
    },
    "hljs-attr": {
        "color": "#8FBCBB"
    },
    "hljs-attribute": {
        "color": "#D8DEE9"
    },
    "hljs-builtin-name": {
        "color": "#81A1C1"
    },
    "hljs-name": {
        "color": "#81A1C1"
    },
    "hljs-section": {
        "color": "#88C0D0"
    },
    "hljs-tag": {
        "color": "#81A1C1"
    },
    "hljs-variable": {
        "color": "#D8DEE9"
    },
    "hljs-template-variable": {
        "color": "#D8DEE9"
    },
    "hljs-template-tag": {
        "color": "#5E81AC"
    },
    "abnf .hljs-attribute": {
        "color": "#88C0D0"
    },
    "abnf .hljs-symbol": {
        "color": "#EBCB8B"
    },
    "apache .hljs-attribute": {
        "color": "#88C0D0"
    },
    "apache .hljs-section": {
        "color": "#81A1C1"
    },
    "arduino .hljs-built_in": {
        "color": "#88C0D0"
    },
    "aspectj .hljs-meta": {
        "color": "#D08770"
    },
    "aspectj > .hljs-title": {
        "color": "#88C0D0"
    },
    "bnf .hljs-attribute": {
        "color": "#8FBCBB"
    },
    "clojure .hljs-name": {
        "color": "#88C0D0"
    },
    "clojure .hljs-symbol": {
        "color": "#EBCB8B"
    },
    "coq .hljs-built_in": {
        "color": "#88C0D0"
    },
    "cpp .hljs-meta-string": {
        "color": "#8FBCBB"
    },
    "css .hljs-built_in": {
        "color": "#88C0D0"
    },
    "css .hljs-keyword": {
        "color": "#D08770"
    },
    "diff .hljs-meta": {
        "color": "#8FBCBB"
    },
    "ebnf .hljs-attribute": {
        "color": "#8FBCBB"
    },
    "glsl .hljs-built_in": {
        "color": "#88C0D0"
    },
    "groovy .hljs-meta:not(:first-child)": {
        "color": "#D08770"
    },
    "haxe .hljs-meta": {
        "color": "#D08770"
    },
    "java .hljs-meta": {
        "color": "#D08770"
    },
    "ldif .hljs-attribute": {
        "color": "#8FBCBB"
    },
    "lisp .hljs-name": {
        "color": "#88C0D0"
    },
    "lua .hljs-built_in": {
        "color": "#88C0D0"
    },
    "moonscript .hljs-built_in": {
        "color": "#88C0D0"
    },
    "nginx .hljs-attribute": {
        "color": "#88C0D0"
    },
    "nginx .hljs-section": {
        "color": "#5E81AC"
    },
    "pf .hljs-built_in": {
        "color": "#88C0D0"
    },
    "processing .hljs-built_in": {
        "color": "#88C0D0"
    },
    "scss .hljs-keyword": {
        "color": "#81A1C1"
    },
    "stylus .hljs-keyword": {
        "color": "#81A1C1"
    },
    "swift .hljs-meta": {
        "color": "#D08770"
    },
    "vim .hljs-built_in": {
        "color": "#88C0D0",
        "fontStyle": "italic"
    },
    "yaml .hljs-meta": {
        "color": "#D08770"
    }
};
}),
"[project]/node_modules/react-syntax-highlighter/dist/esm/styles/hljs/obsidian.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
const __TURBOPACK__default__export__ = {
    "hljs": {
        "display": "block",
        "overflowX": "auto",
        "padding": "0.5em",
        "background": "#282b2e",
        "color": "#e0e2e4"
    },
    "hljs-keyword": {
        "color": "#93c763",
        "fontWeight": "bold"
    },
    "hljs-selector-tag": {
        "color": "#93c763",
        "fontWeight": "bold"
    },
    "hljs-literal": {
        "color": "#93c763",
        "fontWeight": "bold"
    },
    "hljs-selector-id": {
        "color": "#93c763"
    },
    "hljs-number": {
        "color": "#ffcd22"
    },
    "hljs-attribute": {
        "color": "#668bb0"
    },
    "hljs-code": {
        "color": "white"
    },
    "hljs-class .hljs-title": {
        "color": "white"
    },
    "hljs-section": {
        "color": "white",
        "fontWeight": "bold"
    },
    "hljs-regexp": {
        "color": "#d39745"
    },
    "hljs-link": {
        "color": "#d39745"
    },
    "hljs-meta": {
        "color": "#557182"
    },
    "hljs-tag": {
        "color": "#8cbbad"
    },
    "hljs-name": {
        "color": "#8cbbad",
        "fontWeight": "bold"
    },
    "hljs-bullet": {
        "color": "#8cbbad"
    },
    "hljs-subst": {
        "color": "#8cbbad"
    },
    "hljs-emphasis": {
        "color": "#8cbbad"
    },
    "hljs-type": {
        "color": "#8cbbad",
        "fontWeight": "bold"
    },
    "hljs-built_in": {
        "color": "#8cbbad"
    },
    "hljs-selector-attr": {
        "color": "#8cbbad"
    },
    "hljs-selector-pseudo": {
        "color": "#8cbbad"
    },
    "hljs-addition": {
        "color": "#8cbbad"
    },
    "hljs-variable": {
        "color": "#8cbbad"
    },
    "hljs-template-tag": {
        "color": "#8cbbad"
    },
    "hljs-template-variable": {
        "color": "#8cbbad"
    },
    "hljs-string": {
        "color": "#ec7600"
    },
    "hljs-symbol": {
        "color": "#ec7600"
    },
    "hljs-comment": {
        "color": "#818e96"
    },
    "hljs-quote": {
        "color": "#818e96"
    },
    "hljs-deletion": {
        "color": "#818e96"
    },
    "hljs-selector-class": {
        "color": "#A082BD"
    },
    "hljs-doctag": {
        "fontWeight": "bold"
    },
    "hljs-title": {
        "fontWeight": "bold"
    },
    "hljs-strong": {
        "fontWeight": "bold"
    }
};
}),
"[project]/node_modules/react-syntax-highlighter/dist/esm/styles/hljs/tomorrow-night.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
const __TURBOPACK__default__export__ = {
    "hljs-comment": {
        "color": "#969896"
    },
    "hljs-quote": {
        "color": "#969896"
    },
    "hljs-variable": {
        "color": "#cc6666"
    },
    "hljs-template-variable": {
        "color": "#cc6666"
    },
    "hljs-tag": {
        "color": "#cc6666"
    },
    "hljs-name": {
        "color": "#cc6666"
    },
    "hljs-selector-id": {
        "color": "#cc6666"
    },
    "hljs-selector-class": {
        "color": "#cc6666"
    },
    "hljs-regexp": {
        "color": "#cc6666"
    },
    "hljs-deletion": {
        "color": "#cc6666"
    },
    "hljs-number": {
        "color": "#de935f"
    },
    "hljs-built_in": {
        "color": "#de935f"
    },
    "hljs-builtin-name": {
        "color": "#de935f"
    },
    "hljs-literal": {
        "color": "#de935f"
    },
    "hljs-type": {
        "color": "#de935f"
    },
    "hljs-params": {
        "color": "#de935f"
    },
    "hljs-meta": {
        "color": "#de935f"
    },
    "hljs-link": {
        "color": "#de935f"
    },
    "hljs-attribute": {
        "color": "#f0c674"
    },
    "hljs-string": {
        "color": "#b5bd68"
    },
    "hljs-symbol": {
        "color": "#b5bd68"
    },
    "hljs-bullet": {
        "color": "#b5bd68"
    },
    "hljs-addition": {
        "color": "#b5bd68"
    },
    "hljs-title": {
        "color": "#81a2be"
    },
    "hljs-section": {
        "color": "#81a2be"
    },
    "hljs-keyword": {
        "color": "#b294bb"
    },
    "hljs-selector-tag": {
        "color": "#b294bb"
    },
    "hljs": {
        "display": "block",
        "overflowX": "auto",
        "background": "#1d1f21",
        "color": "#c5c8c6",
        "padding": "0.5em"
    },
    "hljs-emphasis": {
        "fontStyle": "italic"
    },
    "hljs-strong": {
        "fontWeight": "bold"
    }
};
}),
"[project]/node_modules/react-syntax-highlighter/dist/esm/styles/hljs/idea.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
const __TURBOPACK__default__export__ = {
    "hljs": {
        "display": "block",
        "overflowX": "auto",
        "padding": "0.5em",
        "color": "#000",
        "background": "#fff"
    },
    "hljs-subst": {
        "fontWeight": "normal",
        "color": "#000"
    },
    "hljs-title": {
        "fontWeight": "normal",
        "color": "#000"
    },
    "hljs-comment": {
        "color": "#808080",
        "fontStyle": "italic"
    },
    "hljs-quote": {
        "color": "#808080",
        "fontStyle": "italic"
    },
    "hljs-meta": {
        "color": "#808000"
    },
    "hljs-tag": {
        "background": "#efefef"
    },
    "hljs-section": {
        "fontWeight": "bold",
        "color": "#000080"
    },
    "hljs-name": {
        "fontWeight": "bold",
        "color": "#000080"
    },
    "hljs-literal": {
        "fontWeight": "bold",
        "color": "#000080"
    },
    "hljs-keyword": {
        "fontWeight": "bold",
        "color": "#000080"
    },
    "hljs-selector-tag": {
        "fontWeight": "bold",
        "color": "#000080"
    },
    "hljs-type": {
        "fontWeight": "bold",
        "color": "#000080"
    },
    "hljs-selector-id": {
        "fontWeight": "bold",
        "color": "#000080"
    },
    "hljs-selector-class": {
        "fontWeight": "bold",
        "color": "#000080"
    },
    "hljs-attribute": {
        "fontWeight": "bold",
        "color": "#0000ff"
    },
    "hljs-number": {
        "fontWeight": "normal",
        "color": "#0000ff"
    },
    "hljs-regexp": {
        "fontWeight": "normal",
        "color": "#0000ff"
    },
    "hljs-link": {
        "fontWeight": "normal",
        "color": "#0000ff"
    },
    "hljs-string": {
        "color": "#008000",
        "fontWeight": "bold"
    },
    "hljs-symbol": {
        "color": "#000",
        "background": "#d0eded",
        "fontStyle": "italic"
    },
    "hljs-bullet": {
        "color": "#000",
        "background": "#d0eded",
        "fontStyle": "italic"
    },
    "hljs-formula": {
        "color": "#000",
        "background": "#d0eded",
        "fontStyle": "italic"
    },
    "hljs-doctag": {
        "textDecoration": "underline"
    },
    "hljs-variable": {
        "color": "#660e7a"
    },
    "hljs-template-variable": {
        "color": "#660e7a"
    },
    "hljs-addition": {
        "background": "#baeeba"
    },
    "hljs-deletion": {
        "background": "#ffc8bd"
    },
    "hljs-emphasis": {
        "fontStyle": "italic"
    },
    "hljs-strong": {
        "fontWeight": "bold"
    }
};
}),
"[project]/node_modules/format/format.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

//
// format - printf-like string formatting for JavaScript
// github.com/samsonjs/format
// @_sjs
//
// Copyright 2010 - 2013 Sami Samhuri <sami@samhuri.net>
//
// MIT License
// http://sjs.mit-license.org
//
;
(function() {
    //// Export the API
    var namespace;
    // CommonJS / Node module
    if ("TURBOPACK compile-time truthy", 1) {
        namespace = module.exports = format;
    } else //TURBOPACK unreachable
    ;
    namespace.format = format;
    namespace.vsprintf = vsprintf;
    if (typeof console !== 'undefined' && typeof console.log === 'function') {
        namespace.printf = printf;
    }
    function printf() {
        console.log(format.apply(null, arguments));
    }
    function vsprintf(fmt, replacements) {
        return format.apply(null, [
            fmt
        ].concat(replacements));
    }
    function format(fmt) {
        var argIndex = 1 // skip initial format argument
        , args = [].slice.call(arguments), i = 0, n = fmt.length, result = '', c, escaped = false, arg, tmp, leadingZero = false, precision, nextArg = function() {
            return args[argIndex++];
        }, slurpNumber = function() {
            var digits = '';
            while(/\d/.test(fmt[i])){
                digits += fmt[i++];
                c = fmt[i];
            }
            return digits.length > 0 ? parseInt(digits) : null;
        };
        for(; i < n; ++i){
            c = fmt[i];
            if (escaped) {
                escaped = false;
                if (c == '.') {
                    leadingZero = false;
                    c = fmt[++i];
                } else if (c == '0' && fmt[i + 1] == '.') {
                    leadingZero = true;
                    i += 2;
                    c = fmt[i];
                } else {
                    leadingZero = true;
                }
                precision = slurpNumber();
                switch(c){
                    case 'b':
                        result += parseInt(nextArg(), 10).toString(2);
                        break;
                    case 'c':
                        arg = nextArg();
                        if (typeof arg === 'string' || arg instanceof String) result += arg;
                        else result += String.fromCharCode(parseInt(arg, 10));
                        break;
                    case 'd':
                        result += parseInt(nextArg(), 10);
                        break;
                    case 'f':
                        tmp = String(parseFloat(nextArg()).toFixed(precision || 6));
                        result += leadingZero ? tmp : tmp.replace(/^0/, '');
                        break;
                    case 'j':
                        result += JSON.stringify(nextArg());
                        break;
                    case 'o':
                        result += '0' + parseInt(nextArg(), 10).toString(8);
                        break;
                    case 's':
                        result += nextArg();
                        break;
                    case 'x':
                        result += '0x' + parseInt(nextArg(), 10).toString(16);
                        break;
                    case 'X':
                        result += '0x' + parseInt(nextArg(), 10).toString(16).toUpperCase();
                        break;
                    default:
                        result += c;
                        break;
                }
            } else if (c === '%') {
                escaped = true;
            } else {
                result += c;
            }
        }
        return result;
    }
})();
}),
"[project]/node_modules/fault/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var formatter = __turbopack_context__.r("[project]/node_modules/format/format.js [app-client] (ecmascript)");
var fault = create(Error);
module.exports = fault;
fault.eval = create(EvalError);
fault.range = create(RangeError);
fault.reference = create(ReferenceError);
fault.syntax = create(SyntaxError);
fault.type = create(TypeError);
fault.uri = create(URIError);
fault.create = create;
// Create a new `EConstructor`, with the formatted `format` as a first argument.
function create(EConstructor) {
    FormattedError.displayName = EConstructor.displayName || EConstructor.name;
    return FormattedError;
    //TURBOPACK unreachable
    ;
    function FormattedError(format) {
        if (format) {
            format = formatter.apply(null, arguments);
        }
        return new EConstructor(format);
    }
}
}),
"[project]/node_modules/lowlight/lib/core.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var high = __turbopack_context__.r("[project]/node_modules/highlight.js/lib/core.js [app-client] (ecmascript)");
var fault = __turbopack_context__.r("[project]/node_modules/fault/index.js [app-client] (ecmascript)");
exports.highlight = highlight;
exports.highlightAuto = highlightAuto;
exports.registerLanguage = registerLanguage;
exports.listLanguages = listLanguages;
exports.registerAlias = registerAlias;
Emitter.prototype.addText = text;
Emitter.prototype.addKeyword = addKeyword;
Emitter.prototype.addSublanguage = addSublanguage;
Emitter.prototype.openNode = open;
Emitter.prototype.closeNode = close;
Emitter.prototype.closeAllNodes = noop;
Emitter.prototype.finalize = noop;
Emitter.prototype.toHTML = toHtmlNoop;
var defaultPrefix = 'hljs-';
// Highlighting `value` in the language `name`.
function highlight(name, value, options) {
    var before = high.configure({});
    var settings = options || {};
    var prefix = settings.prefix;
    var result;
    if (typeof name !== 'string') {
        throw fault('Expected `string` for name, got `%s`', name);
    }
    if (!high.getLanguage(name)) {
        throw fault('Unknown language: `%s` is not registered', name);
    }
    if (typeof value !== 'string') {
        throw fault('Expected `string` for value, got `%s`', value);
    }
    if (prefix === null || prefix === undefined) {
        prefix = defaultPrefix;
    }
    high.configure({
        __emitter: Emitter,
        classPrefix: prefix
    });
    result = high.highlight(value, {
        language: name,
        ignoreIllegals: true
    });
    high.configure(before || {});
    /* istanbul ignore if - Highlight.js seems to use this (currently) for broken
   * grammars, so lets keep it in there just to be sure. */ if (result.errorRaised) {
        throw result.errorRaised;
    }
    return {
        relevance: result.relevance,
        language: result.language,
        value: result.emitter.rootNode.children
    };
}
function highlightAuto(value, options) {
    var settings = options || {};
    var subset = settings.subset || high.listLanguages();
    var prefix = settings.prefix;
    var length = subset.length;
    var index = -1;
    var result;
    var secondBest;
    var current;
    var name;
    if (prefix === null || prefix === undefined) {
        prefix = defaultPrefix;
    }
    if (typeof value !== 'string') {
        throw fault('Expected `string` for value, got `%s`', value);
    }
    secondBest = {
        relevance: 0,
        language: null,
        value: []
    };
    result = {
        relevance: 0,
        language: null,
        value: []
    };
    while(++index < length){
        name = subset[index];
        if (!high.getLanguage(name)) {
            continue;
        }
        current = highlight(name, value, options);
        current.language = name;
        if (current.relevance > secondBest.relevance) {
            secondBest = current;
        }
        if (current.relevance > result.relevance) {
            secondBest = result;
            result = current;
        }
    }
    if (secondBest.language) {
        result.secondBest = secondBest;
    }
    return result;
}
// Register a language.
function registerLanguage(name, syntax) {
    high.registerLanguage(name, syntax);
}
// Get a list of all registered languages.
function listLanguages() {
    return high.listLanguages();
}
// Register more aliases for an already registered language.
function registerAlias(name, alias) {
    var map = name;
    var key;
    if (alias) {
        map = {};
        map[name] = alias;
    }
    for(key in map){
        high.registerAliases(map[key], {
            languageName: key
        });
    }
}
function Emitter(options) {
    this.options = options;
    this.rootNode = {
        children: []
    };
    this.stack = [
        this.rootNode
    ];
}
function addKeyword(value, name) {
    this.openNode(name);
    this.addText(value);
    this.closeNode();
}
function addSublanguage(other, name) {
    var stack = this.stack;
    var current = stack[stack.length - 1];
    var results = other.rootNode.children;
    var node = name ? {
        type: 'element',
        tagName: 'span',
        properties: {
            className: [
                name
            ]
        },
        children: results
    } : results;
    current.children = current.children.concat(node);
}
function text(value) {
    var stack = this.stack;
    var current;
    var tail;
    if (value === '') return;
    current = stack[stack.length - 1];
    tail = current.children[current.children.length - 1];
    if (tail && tail.type === 'text') {
        tail.value += value;
    } else {
        current.children.push({
            type: 'text',
            value: value
        });
    }
}
function open(name) {
    var stack = this.stack;
    var className = this.options.classPrefix + name;
    var current = stack[stack.length - 1];
    var child = {
        type: 'element',
        tagName: 'span',
        properties: {
            className: [
                className
            ]
        },
        children: []
    };
    current.children.push(child);
    stack.push(child);
}
function close() {
    this.stack.pop();
}
function toHtmlNoop() {
    return '';
}
function noop() {}
}),
"[project]/node_modules/js-file-download/file-download.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = function(data, filename, mime, bom) {
    var blobData = typeof bom !== 'undefined' ? [
        bom,
        data
    ] : [
        data
    ];
    var blob = new Blob(blobData, {
        type: mime || 'application/octet-stream'
    });
    if (typeof window.navigator.msSaveBlob !== 'undefined') {
        // IE workaround for "HTML7007: One or more blob URLs were
        // revoked by closing the blob for which they were created.
        // These URLs will no longer resolve as the data backing
        // the URL has been freed."
        window.navigator.msSaveBlob(blob, filename);
    } else {
        var blobURL = window.URL && window.URL.createObjectURL ? window.URL.createObjectURL(blob) : window.webkitURL.createObjectURL(blob);
        var tempLink = document.createElement('a');
        tempLink.style.display = 'none';
        tempLink.href = blobURL;
        tempLink.setAttribute('download', filename);
        // Safari thinks _blank anchor are pop ups. We only want to set _blank
        // target if the browser does not support the HTML5 download attribute.
        // This allows you to download files in desktop safari if pop up blocking
        // is enabled.
        if (typeof tempLink.download === 'undefined') {
            tempLink.setAttribute('target', '_blank');
        }
        document.body.appendChild(tempLink);
        tempLink.click();
        // Fixes "webkit blob resource error 1"
        setTimeout(function() {
            document.body.removeChild(tempLink);
            window.URL.revokeObjectURL(blobURL);
        }, 200);
    }
};
}),
"[project]/node_modules/repeat-string/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */ /**
 * Results cache
 */ var res = '';
var cache;
/**
 * Expose `repeat`
 */ module.exports = repeat;
/**
 * Repeat the given `string` the specified `number`
 * of times.
 *
 * **Example:**
 *
 * ```js
 * var repeat = require('repeat-string');
 * repeat('A', 5);
 * //=> AAAAA
 * ```
 *
 * @param {String} `string` The string to repeat
 * @param {Number} `number` The number of times to repeat the string
 * @return {String} Repeated string
 * @api public
 */ function repeat(str, num) {
    if (typeof str !== 'string') {
        throw new TypeError('expected a string');
    }
    // cover common, quick use cases
    if (num === 1) return str;
    if (num === 2) return str + str;
    var max = str.length * num;
    if (cache !== str || typeof cache === 'undefined') {
        cache = str;
        res = '';
    } else if (res.length >= max) {
        return res.substr(0, max);
    }
    while(max > res.length && num > 1){
        if (num & 1) {
            res += str;
        }
        num >>= 1;
        str += str;
    }
    res += str;
    res = res.substr(0, max);
    return res;
}
}),
"[project]/node_modules/xml-but-prettier/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var repeat = __turbopack_context__.r("[project]/node_modules/repeat-string/index.js [app-client] (ecmascript)");
var splitOnTags = function splitOnTags(str) {
    return str.split(/(<\/?[^>]+>)/g).filter(function(line) {
        return line.trim() !== '';
    });
};
var isTag = function isTag(str) {
    return /<[^>!]+>/.test(str);
};
var isClosingTag = function isClosingTag(str) {
    return /<\/+[^>]+>/.test(str);
};
var isSelfClosingTag = function isSelfClosingTag(str) {
    return /<[^>]+\/>/.test(str);
};
var isOpeningTag = function isOpeningTag(str) {
    return isTag(str) && !isClosingTag(str) && !isSelfClosingTag(str);
};
module.exports = function(xml) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var indentor = config.indentor, textNodesOnSameLine = config.textNodesOnSameLine;
    var depth = 0;
    var indicesToRemove = [];
    indentor = indentor || '    ';
    var rawResult = lexer(xml).map(function(element, i, arr) {
        var value = element.value, type = element.type;
        if (type === 'ClosingTag') {
            depth--;
        }
        var indentation = repeat(indentor, depth);
        var line = indentation + value;
        if (type === 'OpeningTag') {
            depth++;
        }
        if (textNodesOnSameLine) {
            // Lookbehind for [OpeningTag][Text][ClosingTag]
            var oneBefore = arr[i - 1];
            var twoBefore = arr[i - 2];
            if (type === "ClosingTag" && oneBefore.type === "Text" && twoBefore.type === "OpeningTag") {
                // collapse into a single line
                line = '' + indentation + twoBefore.value + oneBefore.value + value;
                indicesToRemove.push(i - 2, i - 1);
            }
        }
        return line;
    });
    indicesToRemove.forEach(function(idx) {
        return rawResult[idx] = null;
    });
    return rawResult.filter(function(val) {
        return !!val;
    }).join('\n');
};
function lexer(xmlStr) {
    var values = splitOnTags(xmlStr);
    return values.map(function(value) {
        return {
            value: value,
            type: getType(value)
        };
    });
}
// Helpers
function getType(str) {
    if (isClosingTag(str)) {
        return 'ClosingTag';
    }
    if (isOpeningTag(str)) {
        return 'OpeningTag';
    }
    if (isSelfClosingTag(str)) {
        return 'SelfClosingTag';
    }
    return 'Text';
}
}),
"[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ __turbopack_context__.s([
    "__addDisposableResource",
    ()=>__addDisposableResource,
    "__assign",
    ()=>__assign,
    "__asyncDelegator",
    ()=>__asyncDelegator,
    "__asyncGenerator",
    ()=>__asyncGenerator,
    "__asyncValues",
    ()=>__asyncValues,
    "__await",
    ()=>__await,
    "__awaiter",
    ()=>__awaiter,
    "__classPrivateFieldGet",
    ()=>__classPrivateFieldGet,
    "__classPrivateFieldIn",
    ()=>__classPrivateFieldIn,
    "__classPrivateFieldSet",
    ()=>__classPrivateFieldSet,
    "__createBinding",
    ()=>__createBinding,
    "__decorate",
    ()=>__decorate,
    "__disposeResources",
    ()=>__disposeResources,
    "__esDecorate",
    ()=>__esDecorate,
    "__exportStar",
    ()=>__exportStar,
    "__extends",
    ()=>__extends,
    "__generator",
    ()=>__generator,
    "__importDefault",
    ()=>__importDefault,
    "__importStar",
    ()=>__importStar,
    "__makeTemplateObject",
    ()=>__makeTemplateObject,
    "__metadata",
    ()=>__metadata,
    "__param",
    ()=>__param,
    "__propKey",
    ()=>__propKey,
    "__read",
    ()=>__read,
    "__rest",
    ()=>__rest,
    "__rewriteRelativeImportExtension",
    ()=>__rewriteRelativeImportExtension,
    "__runInitializers",
    ()=>__runInitializers,
    "__setFunctionName",
    ()=>__setFunctionName,
    "__spread",
    ()=>__spread,
    "__spreadArray",
    ()=>__spreadArray,
    "__spreadArrays",
    ()=>__spreadArrays,
    "__values",
    ()=>__values,
    "default",
    ()=>__TURBOPACK__default__export__
]);
var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(d, b) {
        d.__proto__ = b;
    } || function(d, b) {
        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return extendStatics(d, b);
};
function __extends(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
function __rest(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
}
function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
        if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
        return f;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for(var i = decorators.length - 1; i >= 0; i--){
        var context = {};
        for(var p in contextIn)context[p] = p === "access" ? {} : contextIn[p];
        for(var p in contextIn.access)context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
            if (done) throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? {
            get: descriptor.get,
            set: descriptor.set
        } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        } else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
}
;
function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for(var i = 0; i < initializers.length; i++){
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
}
;
function __propKey(x) {
    return typeof x === "symbol" ? x : "".concat(x);
}
;
function __setFunctionName(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", {
        configurable: true,
        value: prefix ? "".concat(prefix, " ", name) : name
    });
}
;
function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function __generator(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    //TURBOPACK unreachable
    ;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
var __createBinding = Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
};
function __exportStar(m, o) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
}
function __spread() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
    return ar;
}
function __spreadArrays() {
    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
    return r;
}
function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    //TURBOPACK unreachable
    ;
    function awaitReturn(f) {
        return function(v) {
            return Promise.resolve(v).then(f, reject);
        };
    }
    function verb(n, f) {
        if (g[n]) {
            i[n] = function(v) {
                return new Promise(function(a, b) {
                    q.push([
                        n,
                        v,
                        a,
                        b
                    ]) > 1 || resume(n, v);
                });
            };
            if (f) i[n] = f(i[n]);
        }
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
}
function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
        return this;
    }, i;
    //TURBOPACK unreachable
    ;
    function verb(n, f) {
        i[n] = o[n] ? function(v) {
            return (p = !p) ? {
                value: __await(o[n](v)),
                done: false
            } : f ? f(v) : v;
        } : f;
    }
}
function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    //TURBOPACK unreachable
    ;
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
}
function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", {
            value: raw
        });
    } else {
        cooked.raw = raw;
    }
    return cooked;
}
;
var __setModuleDefault = Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
};
var ownKeys = function(o) {
    ownKeys = Object.getOwnPropertyNames || function(o) {
        var ar = [];
        for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
    };
    return ownKeys(o);
};
function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
    }
    __setModuleDefault(result, mod);
    return result;
}
function __importDefault(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() {
            try {
                inner.call(this);
            } catch (e) {
                return Promise.reject(e);
            }
        };
        env.stack.push({
            value: value,
            dispose: dispose,
            async: async
        });
    } else if (async) {
        env.stack.push({
            async: true
        });
    }
    return value;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
function __disposeResources(env) {
    function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
    }
    var r, s = 0;
    function next() {
        while(r = env.stack.pop()){
            try {
                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                if (r.dispose) {
                    var result = r.dispose.call(r.value);
                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                        fail(e);
                        return next();
                    });
                } else s |= 1;
            } catch (e) {
                fail(e);
            }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
    }
    return next();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
    if (typeof path === "string" && /^\.\.?\//.test(path)) {
        return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
            return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
        });
    }
    return path;
}
const __TURBOPACK__default__export__ = {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __esDecorate,
    __runInitializers,
    __propKey,
    __setFunctionName,
    __metadata,
    __awaiter,
    __generator,
    __createBinding,
    __exportStar,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet,
    __classPrivateFieldIn,
    __addDisposableResource,
    __disposeResources,
    __rewriteRelativeImportExtension
};
}),
"[project]/node_modules/dompurify/dist/purify.es.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*! @license DOMPurify 3.2.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.6/LICENSE */ __turbopack_context__.s([
    "default",
    ()=>purify
]);
const { entries, setPrototypeOf, isFrozen, getPrototypeOf, getOwnPropertyDescriptor } = Object;
let { freeze, seal, create } = Object; // eslint-disable-line import/no-mutable-exports
let { apply, construct } = typeof Reflect !== 'undefined' && Reflect;
if (!freeze) {
    freeze = function freeze(x) {
        return x;
    };
}
if (!seal) {
    seal = function seal(x) {
        return x;
    };
}
if (!apply) {
    apply = function apply(fun, thisValue, args) {
        return fun.apply(thisValue, args);
    };
}
if (!construct) {
    construct = function construct(Func, args) {
        return new Func(...args);
    };
}
const arrayForEach = unapply(Array.prototype.forEach);
const arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);
const arrayPop = unapply(Array.prototype.pop);
const arrayPush = unapply(Array.prototype.push);
const arraySplice = unapply(Array.prototype.splice);
const stringToLowerCase = unapply(String.prototype.toLowerCase);
const stringToString = unapply(String.prototype.toString);
const stringMatch = unapply(String.prototype.match);
const stringReplace = unapply(String.prototype.replace);
const stringIndexOf = unapply(String.prototype.indexOf);
const stringTrim = unapply(String.prototype.trim);
const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
const regExpTest = unapply(RegExp.prototype.test);
const typeErrorCreate = unconstruct(TypeError);
/**
 * Creates a new function that calls the given function with a specified thisArg and arguments.
 *
 * @param func - The function to be wrapped and called.
 * @returns A new function that calls the given function with a specified thisArg and arguments.
 */ function unapply(func) {
    return function(thisArg) {
        if (thisArg instanceof RegExp) {
            thisArg.lastIndex = 0;
        }
        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            args[_key - 1] = arguments[_key];
        }
        return apply(func, thisArg, args);
    };
}
/**
 * Creates a new function that constructs an instance of the given constructor function with the provided arguments.
 *
 * @param func - The constructor function to be wrapped and called.
 * @returns A new function that constructs an instance of the given constructor function with the provided arguments.
 */ function unconstruct(func) {
    return function() {
        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){
            args[_key2] = arguments[_key2];
        }
        return construct(func, args);
    };
}
/**
 * Add properties to a lookup table
 *
 * @param set - The set to which elements will be added.
 * @param array - The array containing elements to be added to the set.
 * @param transformCaseFunc - An optional function to transform the case of each element before adding to the set.
 * @returns The modified set with added elements.
 */ function addToSet(set, array) {
    let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;
    if (setPrototypeOf) {
        // Make 'in' and truthy checks like Boolean(set.constructor)
        // independent of any properties defined on Object.prototype.
        // Prevent prototype setters from intercepting set as a this value.
        setPrototypeOf(set, null);
    }
    let l = array.length;
    while(l--){
        let element = array[l];
        if (typeof element === 'string') {
            const lcElement = transformCaseFunc(element);
            if (lcElement !== element) {
                // Config presets (e.g. tags.js, attrs.js) are immutable.
                if (!isFrozen(array)) {
                    array[l] = lcElement;
                }
                element = lcElement;
            }
        }
        set[element] = true;
    }
    return set;
}
/**
 * Clean up an array to harden against CSPP
 *
 * @param array - The array to be cleaned.
 * @returns The cleaned version of the array
 */ function cleanArray(array) {
    for(let index = 0; index < array.length; index++){
        const isPropertyExist = objectHasOwnProperty(array, index);
        if (!isPropertyExist) {
            array[index] = null;
        }
    }
    return array;
}
/**
 * Shallow clone an object
 *
 * @param object - The object to be cloned.
 * @returns A new object that copies the original.
 */ function clone(object) {
    const newObject = create(null);
    for (const [property, value] of entries(object)){
        const isPropertyExist = objectHasOwnProperty(object, property);
        if (isPropertyExist) {
            if (Array.isArray(value)) {
                newObject[property] = cleanArray(value);
            } else if (value && typeof value === 'object' && value.constructor === Object) {
                newObject[property] = clone(value);
            } else {
                newObject[property] = value;
            }
        }
    }
    return newObject;
}
/**
 * This method automatically checks if the prop is function or getter and behaves accordingly.
 *
 * @param object - The object to look up the getter function in its prototype chain.
 * @param prop - The property name for which to find the getter function.
 * @returns The getter function found in the prototype chain or a fallback function.
 */ function lookupGetter(object, prop) {
    while(object !== null){
        const desc = getOwnPropertyDescriptor(object, prop);
        if (desc) {
            if (desc.get) {
                return unapply(desc.get);
            }
            if (typeof desc.value === 'function') {
                return unapply(desc.value);
            }
        }
        object = getPrototypeOf(object);
    }
    function fallbackValue() {
        return null;
    }
    return fallbackValue;
}
const html$1 = freeze([
    'a',
    'abbr',
    'acronym',
    'address',
    'area',
    'article',
    'aside',
    'audio',
    'b',
    'bdi',
    'bdo',
    'big',
    'blink',
    'blockquote',
    'body',
    'br',
    'button',
    'canvas',
    'caption',
    'center',
    'cite',
    'code',
    'col',
    'colgroup',
    'content',
    'data',
    'datalist',
    'dd',
    'decorator',
    'del',
    'details',
    'dfn',
    'dialog',
    'dir',
    'div',
    'dl',
    'dt',
    'element',
    'em',
    'fieldset',
    'figcaption',
    'figure',
    'font',
    'footer',
    'form',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'head',
    'header',
    'hgroup',
    'hr',
    'html',
    'i',
    'img',
    'input',
    'ins',
    'kbd',
    'label',
    'legend',
    'li',
    'main',
    'map',
    'mark',
    'marquee',
    'menu',
    'menuitem',
    'meter',
    'nav',
    'nobr',
    'ol',
    'optgroup',
    'option',
    'output',
    'p',
    'picture',
    'pre',
    'progress',
    'q',
    'rp',
    'rt',
    'ruby',
    's',
    'samp',
    'section',
    'select',
    'shadow',
    'small',
    'source',
    'spacer',
    'span',
    'strike',
    'strong',
    'style',
    'sub',
    'summary',
    'sup',
    'table',
    'tbody',
    'td',
    'template',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'time',
    'tr',
    'track',
    'tt',
    'u',
    'ul',
    'var',
    'video',
    'wbr'
]);
const svg$1 = freeze([
    'svg',
    'a',
    'altglyph',
    'altglyphdef',
    'altglyphitem',
    'animatecolor',
    'animatemotion',
    'animatetransform',
    'circle',
    'clippath',
    'defs',
    'desc',
    'ellipse',
    'filter',
    'font',
    'g',
    'glyph',
    'glyphref',
    'hkern',
    'image',
    'line',
    'lineargradient',
    'marker',
    'mask',
    'metadata',
    'mpath',
    'path',
    'pattern',
    'polygon',
    'polyline',
    'radialgradient',
    'rect',
    'stop',
    'style',
    'switch',
    'symbol',
    'text',
    'textpath',
    'title',
    'tref',
    'tspan',
    'view',
    'vkern'
]);
const svgFilters = freeze([
    'feBlend',
    'feColorMatrix',
    'feComponentTransfer',
    'feComposite',
    'feConvolveMatrix',
    'feDiffuseLighting',
    'feDisplacementMap',
    'feDistantLight',
    'feDropShadow',
    'feFlood',
    'feFuncA',
    'feFuncB',
    'feFuncG',
    'feFuncR',
    'feGaussianBlur',
    'feImage',
    'feMerge',
    'feMergeNode',
    'feMorphology',
    'feOffset',
    'fePointLight',
    'feSpecularLighting',
    'feSpotLight',
    'feTile',
    'feTurbulence'
]);
// List of SVG elements that are disallowed by default.
// We still need to know them so that we can do namespace
// checks properly in case one wants to add them to
// allow-list.
const svgDisallowed = freeze([
    'animate',
    'color-profile',
    'cursor',
    'discard',
    'font-face',
    'font-face-format',
    'font-face-name',
    'font-face-src',
    'font-face-uri',
    'foreignobject',
    'hatch',
    'hatchpath',
    'mesh',
    'meshgradient',
    'meshpatch',
    'meshrow',
    'missing-glyph',
    'script',
    'set',
    'solidcolor',
    'unknown',
    'use'
]);
const mathMl$1 = freeze([
    'math',
    'menclose',
    'merror',
    'mfenced',
    'mfrac',
    'mglyph',
    'mi',
    'mlabeledtr',
    'mmultiscripts',
    'mn',
    'mo',
    'mover',
    'mpadded',
    'mphantom',
    'mroot',
    'mrow',
    'ms',
    'mspace',
    'msqrt',
    'mstyle',
    'msub',
    'msup',
    'msubsup',
    'mtable',
    'mtd',
    'mtext',
    'mtr',
    'munder',
    'munderover',
    'mprescripts'
]);
// Similarly to SVG, we want to know all MathML elements,
// even those that we disallow by default.
const mathMlDisallowed = freeze([
    'maction',
    'maligngroup',
    'malignmark',
    'mlongdiv',
    'mscarries',
    'mscarry',
    'msgroup',
    'mstack',
    'msline',
    'msrow',
    'semantics',
    'annotation',
    'annotation-xml',
    'mprescripts',
    'none'
]);
const text = freeze([
    '#text'
]);
const html = freeze([
    'accept',
    'action',
    'align',
    'alt',
    'autocapitalize',
    'autocomplete',
    'autopictureinpicture',
    'autoplay',
    'background',
    'bgcolor',
    'border',
    'capture',
    'cellpadding',
    'cellspacing',
    'checked',
    'cite',
    'class',
    'clear',
    'color',
    'cols',
    'colspan',
    'controls',
    'controlslist',
    'coords',
    'crossorigin',
    'datetime',
    'decoding',
    'default',
    'dir',
    'disabled',
    'disablepictureinpicture',
    'disableremoteplayback',
    'download',
    'draggable',
    'enctype',
    'enterkeyhint',
    'face',
    'for',
    'headers',
    'height',
    'hidden',
    'high',
    'href',
    'hreflang',
    'id',
    'inputmode',
    'integrity',
    'ismap',
    'kind',
    'label',
    'lang',
    'list',
    'loading',
    'loop',
    'low',
    'max',
    'maxlength',
    'media',
    'method',
    'min',
    'minlength',
    'multiple',
    'muted',
    'name',
    'nonce',
    'noshade',
    'novalidate',
    'nowrap',
    'open',
    'optimum',
    'pattern',
    'placeholder',
    'playsinline',
    'popover',
    'popovertarget',
    'popovertargetaction',
    'poster',
    'preload',
    'pubdate',
    'radiogroup',
    'readonly',
    'rel',
    'required',
    'rev',
    'reversed',
    'role',
    'rows',
    'rowspan',
    'spellcheck',
    'scope',
    'selected',
    'shape',
    'size',
    'sizes',
    'span',
    'srclang',
    'start',
    'src',
    'srcset',
    'step',
    'style',
    'summary',
    'tabindex',
    'title',
    'translate',
    'type',
    'usemap',
    'valign',
    'value',
    'width',
    'wrap',
    'xmlns',
    'slot'
]);
const svg = freeze([
    'accent-height',
    'accumulate',
    'additive',
    'alignment-baseline',
    'amplitude',
    'ascent',
    'attributename',
    'attributetype',
    'azimuth',
    'basefrequency',
    'baseline-shift',
    'begin',
    'bias',
    'by',
    'class',
    'clip',
    'clippathunits',
    'clip-path',
    'clip-rule',
    'color',
    'color-interpolation',
    'color-interpolation-filters',
    'color-profile',
    'color-rendering',
    'cx',
    'cy',
    'd',
    'dx',
    'dy',
    'diffuseconstant',
    'direction',
    'display',
    'divisor',
    'dur',
    'edgemode',
    'elevation',
    'end',
    'exponent',
    'fill',
    'fill-opacity',
    'fill-rule',
    'filter',
    'filterunits',
    'flood-color',
    'flood-opacity',
    'font-family',
    'font-size',
    'font-size-adjust',
    'font-stretch',
    'font-style',
    'font-variant',
    'font-weight',
    'fx',
    'fy',
    'g1',
    'g2',
    'glyph-name',
    'glyphref',
    'gradientunits',
    'gradienttransform',
    'height',
    'href',
    'id',
    'image-rendering',
    'in',
    'in2',
    'intercept',
    'k',
    'k1',
    'k2',
    'k3',
    'k4',
    'kerning',
    'keypoints',
    'keysplines',
    'keytimes',
    'lang',
    'lengthadjust',
    'letter-spacing',
    'kernelmatrix',
    'kernelunitlength',
    'lighting-color',
    'local',
    'marker-end',
    'marker-mid',
    'marker-start',
    'markerheight',
    'markerunits',
    'markerwidth',
    'maskcontentunits',
    'maskunits',
    'max',
    'mask',
    'media',
    'method',
    'mode',
    'min',
    'name',
    'numoctaves',
    'offset',
    'operator',
    'opacity',
    'order',
    'orient',
    'orientation',
    'origin',
    'overflow',
    'paint-order',
    'path',
    'pathlength',
    'patterncontentunits',
    'patterntransform',
    'patternunits',
    'points',
    'preservealpha',
    'preserveaspectratio',
    'primitiveunits',
    'r',
    'rx',
    'ry',
    'radius',
    'refx',
    'refy',
    'repeatcount',
    'repeatdur',
    'restart',
    'result',
    'rotate',
    'scale',
    'seed',
    'shape-rendering',
    'slope',
    'specularconstant',
    'specularexponent',
    'spreadmethod',
    'startoffset',
    'stddeviation',
    'stitchtiles',
    'stop-color',
    'stop-opacity',
    'stroke-dasharray',
    'stroke-dashoffset',
    'stroke-linecap',
    'stroke-linejoin',
    'stroke-miterlimit',
    'stroke-opacity',
    'stroke',
    'stroke-width',
    'style',
    'surfacescale',
    'systemlanguage',
    'tabindex',
    'tablevalues',
    'targetx',
    'targety',
    'transform',
    'transform-origin',
    'text-anchor',
    'text-decoration',
    'text-rendering',
    'textlength',
    'type',
    'u1',
    'u2',
    'unicode',
    'values',
    'viewbox',
    'visibility',
    'version',
    'vert-adv-y',
    'vert-origin-x',
    'vert-origin-y',
    'width',
    'word-spacing',
    'wrap',
    'writing-mode',
    'xchannelselector',
    'ychannelselector',
    'x',
    'x1',
    'x2',
    'xmlns',
    'y',
    'y1',
    'y2',
    'z',
    'zoomandpan'
]);
const mathMl = freeze([
    'accent',
    'accentunder',
    'align',
    'bevelled',
    'close',
    'columnsalign',
    'columnlines',
    'columnspan',
    'denomalign',
    'depth',
    'dir',
    'display',
    'displaystyle',
    'encoding',
    'fence',
    'frame',
    'height',
    'href',
    'id',
    'largeop',
    'length',
    'linethickness',
    'lspace',
    'lquote',
    'mathbackground',
    'mathcolor',
    'mathsize',
    'mathvariant',
    'maxsize',
    'minsize',
    'movablelimits',
    'notation',
    'numalign',
    'open',
    'rowalign',
    'rowlines',
    'rowspacing',
    'rowspan',
    'rspace',
    'rquote',
    'scriptlevel',
    'scriptminsize',
    'scriptsizemultiplier',
    'selection',
    'separator',
    'separators',
    'stretchy',
    'subscriptshift',
    'supscriptshift',
    'symmetric',
    'voffset',
    'width',
    'xmlns'
]);
const xml = freeze([
    'xlink:href',
    'xml:id',
    'xlink:title',
    'xml:space',
    'xmlns:xlink'
]);
// eslint-disable-next-line unicorn/better-regex
const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
const TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm); // eslint-disable-line unicorn/better-regex
const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/); // eslint-disable-line no-useless-escape
const ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
);
const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
const ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
);
const DOCTYPE_NAME = seal(/^html$/i);
const CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
var EXPRESSIONS = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    ARIA_ATTR: ARIA_ATTR,
    ATTR_WHITESPACE: ATTR_WHITESPACE,
    CUSTOM_ELEMENT: CUSTOM_ELEMENT,
    DATA_ATTR: DATA_ATTR,
    DOCTYPE_NAME: DOCTYPE_NAME,
    ERB_EXPR: ERB_EXPR,
    IS_ALLOWED_URI: IS_ALLOWED_URI,
    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,
    MUSTACHE_EXPR: MUSTACHE_EXPR,
    TMPLIT_EXPR: TMPLIT_EXPR
});
/* eslint-disable @typescript-eslint/indent */ // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
const NODE_TYPE = {
    element: 1,
    attribute: 2,
    text: 3,
    cdataSection: 4,
    entityReference: 5,
    // Deprecated
    entityNode: 6,
    // Deprecated
    progressingInstruction: 7,
    comment: 8,
    document: 9,
    documentType: 10,
    documentFragment: 11,
    notation: 12 // Deprecated
};
const getGlobal = function getGlobal() {
    return typeof window === 'undefined' ? null : window;
};
/**
 * Creates a no-op policy for internal use only.
 * Don't export this function outside this module!
 * @param trustedTypes The policy factory.
 * @param purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).
 * @return The policy created (or null, if Trusted Types
 * are not supported or creating the policy failed).
 */ const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {
    if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
        return null;
    }
    // Allow the callers to control the unique policy name
    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
    // Policy creation with duplicate names throws in Trusted Types.
    let suffix = null;
    const ATTR_NAME = 'data-tt-policy-suffix';
    if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
        suffix = purifyHostElement.getAttribute(ATTR_NAME);
    }
    const policyName = 'dompurify' + (suffix ? '#' + suffix : '');
    try {
        return trustedTypes.createPolicy(policyName, {
            createHTML (html) {
                return html;
            },
            createScriptURL (scriptUrl) {
                return scriptUrl;
            }
        });
    } catch (_) {
        // Policy creation failed (most likely another DOMPurify script has
        // already run). Skip creating the policy, as this will only cause errors
        // if TT are enforced.
        console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
        return null;
    }
};
const _createHooksMap = function _createHooksMap() {
    return {
        afterSanitizeAttributes: [],
        afterSanitizeElements: [],
        afterSanitizeShadowDOM: [],
        beforeSanitizeAttributes: [],
        beforeSanitizeElements: [],
        beforeSanitizeShadowDOM: [],
        uponSanitizeAttribute: [],
        uponSanitizeElement: [],
        uponSanitizeShadowNode: []
    };
};
function createDOMPurify() {
    let window1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();
    const DOMPurify = (root)=>createDOMPurify(root);
    DOMPurify.version = '3.2.6';
    DOMPurify.removed = [];
    if (!window1 || !window1.document || window1.document.nodeType !== NODE_TYPE.document || !window1.Element) {
        // Not running in a browser, provide a factory function
        // so that you can pass your own Window
        DOMPurify.isSupported = false;
        return DOMPurify;
    }
    let { document } = window1;
    const originalDocument = document;
    const currentScript = originalDocument.currentScript;
    const { DocumentFragment, HTMLTemplateElement, Node, Element, NodeFilter, NamedNodeMap = window1.NamedNodeMap || window1.MozNamedAttrMap, HTMLFormElement, DOMParser, trustedTypes } = window1;
    const ElementPrototype = Element.prototype;
    const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
    const remove = lookupGetter(ElementPrototype, 'remove');
    const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
    const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
    const getParentNode = lookupGetter(ElementPrototype, 'parentNode');
    // As per issue #47, the web-components registry is inherited by a
    // new document created via createHTMLDocument. As per the spec
    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
    // a new empty registry is used when creating a template contents owner
    // document, so we use that as our parent document to ensure nothing
    // is inherited.
    if (typeof HTMLTemplateElement === 'function') {
        const template = document.createElement('template');
        if (template.content && template.content.ownerDocument) {
            document = template.content.ownerDocument;
        }
    }
    let trustedTypesPolicy;
    let emptyHTML = '';
    const { implementation, createNodeIterator, createDocumentFragment, getElementsByTagName } = document;
    const { importNode } = originalDocument;
    let hooks = _createHooksMap();
    /**
   * Expose whether this browser supports running the full DOMPurify.
   */ DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;
    const { MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR, DATA_ATTR, ARIA_ATTR, IS_SCRIPT_OR_DATA, ATTR_WHITESPACE, CUSTOM_ELEMENT } = EXPRESSIONS;
    let { IS_ALLOWED_URI: IS_ALLOWED_URI$1 } = EXPRESSIONS;
    /**
   * We consider the elements and attributes below to be safe. Ideally
   * don't add any new ones but feel free to remove unwanted ones.
   */ /* allowed element names */ let ALLOWED_TAGS = null;
    const DEFAULT_ALLOWED_TAGS = addToSet({}, [
        ...html$1,
        ...svg$1,
        ...svgFilters,
        ...mathMl$1,
        ...text
    ]);
    /* Allowed attribute names */ let ALLOWED_ATTR = null;
    const DEFAULT_ALLOWED_ATTR = addToSet({}, [
        ...html,
        ...svg,
        ...mathMl,
        ...xml
    ]);
    /*
   * Configure how DOMPurify should handle custom elements and their attributes as well as customized built-in elements.
   * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
   * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
   * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
   */ let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
        tagNameCheck: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: null
        },
        attributeNameCheck: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: null
        },
        allowCustomizedBuiltInElements: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: false
        }
    }));
    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */ let FORBID_TAGS = null;
    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */ let FORBID_ATTR = null;
    /* Decide if ARIA attributes are okay */ let ALLOW_ARIA_ATTR = true;
    /* Decide if custom data attributes are okay */ let ALLOW_DATA_ATTR = true;
    /* Decide if unknown protocols are okay */ let ALLOW_UNKNOWN_PROTOCOLS = false;
    /* Decide if self-closing tags in attributes are allowed.
   * Usually removed due to a mXSS issue in jQuery 3.0 */ let ALLOW_SELF_CLOSE_IN_ATTR = true;
    /* Output should be safe for common template engines.
   * This means, DOMPurify removes data attributes, mustaches and ERB
   */ let SAFE_FOR_TEMPLATES = false;
    /* Output should be safe even for XML used within HTML and alike.
   * This means, DOMPurify removes comments when containing risky content.
   */ let SAFE_FOR_XML = true;
    /* Decide if document with <html>... should be returned */ let WHOLE_DOCUMENT = false;
    /* Track whether config is already set on this instance of DOMPurify. */ let SET_CONFIG = false;
    /* Decide if all elements (e.g. style, script) must be children of
   * document.body. By default, browsers might move them to document.head */ let FORCE_BODY = false;
    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
   * string (or a TrustedHTML object if Trusted Types are supported).
   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
   */ let RETURN_DOM = false;
    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
   * string  (or a TrustedHTML object if Trusted Types are supported) */ let RETURN_DOM_FRAGMENT = false;
    /* Try to return a Trusted Type object instead of a string, return a string in
   * case Trusted Types are not supported  */ let RETURN_TRUSTED_TYPE = false;
    /* Output should be free from DOM clobbering attacks?
   * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
   */ let SANITIZE_DOM = true;
    /* Achieve full DOM Clobbering protection by isolating the namespace of named
   * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
   *
   * HTML/DOM spec rules that enable DOM Clobbering:
   *   - Named Access on Window (7.3.3)
   *   - DOM Tree Accessors (3.1.5)
   *   - Form Element Parent-Child Relations (4.10.3)
   *   - Iframe srcdoc / Nested WindowProxies (4.8.5)
   *   - HTMLCollection (4.2.10.2)
   *
   * Namespace isolation is implemented by prefixing `id` and `name` attributes
   * with a constant string, i.e., `user-content-`
   */ let SANITIZE_NAMED_PROPS = false;
    const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';
    /* Keep element content when removing element? */ let KEEP_CONTENT = true;
    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
   * of importing it into a new Document and returning a sanitized copy */ let IN_PLACE = false;
    /* Allow usage of profiles like html, svg and mathMl */ let USE_PROFILES = {};
    /* Tags to ignore content of when KEEP_CONTENT is true */ let FORBID_CONTENTS = null;
    const DEFAULT_FORBID_CONTENTS = addToSet({}, [
        'annotation-xml',
        'audio',
        'colgroup',
        'desc',
        'foreignobject',
        'head',
        'iframe',
        'math',
        'mi',
        'mn',
        'mo',
        'ms',
        'mtext',
        'noembed',
        'noframes',
        'noscript',
        'plaintext',
        'script',
        'style',
        'svg',
        'template',
        'thead',
        'title',
        'video',
        'xmp'
    ]);
    /* Tags that are safe for data: URIs */ let DATA_URI_TAGS = null;
    const DEFAULT_DATA_URI_TAGS = addToSet({}, [
        'audio',
        'video',
        'img',
        'source',
        'image',
        'track'
    ]);
    /* Attributes safe for values like "javascript:" */ let URI_SAFE_ATTRIBUTES = null;
    const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [
        'alt',
        'class',
        'for',
        'id',
        'label',
        'name',
        'pattern',
        'placeholder',
        'role',
        'summary',
        'title',
        'value',
        'style',
        'xmlns'
    ]);
    const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
    const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
    const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
    /* Document namespace */ let NAMESPACE = HTML_NAMESPACE;
    let IS_EMPTY_INPUT = false;
    /* Allowed XHTML+XML namespaces */ let ALLOWED_NAMESPACES = null;
    const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [
        MATHML_NAMESPACE,
        SVG_NAMESPACE,
        HTML_NAMESPACE
    ], stringToString);
    let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [
        'mi',
        'mo',
        'mn',
        'ms',
        'mtext'
    ]);
    let HTML_INTEGRATION_POINTS = addToSet({}, [
        'annotation-xml'
    ]);
    // Certain elements are allowed in both SVG and HTML
    // namespace. We need to specify them explicitly
    // so that they don't get erroneously deleted from
    // HTML namespace.
    const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [
        'title',
        'style',
        'font',
        'a',
        'script'
    ]);
    /* Parsing of strict XHTML documents */ let PARSER_MEDIA_TYPE = null;
    const SUPPORTED_PARSER_MEDIA_TYPES = [
        'application/xhtml+xml',
        'text/html'
    ];
    const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
    let transformCaseFunc = null;
    /* Keep a reference to config to pass to hooks */ let CONFIG = null;
    /* Ideally, do not touch anything below this line */ /* ______________________________________________ */ const formElement = document.createElement('form');
    const isRegexOrFunction = function isRegexOrFunction(testValue) {
        return testValue instanceof RegExp || testValue instanceof Function;
    };
    /**
   * _parseConfig
   *
   * @param cfg optional config literal
   */ // eslint-disable-next-line complexity
    const _parseConfig = function _parseConfig() {
        let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (CONFIG && CONFIG === cfg) {
            return;
        }
        /* Shield configuration object from tampering */ if (!cfg || typeof cfg !== 'object') {
            cfg = {};
        }
        /* Shield configuration object from prototype pollution */ cfg = clone(cfg);
        PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
        SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
        // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
        transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;
        /* Set configuration parameters */ ALLOWED_TAGS = objectHasOwnProperty(cfg, 'ALLOWED_TAGS') ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
        ALLOWED_ATTR = objectHasOwnProperty(cfg, 'ALLOWED_ATTR') ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
        ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, 'ALLOWED_NAMESPACES') ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
        URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, 'ADD_URI_SAFE_ATTR') ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
        DATA_URI_TAGS = objectHasOwnProperty(cfg, 'ADD_DATA_URI_TAGS') ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
        FORBID_CONTENTS = objectHasOwnProperty(cfg, 'FORBID_CONTENTS') ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
        FORBID_TAGS = objectHasOwnProperty(cfg, 'FORBID_TAGS') ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : clone({});
        FORBID_ATTR = objectHasOwnProperty(cfg, 'FORBID_ATTR') ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : clone({});
        USE_PROFILES = objectHasOwnProperty(cfg, 'USE_PROFILES') ? cfg.USE_PROFILES : false;
        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
        ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true
        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
        SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true
        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
        RETURN_DOM = cfg.RETURN_DOM || false; // Default false
        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
        FORCE_BODY = cfg.FORCE_BODY || false; // Default false
        SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
        SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false
        KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
        IN_PLACE = cfg.IN_PLACE || false; // Default false
        IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
        MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
        HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
        CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
            CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
        }
        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
            CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
        }
        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
            CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
        }
        if (SAFE_FOR_TEMPLATES) {
            ALLOW_DATA_ATTR = false;
        }
        if (RETURN_DOM_FRAGMENT) {
            RETURN_DOM = true;
        }
        /* Parse profile info */ if (USE_PROFILES) {
            ALLOWED_TAGS = addToSet({}, text);
            ALLOWED_ATTR = [];
            if (USE_PROFILES.html === true) {
                addToSet(ALLOWED_TAGS, html$1);
                addToSet(ALLOWED_ATTR, html);
            }
            if (USE_PROFILES.svg === true) {
                addToSet(ALLOWED_TAGS, svg$1);
                addToSet(ALLOWED_ATTR, svg);
                addToSet(ALLOWED_ATTR, xml);
            }
            if (USE_PROFILES.svgFilters === true) {
                addToSet(ALLOWED_TAGS, svgFilters);
                addToSet(ALLOWED_ATTR, svg);
                addToSet(ALLOWED_ATTR, xml);
            }
            if (USE_PROFILES.mathMl === true) {
                addToSet(ALLOWED_TAGS, mathMl$1);
                addToSet(ALLOWED_ATTR, mathMl);
                addToSet(ALLOWED_ATTR, xml);
            }
        }
        /* Merge configuration parameters */ if (cfg.ADD_TAGS) {
            if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
                ALLOWED_TAGS = clone(ALLOWED_TAGS);
            }
            addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
        }
        if (cfg.ADD_ATTR) {
            if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
                ALLOWED_ATTR = clone(ALLOWED_ATTR);
            }
            addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
        }
        if (cfg.ADD_URI_SAFE_ATTR) {
            addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
        }
        if (cfg.FORBID_CONTENTS) {
            if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
                FORBID_CONTENTS = clone(FORBID_CONTENTS);
            }
            addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
        }
        /* Add #text in case KEEP_CONTENT is set to true */ if (KEEP_CONTENT) {
            ALLOWED_TAGS['#text'] = true;
        }
        /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */ if (WHOLE_DOCUMENT) {
            addToSet(ALLOWED_TAGS, [
                'html',
                'head',
                'body'
            ]);
        }
        /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */ if (ALLOWED_TAGS.table) {
            addToSet(ALLOWED_TAGS, [
                'tbody'
            ]);
            delete FORBID_TAGS.tbody;
        }
        if (cfg.TRUSTED_TYPES_POLICY) {
            if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {
                throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
            }
            if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {
                throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
            }
            // Overwrite existing TrustedTypes policy.
            trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
            // Sign local variables required by `sanitize`.
            emptyHTML = trustedTypesPolicy.createHTML('');
        } else {
            // Uninitialized policy, attempt to initialize the internal dompurify policy.
            if (trustedTypesPolicy === undefined) {
                trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
            }
            // If creating the internal policy succeeded sign internal variables.
            if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {
                emptyHTML = trustedTypesPolicy.createHTML('');
            }
        }
        // Prevent further manipulation of configuration.
        // Not available in IE8, Safari 5, etc.
        if (freeze) {
            freeze(cfg);
        }
        CONFIG = cfg;
    };
    /* Keep track of all possible SVG and MathML tags
   * so that we can perform the namespace checks
   * correctly. */ const ALL_SVG_TAGS = addToSet({}, [
        ...svg$1,
        ...svgFilters,
        ...svgDisallowed
    ]);
    const ALL_MATHML_TAGS = addToSet({}, [
        ...mathMl$1,
        ...mathMlDisallowed
    ]);
    /**
   * @param element a DOM element whose namespace is being checked
   * @returns Return false if the element has a
   *  namespace that a spec-compliant parser would never
   *  return. Return true otherwise.
   */ const _checkValidNamespace = function _checkValidNamespace(element) {
        let parent = getParentNode(element);
        // In JSDOM, if we're inside shadow DOM, then parentNode
        // can be null. We just simulate parent in this case.
        if (!parent || !parent.tagName) {
            parent = {
                namespaceURI: NAMESPACE,
                tagName: 'template'
            };
        }
        const tagName = stringToLowerCase(element.tagName);
        const parentTagName = stringToLowerCase(parent.tagName);
        if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
            return false;
        }
        if (element.namespaceURI === SVG_NAMESPACE) {
            // The only way to switch from HTML namespace to SVG
            // is via <svg>. If it happens via any other tag, then
            // it should be killed.
            if (parent.namespaceURI === HTML_NAMESPACE) {
                return tagName === 'svg';
            }
            // The only way to switch from MathML to SVG is via`
            // svg if parent is either <annotation-xml> or MathML
            // text integration points.
            if (parent.namespaceURI === MATHML_NAMESPACE) {
                return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
            }
            // We only allow elements that are defined in SVG
            // spec. All others are disallowed in SVG namespace.
            return Boolean(ALL_SVG_TAGS[tagName]);
        }
        if (element.namespaceURI === MATHML_NAMESPACE) {
            // The only way to switch from HTML namespace to MathML
            // is via <math>. If it happens via any other tag, then
            // it should be killed.
            if (parent.namespaceURI === HTML_NAMESPACE) {
                return tagName === 'math';
            }
            // The only way to switch from SVG to MathML is via
            // <math> and HTML integration points
            if (parent.namespaceURI === SVG_NAMESPACE) {
                return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
            }
            // We only allow elements that are defined in MathML
            // spec. All others are disallowed in MathML namespace.
            return Boolean(ALL_MATHML_TAGS[tagName]);
        }
        if (element.namespaceURI === HTML_NAMESPACE) {
            // The only way to switch from SVG to HTML is via
            // HTML integration points, and from MathML to HTML
            // is via MathML text integration points
            if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
                return false;
            }
            if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
                return false;
            }
            // We disallow tags that are specific for MathML
            // or SVG and should never appear in HTML namespace
            return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
        }
        // For XHTML and XML documents that support custom namespaces
        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {
            return true;
        }
        // The code should never reach this place (this means
        // that the element somehow got namespace that is not
        // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).
        // Return false just in case.
        return false;
    };
    /**
   * _forceRemove
   *
   * @param node a DOM node
   */ const _forceRemove = function _forceRemove(node) {
        arrayPush(DOMPurify.removed, {
            element: node
        });
        try {
            // eslint-disable-next-line unicorn/prefer-dom-node-remove
            getParentNode(node).removeChild(node);
        } catch (_) {
            remove(node);
        }
    };
    /**
   * _removeAttribute
   *
   * @param name an Attribute name
   * @param element a DOM node
   */ const _removeAttribute = function _removeAttribute(name, element) {
        try {
            arrayPush(DOMPurify.removed, {
                attribute: element.getAttributeNode(name),
                from: element
            });
        } catch (_) {
            arrayPush(DOMPurify.removed, {
                attribute: null,
                from: element
            });
        }
        element.removeAttribute(name);
        // We void attribute values for unremovable "is" attributes
        if (name === 'is') {
            if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
                try {
                    _forceRemove(element);
                } catch (_) {}
            } else {
                try {
                    element.setAttribute(name, '');
                } catch (_) {}
            }
        }
    };
    /**
   * _initDocument
   *
   * @param dirty - a string of dirty markup
   * @return a DOM, filled with the dirty markup
   */ const _initDocument = function _initDocument(dirty) {
        /* Create a HTML document */ let doc = null;
        let leadingWhitespace = null;
        if (FORCE_BODY) {
            dirty = '<remove></remove>' + dirty;
        } else {
            /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */ const matches = stringMatch(dirty, /^[\r\n\t ]+/);
            leadingWhitespace = matches && matches[0];
        }
        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {
            // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
            dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
        }
        const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
        /*
     * Use the DOMParser API by default, fallback later if needs be
     * DOMParser not work for svg when has multiple root element.
     */ if (NAMESPACE === HTML_NAMESPACE) {
            try {
                doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
            } catch (_) {}
        }
        /* Use createHTMLDocument in case DOMParser is not available */ if (!doc || !doc.documentElement) {
            doc = implementation.createDocument(NAMESPACE, 'template', null);
            try {
                doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
            } catch (_) {
            // Syntax error if dirtyPayload is invalid xml
            }
        }
        const body = doc.body || doc.documentElement;
        if (dirty && leadingWhitespace) {
            body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
        }
        /* Work on whole document or just its body */ if (NAMESPACE === HTML_NAMESPACE) {
            return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
        }
        return WHOLE_DOCUMENT ? doc.documentElement : body;
    };
    /**
   * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.
   *
   * @param root The root element or node to start traversing on.
   * @return The created NodeIterator
   */ const _createNodeIterator = function _createNodeIterator(root) {
        return createNodeIterator.call(root.ownerDocument || root, root, // eslint-disable-next-line no-bitwise
        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null);
    };
    /**
   * _isClobbered
   *
   * @param element element to check for clobbering attacks
   * @return true if clobbered, false if safe
   */ const _isClobbered = function _isClobbered(element) {
        return element instanceof HTMLFormElement && (typeof element.nodeName !== 'string' || typeof element.textContent !== 'string' || typeof element.removeChild !== 'function' || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== 'function' || typeof element.setAttribute !== 'function' || typeof element.namespaceURI !== 'string' || typeof element.insertBefore !== 'function' || typeof element.hasChildNodes !== 'function');
    };
    /**
   * Checks whether the given object is a DOM node.
   *
   * @param value object to check whether it's a DOM node
   * @return true is object is a DOM node
   */ const _isNode = function _isNode(value) {
        return typeof Node === 'function' && value instanceof Node;
    };
    function _executeHooks(hooks, currentNode, data) {
        arrayForEach(hooks, (hook)=>{
            hook.call(DOMPurify, currentNode, data, CONFIG);
        });
    }
    /**
   * _sanitizeElements
   *
   * @protect nodeName
   * @protect textContent
   * @protect removeChild
   * @param currentNode to check for permission to exist
   * @return true if node was killed, false if left alive
   */ const _sanitizeElements = function _sanitizeElements(currentNode) {
        let content = null;
        /* Execute a hook if present */ _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
        /* Check if element is clobbered or can clobber */ if (_isClobbered(currentNode)) {
            _forceRemove(currentNode);
            return true;
        }
        /* Now let's check the element's type and name */ const tagName = transformCaseFunc(currentNode.nodeName);
        /* Execute a hook if present */ _executeHooks(hooks.uponSanitizeElement, currentNode, {
            tagName,
            allowedTags: ALLOWED_TAGS
        });
        /* Detect mXSS attempts abusing namespace confusion */ if (SAFE_FOR_XML && currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\w!]/g, currentNode.textContent)) {
            _forceRemove(currentNode);
            return true;
        }
        /* Remove any occurrence of processing instructions */ if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
            _forceRemove(currentNode);
            return true;
        }
        /* Remove any kind of possibly harmful comments */ if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
            _forceRemove(currentNode);
            return true;
        }
        /* Remove element if anything forbids its presence */ if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            /* Check if we have a custom element to handle */ if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
                if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
                    return false;
                }
                if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
                    return false;
                }
            }
            /* Keep content except for bad-listed elements */ if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
                const parentNode = getParentNode(currentNode) || currentNode.parentNode;
                const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
                if (childNodes && parentNode) {
                    const childCount = childNodes.length;
                    for(let i = childCount - 1; i >= 0; --i){
                        const childClone = cloneNode(childNodes[i], true);
                        childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
                        parentNode.insertBefore(childClone, getNextSibling(currentNode));
                    }
                }
            }
            _forceRemove(currentNode);
            return true;
        }
        /* Check whether element has a valid namespace */ if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
            _forceRemove(currentNode);
            return true;
        }
        /* Make sure that older browsers don't get fallback-tag mXSS */ if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
            _forceRemove(currentNode);
            return true;
        }
        /* Sanitize element content to be template-safe */ if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
            /* Get the element's text content */ content = currentNode.textContent;
            arrayForEach([
                MUSTACHE_EXPR,
                ERB_EXPR,
                TMPLIT_EXPR
            ], (expr)=>{
                content = stringReplace(content, expr, ' ');
            });
            if (currentNode.textContent !== content) {
                arrayPush(DOMPurify.removed, {
                    element: currentNode.cloneNode()
                });
                currentNode.textContent = content;
            }
        }
        /* Execute a hook if present */ _executeHooks(hooks.afterSanitizeElements, currentNode, null);
        return false;
    };
    /**
   * _isValidAttribute
   *
   * @param lcTag Lowercase tag name of containing element.
   * @param lcName Lowercase attribute name.
   * @param value Attribute value.
   * @return Returns true if `value` is valid, otherwise false.
   */ // eslint-disable-next-line complexity
    const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
        /* Make sure attribute cannot clobber */ if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
            return false;
        }
        /* Allow valid data-* attributes: At least one character after "-"
        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
        We don't need to check the value; it's always URI safe. */ if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ;
        else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ;
        else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
            if (// First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ;
            else {
                return false;
            }
        /* Check value is safe. First, is attr inert? If so, is safe */ } else if (URI_SAFE_ATTRIBUTES[lcName]) ;
        else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))) ;
        else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ;
        else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))) ;
        else if (value) {
            return false;
        } else ;
        return true;
    };
    /**
   * _isBasicCustomElement
   * checks if at least one dash is included in tagName, and it's not the first char
   * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
   *
   * @param tagName name of the tag of the node to sanitize
   * @returns Returns true if the tag name meets the basic criteria for a custom element, otherwise false.
   */ const _isBasicCustomElement = function _isBasicCustomElement(tagName) {
        return tagName !== 'annotation-xml' && stringMatch(tagName, CUSTOM_ELEMENT);
    };
    /**
   * _sanitizeAttributes
   *
   * @protect attributes
   * @protect nodeName
   * @protect removeAttribute
   * @protect setAttribute
   *
   * @param currentNode to sanitize
   */ const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
        /* Execute a hook if present */ _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
        const { attributes } = currentNode;
        /* Check if we have attributes; if not we might have a text node */ if (!attributes || _isClobbered(currentNode)) {
            return;
        }
        const hookEvent = {
            attrName: '',
            attrValue: '',
            keepAttr: true,
            allowedAttributes: ALLOWED_ATTR,
            forceKeepAttr: undefined
        };
        let l = attributes.length;
        /* Go backwards over all attributes; safely remove bad ones */ while(l--){
            const attr = attributes[l];
            const { name, namespaceURI, value: attrValue } = attr;
            const lcName = transformCaseFunc(name);
            const initValue = attrValue;
            let value = name === 'value' ? initValue : stringTrim(initValue);
            /* Execute a hook if present */ hookEvent.attrName = lcName;
            hookEvent.attrValue = value;
            hookEvent.keepAttr = true;
            hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
            _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
            value = hookEvent.attrValue;
            /* Full DOM Clobbering protection via namespace isolation,
       * Prefix id and name attributes with `user-content-`
       */ if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
                // Remove the attribute with this value
                _removeAttribute(name, currentNode);
                // Prefix the value and later re-create the attribute with the sanitized value
                value = SANITIZE_NAMED_PROPS_PREFIX + value;
            }
            /* Work around a security issue with comments inside attributes */ if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value)) {
                _removeAttribute(name, currentNode);
                continue;
            }
            /* Did the hooks approve of the attribute? */ if (hookEvent.forceKeepAttr) {
                continue;
            }
            /* Did the hooks approve of the attribute? */ if (!hookEvent.keepAttr) {
                _removeAttribute(name, currentNode);
                continue;
            }
            /* Work around a security issue in jQuery 3.0 */ if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
                _removeAttribute(name, currentNode);
                continue;
            }
            /* Sanitize attribute content to be template-safe */ if (SAFE_FOR_TEMPLATES) {
                arrayForEach([
                    MUSTACHE_EXPR,
                    ERB_EXPR,
                    TMPLIT_EXPR
                ], (expr)=>{
                    value = stringReplace(value, expr, ' ');
                });
            }
            /* Is `value` valid for this attribute? */ const lcTag = transformCaseFunc(currentNode.nodeName);
            if (!_isValidAttribute(lcTag, lcName, value)) {
                _removeAttribute(name, currentNode);
                continue;
            }
            /* Handle attributes that require Trusted Types */ if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {
                if (namespaceURI) ;
                else {
                    switch(trustedTypes.getAttributeType(lcTag, lcName)){
                        case 'TrustedHTML':
                            {
                                value = trustedTypesPolicy.createHTML(value);
                                break;
                            }
                        case 'TrustedScriptURL':
                            {
                                value = trustedTypesPolicy.createScriptURL(value);
                                break;
                            }
                    }
                }
            }
            /* Handle invalid data-* attribute set by try-catching it */ if (value !== initValue) {
                try {
                    if (namespaceURI) {
                        currentNode.setAttributeNS(namespaceURI, name, value);
                    } else {
                        /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */ currentNode.setAttribute(name, value);
                    }
                    if (_isClobbered(currentNode)) {
                        _forceRemove(currentNode);
                    } else {
                        arrayPop(DOMPurify.removed);
                    }
                } catch (_) {
                    _removeAttribute(name, currentNode);
                }
            }
        }
        /* Execute a hook if present */ _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
    };
    /**
   * _sanitizeShadowDOM
   *
   * @param fragment to iterate over recursively
   */ const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
        let shadowNode = null;
        const shadowIterator = _createNodeIterator(fragment);
        /* Execute a hook if present */ _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
        while(shadowNode = shadowIterator.nextNode()){
            /* Execute a hook if present */ _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
            /* Sanitize tags and elements */ _sanitizeElements(shadowNode);
            /* Check attributes next */ _sanitizeAttributes(shadowNode);
            /* Deep shadow DOM detected */ if (shadowNode.content instanceof DocumentFragment) {
                _sanitizeShadowDOM(shadowNode.content);
            }
        }
        /* Execute a hook if present */ _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
    };
    // eslint-disable-next-line complexity
    DOMPurify.sanitize = function(dirty) {
        let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        let body = null;
        let importedNode = null;
        let currentNode = null;
        let returnNode = null;
        /* Make sure we have a string to sanitize.
      DO NOT return early, as this will return the wrong type if
      the user has requested a DOM object rather than a string */ IS_EMPTY_INPUT = !dirty;
        if (IS_EMPTY_INPUT) {
            dirty = '<!-->';
        }
        /* Stringify, in case dirty is an object */ if (typeof dirty !== 'string' && !_isNode(dirty)) {
            if (typeof dirty.toString === 'function') {
                dirty = dirty.toString();
                if (typeof dirty !== 'string') {
                    throw typeErrorCreate('dirty is not a string, aborting');
                }
            } else {
                throw typeErrorCreate('toString is not a function');
            }
        }
        /* Return dirty HTML if DOMPurify cannot run */ if (!DOMPurify.isSupported) {
            return dirty;
        }
        /* Assign config vars */ if (!SET_CONFIG) {
            _parseConfig(cfg);
        }
        /* Clean up removed elements */ DOMPurify.removed = [];
        /* Check if dirty is correctly typed for IN_PLACE */ if (typeof dirty === 'string') {
            IN_PLACE = false;
        }
        if (IN_PLACE) {
            /* Do some early pre-sanitization to avoid unsafe root nodes */ if (dirty.nodeName) {
                const tagName = transformCaseFunc(dirty.nodeName);
                if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
                    throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
                }
            }
        } else if (dirty instanceof Node) {
            /* If dirty is a DOM element, append to an empty document to avoid
         elements being stripped by the parser */ body = _initDocument('<!---->');
            importedNode = body.ownerDocument.importNode(dirty, true);
            if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === 'BODY') {
                /* Node is already a body, use as is */ body = importedNode;
            } else if (importedNode.nodeName === 'HTML') {
                body = importedNode;
            } else {
                // eslint-disable-next-line unicorn/prefer-dom-node-append
                body.appendChild(importedNode);
            }
        } else {
            /* Exit directly if we have nothing to do */ if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
            dirty.indexOf('<') === -1) {
                return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
            }
            /* Initialize the document to work on */ body = _initDocument(dirty);
            /* Check we have a DOM node from the data */ if (!body) {
                return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
            }
        }
        /* Remove first element node (ours) if FORCE_BODY is set */ if (body && FORCE_BODY) {
            _forceRemove(body.firstChild);
        }
        /* Get node iterator */ const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
        /* Now start iterating over the created document */ while(currentNode = nodeIterator.nextNode()){
            /* Sanitize tags and elements */ _sanitizeElements(currentNode);
            /* Check attributes next */ _sanitizeAttributes(currentNode);
            /* Shadow DOM detected, sanitize it */ if (currentNode.content instanceof DocumentFragment) {
                _sanitizeShadowDOM(currentNode.content);
            }
        }
        /* If we sanitized `dirty` in-place, return it. */ if (IN_PLACE) {
            return dirty;
        }
        /* Return sanitized string or DOM */ if (RETURN_DOM) {
            if (RETURN_DOM_FRAGMENT) {
                returnNode = createDocumentFragment.call(body.ownerDocument);
                while(body.firstChild){
                    // eslint-disable-next-line unicorn/prefer-dom-node-append
                    returnNode.appendChild(body.firstChild);
                }
            } else {
                returnNode = body;
            }
            if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
                /*
          AdoptNode() is not used because internal state is not reset
          (e.g. the past names map of a HTMLFormElement), this is safe
          in theory but we would rather not risk another attack vector.
          The state that is cloned by importNode() is explicitly defined
          by the specs.
        */ returnNode = importNode.call(originalDocument, returnNode, true);
            }
            return returnNode;
        }
        let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
        /* Serialize doctype if allowed */ if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
            serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
        }
        /* Sanitize final string template-safe */ if (SAFE_FOR_TEMPLATES) {
            arrayForEach([
                MUSTACHE_EXPR,
                ERB_EXPR,
                TMPLIT_EXPR
            ], (expr)=>{
                serializedHTML = stringReplace(serializedHTML, expr, ' ');
            });
        }
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };
    DOMPurify.setConfig = function() {
        let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        _parseConfig(cfg);
        SET_CONFIG = true;
    };
    DOMPurify.clearConfig = function() {
        CONFIG = null;
        SET_CONFIG = false;
    };
    DOMPurify.isValidAttribute = function(tag, attr, value) {
        /* Initialize shared config vars if necessary. */ if (!CONFIG) {
            _parseConfig({});
        }
        const lcTag = transformCaseFunc(tag);
        const lcName = transformCaseFunc(attr);
        return _isValidAttribute(lcTag, lcName, value);
    };
    DOMPurify.addHook = function(entryPoint, hookFunction) {
        if (typeof hookFunction !== 'function') {
            return;
        }
        arrayPush(hooks[entryPoint], hookFunction);
    };
    DOMPurify.removeHook = function(entryPoint, hookFunction) {
        if (hookFunction !== undefined) {
            const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);
            return index === -1 ? undefined : arraySplice(hooks[entryPoint], index, 1)[0];
        }
        return arrayPop(hooks[entryPoint]);
    };
    DOMPurify.removeHooks = function(entryPoint) {
        hooks[entryPoint] = [];
    };
    DOMPurify.removeAllHooks = function() {
        hooks = _createHooksMap();
    };
    return DOMPurify;
}
var purify = createDOMPurify();
;
 //# sourceMappingURL=purify.es.mjs.map
}),
]);

//# sourceMappingURL=node_modules_2c889d0f._.js.map