{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/util/url.mjs"],"sourcesContent":["import process from 'process';\nimport { pathSatisfies, propOr, pipe, test, last } from 'ramda';\nimport { isUndefined, replaceAll, isNotUndefined, trimCharsEnd } from 'ramda-adjunct';\n\n/**\n * SPDX-FileCopyrightText: Copyright (c) 2015 James Messinger\n *\n * SPDX-License-Identifier: MIT\n */\n\n/**\n * @public\n */\n\nconst isWindows = () => pathSatisfies(test(/^win/), ['platform'], process);\n\n/**\n * Returns the protocol of the given URL, or `undefined` if it has no protocol.\n * @public\n */\nexport const getProtocol = url => {\n  try {\n    const parsedUrl = new URL(url);\n    return trimCharsEnd(':', parsedUrl.protocol);\n  } catch {\n    return undefined;\n  }\n};\n\n/**\n * Returns true if given URL has protocol.\n * @public\n */\nexport const hasProtocol = pipe(getProtocol, isNotUndefined);\n\n/**\n * Returns the lower-cased file extension of the given URL,\n * or an empty string if it has no extension.\n * @public\n */\nexport const getExtension = url => {\n  const lastDotPosition = url.lastIndexOf('.');\n  if (lastDotPosition >= 0) {\n    return url.substring(lastDotPosition).toLowerCase();\n  }\n  return '';\n};\n\n/**\n * Determines whether the given path is a filesystem path.\n * This includes \"file://\" URLs.\n * @public\n */\nexport const isFileSystemPath = uri => {\n  // @ts-ignore\n  if (process.browser) {\n    /**\n     * We're running in a browser, so assume that all paths are URLs.\n     * This way, even relative paths will be treated as URLs rather than as filesystem paths.\n     */\n    return false;\n  }\n  const protocol = getProtocol(uri);\n  return isUndefined(protocol) || protocol === 'file' || /^[a-zA-Z]$/.test(protocol);\n};\n\n/**\n * Determines whether the given URI is an HTTP(S) URL.\n * @public\n */\nexport const isHttpUrl = url => {\n  const protocol = getProtocol(url);\n  return protocol === 'http' || protocol === 'https';\n};\n\n/**\n * Determines whether the given URI\n * @public\n */\nexport const isURI = uri => {\n  try {\n    return new URL(uri) && true;\n  } catch {\n    return false;\n  }\n};\n\n/**\n * @public\n */\n\n/**\n * Converts a URL to a local filesystem path.\n * @public\n */\nexport const toFileSystemPath = (uri, options) => {\n  // RegExp patterns to URL-decode special characters for local filesystem paths\n  const urlDecodePatterns = [/%23/g, '#', /%24/g, '$', /%26/g, '&', /%2C/g, ',', /%40/g, '@'];\n  const keepFileProtocol = propOr(false, 'keepFileProtocol', options);\n  const isWindowsPredicate = propOr(isWindows, 'isWindows', options);\n\n  // Step 1: `decodeURI` will decode characters such as Cyrillic characters, spaces, etc.\n  let path = decodeURI(uri);\n\n  // Step 2: Manually decode characters that are not decoded by `decodeURI`.\n  // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n  // but are just normal characters in a filesystem path.\n  for (let i = 0; i < urlDecodePatterns.length; i += 2) {\n    // @ts-ignore\n    path = path.replace(urlDecodePatterns[i], urlDecodePatterns[i + 1]);\n  }\n\n  // Step 3: If it's a \"file://\" URL, then format it consistently\n  // or convert it to a local filesystem path\n  let isFileUrl = path.substring(0, 7).toLowerCase() === 'file://';\n  if (isFileUrl) {\n    // Strip-off the protocol, and the initial \"/\", if there is one\n    path = path[7] === '/' ? path.substring(8) : path.substring(7);\n\n    // insert a colon (\":\") after the drive letter on Windows\n    if (isWindowsPredicate() && path[1] === '/') {\n      path = `${path[0]}:${path.substring(1)}`;\n    }\n    if (keepFileProtocol) {\n      // Return the consistently-formatted \"file://\" URL\n      path = `file:///${path}`;\n    } else {\n      // Convert the \"file://\" URL to a local filesystem path.\n      // On Windows, it will start with something like \"C:/\".\n      // On Posix, it will start with \"/\"\n      isFileUrl = false;\n      path = isWindowsPredicate() ? path : `/${path}`;\n    }\n  }\n\n  // Step 4: Normalize Windows paths (unless it's a \"file://\" URL)\n  if (isWindowsPredicate() && !isFileUrl) {\n    // Replace forward slashes with backslashes\n    path = replaceAll('/', '\\\\', path);\n\n    // Capitalize the drive letter\n    if (path.substring(1, 3) === ':\\\\') {\n      path = path[0].toUpperCase() + path.substring(1);\n    }\n  }\n  return path;\n};\n\n/**\n * Converts a filesystem path to a properly-encoded URL.\n *\n * This is intended to handle situations where resolver is called\n * with a filesystem path that contains characters which are not allowed in URLs.\n *\n * @example\n * The following filesystem paths would be converted to the following URLs:\n *```\n *    <\"!@#$%^&*+=?'>.json              ==>   %3C%22!@%23$%25%5E&*+=%3F\\'%3E.json\n *    C:\\\\My Documents\\\\File (1).json   ==>   C:/My%20Documents/File%20(1).json\n *    file://Project #42/file.json      ==>   file://Project%20%2342/file.json\n * ```\n * @public\n */\nexport const fromFileSystemPath = uri => {\n  const urlEncodePatterns = [/\\?/g, '%3F', /#/g, '%23'];\n  let path = uri;\n\n  // Step 1: On Windows, replace backslashes with forward slashes,\n  // rather than encoding them as \"%5C\"\n  if (isWindows()) {\n    path = path.replace(/\\\\/g, '/');\n  }\n\n  // Step 2: `encodeURI` will take care of MOST characters\n  path = encodeURI(path);\n\n  // Step 3: Manually encode characters that are not encoded by `encodeURI`.\n  // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n  // but are just normal characters in a filesystem path.\n  for (let i = 0; i < urlEncodePatterns.length; i += 2) {\n    // @ts-ignore\n    path = path.replace(urlEncodePatterns[i], urlEncodePatterns[i + 1]);\n  }\n  return path;\n};\n\n/**\n * Returns the hash (URL fragment), of the given path.\n * If there is no hash, then the root hash (\"#\") is returned.\n * @public\n */\nexport const getHash = uri => {\n  const hashIndex = uri.indexOf('#');\n  if (hashIndex !== -1) {\n    return uri.substring(hashIndex);\n  }\n  return '#';\n};\n\n/**\n * Removes the hash (URL fragment), if any, from the given path.\n * @public\n */\nexport const stripHash = uri => {\n  const hashIndex = uri.indexOf('#');\n  let hashStrippedUri = uri;\n  if (hashIndex >= 0) {\n    hashStrippedUri = uri.substring(0, hashIndex);\n  }\n  return hashStrippedUri;\n};\n\n/**\n * Returns the current working directory (in Node) or the current page URL (in browsers).\n * @public\n */\nexport const cwd = () => {\n  // @ts-ignore\n  if (process.browser) {\n    return stripHash(globalThis.location.href);\n  }\n  const path = process.cwd();\n  const lastChar = last(path);\n  if (['/', '\\\\'].includes(lastChar)) {\n    return path;\n  }\n  return path + (isWindows() ? '\\\\' : '/');\n};\n\n/**\n * Resolves a target URI relative to a base URI in a manner similar to that of a Web browser resolving an anchor tag HREF.\n * @public\n */\nexport const resolve = (from, to) => {\n  const resolvedUrl = new URL(to, new URL(from, 'resolve://'));\n  if (resolvedUrl.protocol === 'resolve:') {\n    // `from` is a relative URL.\n    const {\n      pathname,\n      search,\n      hash\n    } = resolvedUrl;\n    return pathname + search + hash;\n  }\n  return resolvedUrl.toString();\n};\n\n/**\n * Sanitizes/Encodes URI to it's url encoded form.\n *\n * The functional will compensate with the usecase when\n * already sanitized URI is passed to it,\n * by first unsatizing it and then performing sanitization again.\n * @public\n */\n\nexport const sanitize = uri => {\n  if (isFileSystemPath(uri)) {\n    return fromFileSystemPath(toFileSystemPath(uri));\n  }\n  try {\n    return new URL(uri).toString();\n  } catch {\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI#encoding_for_ipv6\n    return encodeURI(decodeURI(uri)).replace(/%5B/g, '[').replace(/%5D/g, ']');\n  }\n};\n\n/**\n * Unsanitizes/Decodes URI to it's url encoded form.\n * This function already assumes that hash part of the URI\n * has been removed prior to transforming it to it's sanitized form.\n * @public\n */\n\nexport const unsanitize = uri => {\n  if (isFileSystemPath(uri)) {\n    return toFileSystemPath(uri);\n  }\n  return decodeURI(uri);\n};"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 244, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/File.mjs"],"sourcesContent":["import { type } from 'ramda';\nimport { isString } from 'ramda-adjunct';\nimport * as url from \"./util/url.mjs\";\n/**\n * This class represents a File object with url and data.\n * @public\n */\n/**\n * @public\n */\nclass File {\n  uri;\n  mediaType;\n  data;\n  parseResult;\n  constructor({\n    uri,\n    mediaType = 'text/plain',\n    data,\n    parseResult\n  }) {\n    this.uri = uri;\n    this.mediaType = mediaType;\n    this.data = data;\n    this.parseResult = parseResult;\n  }\n  get extension() {\n    if (isString(this.uri)) {\n      return url.getExtension(this.uri);\n    }\n    return '';\n  }\n  toString() {\n    if (typeof this.data === 'string') {\n      return this.data;\n    }\n    if (this.data instanceof ArrayBuffer || ['ArrayBuffer'].includes(type(this.data)) || ArrayBuffer.isView(this.data)) {\n      const textDecoder = new TextDecoder('utf-8');\n      return textDecoder.decode(this.data);\n    }\n    return String(this.data);\n  }\n}\nexport default File;"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AACA;;;CAGC,GACD;;CAEC,GACD,MAAM;IACJ,IAAI;IACJ,UAAU;IACV,KAAK;IACL,YAAY;IACZ,YAAY,EACV,GAAG,EACH,YAAY,YAAY,EACxB,IAAI,EACJ,WAAW,EACZ,CAAE;QACD,IAAI,CAAC,GAAG,GAAG;QACX,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,WAAW,GAAG;IACrB;IACA,IAAI,YAAY;QACd,IAAI,IAAA,wMAAQ,EAAC,IAAI,CAAC,GAAG,GAAG;YACtB,OAAO,iMAAgB,CAAC,IAAI,CAAC,GAAG;QAClC;QACA,OAAO;IACT;IACA,WAAW;QACT,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,UAAU;YACjC,OAAO,IAAI,CAAC,IAAI;QAClB;QACA,IAAI,IAAI,CAAC,IAAI,YAAY,eAAe;YAAC;SAAc,CAAC,QAAQ,CAAC,IAAA,iLAAI,EAAC,IAAI,CAAC,IAAI,MAAM,YAAY,MAAM,CAAC,IAAI,CAAC,IAAI,GAAG;YAClH,MAAM,cAAc,IAAI,YAAY;YACpC,OAAO,YAAY,MAAM,CAAC,IAAI,CAAC,IAAI;QACrC;QACA,OAAO,OAAO,IAAI,CAAC,IAAI;IACzB;AACF;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 294, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/ReferenceSet.mjs"],"sourcesContent":["import { isNotUndefined, isString } from 'ramda-adjunct';\n\n/**\n * @public\n */\n\n/**\n * @public\n */\nclass ReferenceSet {\n  rootRef;\n  refs;\n  circular;\n  constructor({\n    refs = [],\n    circular = false\n  } = {}) {\n    this.refs = [];\n    this.circular = circular;\n    refs.forEach(this.add.bind(this));\n  }\n  get size() {\n    return this.refs.length;\n  }\n  add(reference) {\n    if (!this.has(reference)) {\n      this.refs.push(reference);\n      this.rootRef = this.rootRef === undefined ? reference : this.rootRef;\n      reference.refSet = this; // eslint-disable-line no-param-reassign\n    }\n    return this;\n  }\n  merge(anotherRefSet) {\n    for (const reference of anotherRefSet.values()) {\n      this.add(reference);\n    }\n    return this;\n  }\n  has(thing) {\n    const uri = isString(thing) ? thing : thing.uri;\n    return isNotUndefined(this.find(ref => ref.uri === uri));\n  }\n  find(predicate) {\n    return this.refs.find(predicate);\n  }\n  *values() {\n    yield* this.refs;\n  }\n  clean() {\n    this.refs.forEach(ref => {\n      ref.refSet = undefined; // eslint-disable-line no-param-reassign\n    });\n    this.rootRef = undefined;\n    this.refs.length = 0;\n  }\n}\nexport default ReferenceSet;"],"names":[],"mappings":";;;;AAAA;AAAA;;AAEA;;CAEC,GAED;;CAEC,GACD,MAAM;IACJ,QAAQ;IACR,KAAK;IACL,SAAS;IACT,YAAY,EACV,OAAO,EAAE,EACT,WAAW,KAAK,EACjB,GAAG,CAAC,CAAC,CAAE;QACN,IAAI,CAAC,IAAI,GAAG,EAAE;QACd,IAAI,CAAC,QAAQ,GAAG;QAChB,KAAK,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI;IACjC;IACA,IAAI,OAAO;QACT,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM;IACzB;IACA,IAAI,SAAS,EAAE;QACb,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,YAAY;YACxB,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;YACf,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,KAAK,YAAY,YAAY,IAAI,CAAC,OAAO;YACpE,UAAU,MAAM,GAAG,IAAI,EAAE,wCAAwC;QACnE;QACA,OAAO,IAAI;IACb;IACA,MAAM,aAAa,EAAE;QACnB,KAAK,MAAM,aAAa,cAAc,MAAM,GAAI;YAC9C,IAAI,CAAC,GAAG,CAAC;QACX;QACA,OAAO,IAAI;IACb;IACA,IAAI,KAAK,EAAE;QACT,MAAM,MAAM,IAAA,wMAAQ,EAAC,SAAS,QAAQ,MAAM,GAAG;QAC/C,OAAO,IAAA,0NAAc,EAAC,IAAI,CAAC,IAAI,CAAC,CAAA,MAAO,IAAI,GAAG,KAAK;IACrD;IACA,KAAK,SAAS,EAAE;QACd,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;IACxB;IACA,CAAC,SAAS;QACR,OAAO,IAAI,CAAC,IAAI;IAClB;IACA,QAAQ;QACN,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;YAChB,IAAI,MAAM,GAAG,WAAW,wCAAwC;QAClE;QACA,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG;IACrB;AACF;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 354, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/options/index.mjs"],"sourcesContent":["import { identity } from 'ramda';\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\nconst defaultOptions = {\n  parse: {\n    /**\n     * This is media type that will be used to parse the input.\n     */\n    mediaType: 'text/plain',\n    /**\n     * Determines how different types of files will be parsed.\n     *\n     * You can add additional parsers of your own, replace an existing one with\n     * your own implementation, or remove any resolver by removing it from the list.\n     * It's recommended to keep the order of parser from most specific ones to most generic ones.\n     */\n    parsers: [],\n    /**\n     * These options are merged with parser plugin instance before the plugin is run.\n     */\n    parserOpts: {}\n  },\n  resolve: {\n    /**\n     * baseURI serves as a base for all relative URL found in ApiDOM references.\n     */\n    baseURI: '',\n    /**\n     * Determines how References will be resolved.\n     *\n     * You can add additional resolvers of your own, replace an existing one with\n     * your own implementation, or remove any resolver by removing it from the list.\n     */\n    resolvers: [],\n    /**\n     * These options are merged with resolver plugin instance before the plugin is run.\n     */\n    resolverOpts: {},\n    /**\n     * Determines strategies how References are identified and processed by resolvers.\n     * Strategy is determined by media type.\n     *\n     * You can add additional resolver strategies of your own, replace an existing one with\n     * your own implementation, or remove any resolve strategy by removing it from the list.\n     */\n    strategies: [],\n    /**\n     * These options are available in resolver strategy `canResolve` and `resolve` methods.\n     */\n    strategyOpts: {},\n    /**\n     * Determines whether internal references will be resolved.\n     * Internal references will simply be ignored.\n     */\n    internal: true,\n    /**\n     * Determines whether external references will be resolved.\n     * If this option is disabled, then none of above resolvers will be called.\n     * Instead, external references will simply be ignored.\n     */\n    external: true,\n    /**\n     * Determines the maximum depth of resolve algorithms.\n     * By default, there is no limit.\n     *\n     * This option tracks the depth of the file tree not the depth of the dereference path.\n     *\n     * It can be set to any positive integer number or zero (0).\n     *\n     * The resolver should throw MaximumResolverDepthError if resolution depth\n     * is exceeded by this option.\n     */\n    maxDepth: +Infinity\n  },\n  dereference: {\n    /**\n     * Determines strategies how ApiDOM is dereferenced.\n     * Strategy is determined by media type or by inspecting ApiDOM to be dereferenced.\n     *\n     * You can add additional dereference strategies of your own, replace an existing one with\n     * your own implementation, or remove any dereference strategy by removing it from the list.\n     */\n    strategies: [],\n    /**\n     * These options are available in dereference strategy `canDereference` and `dereference` methods.\n     */\n    strategyOpts: {},\n    /**\n     * This option accepts an instance of pre-computed ReferenceSet.\n     * If provided it will speed up the dereferencing significantly as the external\n     * resolution doesn't need to happen anymore.\n     */\n    refSet: null,\n    /**\n     * Determines the maximum depth of dereferencing.\n     * By default, there is no limit.\n     *\n     * The maxDepth represents a number of references that needed to be followed\n     * before the eventual value was reached.\n     *\n     * It can be set to any positive integer number or zero (0).\n     *\n     * The dereferencing should throw MaximumDereferenceDepthError if dereferencing depth\n     * is exceeded by this option.\n     */\n    maxDepth: +Infinity,\n    /**\n     * Determines how circular references are handled.\n     *\n     * \"ignore\" - circular reference are allowed\n     * \"replace\" - circular references are not allowed and are translated to RefElement\n     * \"error\" - circular references are not allowed and will throw an error\n     */\n    circular: 'ignore',\n    /**\n     * This function is used to replace circular references when `circular` option is set to \"replace\".\n     * By default, it's an identity function. It means that circular references are replaced with RefElement.\n     */\n    circularReplacer: identity,\n    /**\n     * Determines whether the dereferencing process will be immutable.\n     * By default, the dereferencing process is immutable, which means that the original\n     * ApiDOM passed to the dereference process is NOT modified.\n     *\n     * true - the dereferencing process will be immutable (deep cloning of ApiDOM is involved)\n     * false - the dereferencing process will be mutable\n     */\n    immutable: true\n  },\n  bundle: {\n    /**\n     * Determines strategies how ApiDOM is bundled.\n     * Strategy is determined by media type or by inspecting ApiDOM to be bundled.\n     *\n     * You can add additional bundle strategies of your own, replace an existing one with\n     * your own implementation, or remove any bundle strategy by removing it from the list.\n     */\n    strategies: [],\n    /**\n     * This option accepts an instance of pre-computed ReferenceSet.\n     * If provided it will speed up the bundling significantly as the external\n     * resolution doesn't need to happen anymore.\n     */\n    refSet: null,\n    /**\n     * Determines the maximum depth of bundling.\n     * By default, there is no limit.\n     *\n     * The maxDepth represents a number of references that needed to be followed\n     * before the eventual value was reached.\n     *\n     * It can be set to any positive integer number or zero (0).\n     *\n     * The bundling should throw MaximumBundleDepthError if bundling depth\n     * is exceeded by this option.\n     */\n    maxDepth: +Infinity\n  }\n};\nexport default defaultOptions;"],"names":[],"mappings":";;;;AAAA;;AAEA;;CAEC,GAED;;CAEC,GAED;;CAEC,GAED;;CAEC,GAED;;CAEC,GAED;;CAEC,GACD,MAAM,iBAAiB;IACrB,OAAO;QACL;;KAEC,GACD,WAAW;QACX;;;;;;KAMC,GACD,SAAS,EAAE;QACX;;KAEC,GACD,YAAY,CAAC;IACf;IACA,SAAS;QACP;;KAEC,GACD,SAAS;QACT;;;;;KAKC,GACD,WAAW,EAAE;QACb;;KAEC,GACD,cAAc,CAAC;QACf;;;;;;KAMC,GACD,YAAY,EAAE;QACd;;KAEC,GACD,cAAc,CAAC;QACf;;;KAGC,GACD,UAAU;QACV;;;;KAIC,GACD,UAAU;QACV;;;;;;;;;;KAUC,GACD,UAAU,CAAC;IACb;IACA,aAAa;QACX;;;;;;KAMC,GACD,YAAY,EAAE;QACd;;KAEC,GACD,cAAc,CAAC;QACf;;;;KAIC,GACD,QAAQ;QACR;;;;;;;;;;;KAWC,GACD,UAAU,CAAC;QACX;;;;;;KAMC,GACD,UAAU;QACV;;;KAGC,GACD,kBAAkB,6LAAQ;QAC1B;;;;;;;KAOC,GACD,WAAW;IACb;IACA,QAAQ;QACN;;;;;;KAMC,GACD,YAAY,EAAE;QACd;;;;KAIC,GACD,QAAQ;QACR;;;;;;;;;;;KAWC,GACD,UAAU,CAAC;IACb;AACF;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 512, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/options/util.mjs"],"sourcesContent":["import { mergeDeepRight, lens, path, assocPath, over } from 'ramda';\nimport { isEmptyString } from 'ramda-adjunct';\nimport { cwd } from \"../util/url.mjs\";\n/**\n * Algorithm for deep merging options.\n */\n\nconst baseURILens = lens(path(['resolve', 'baseURI']), assocPath(['resolve', 'baseURI']));\nconst baseURIDefault = baseURI => isEmptyString(baseURI) ? cwd() : baseURI;\n\n/**\n * @public\n */\n// eslint-disable-next-line import/prefer-default-export\nexport const merge = (lObj, rObj) => {\n  const withoutDefaults = mergeDeepRight(lObj, rObj);\n  // @ts-ignore\n  return over(baseURILens, baseURIDefault, withoutDefaults);\n};"],"names":[],"mappings":";;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;AACA;;CAEC,GAED,MAAM,cAAc,IAAA,iLAAI,EAAC,IAAA,iLAAI,EAAC;IAAC;IAAW;CAAU,GAAG,IAAA,gMAAS,EAAC;IAAC;IAAW;CAAU;AACvF,MAAM,iBAAiB,CAAA,UAAW,IAAA,uNAAa,EAAC,WAAW,IAAA,wLAAG,MAAK;AAM5D,MAAM,QAAQ,CAAC,MAAM;IAC1B,MAAM,kBAAkB,IAAA,+MAAc,EAAC,MAAM;IAC7C,aAAa;IACb,OAAO,IAAA,iLAAI,EAAC,aAAa,gBAAgB;AAC3C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 545, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/errors/PluginError.mjs"],"sourcesContent":["import { ApiDOMError } from '@swagger-api/apidom-error';\n\n/**\n * @public\n */\nclass PluginError extends ApiDOMError {\n  plugin;\n  constructor(message, options) {\n    super(message, {\n      cause: options.cause\n    });\n    this.plugin = options.plugin;\n  }\n}\nexport default PluginError;"],"names":[],"mappings":";;;;AAAA;;AAEA;;CAEC,GACD,MAAM,oBAAoB,sOAAW;IACnC,OAAO;IACP,YAAY,OAAO,EAAE,OAAO,CAAE;QAC5B,KAAK,CAAC,SAAS;YACb,OAAO,QAAQ,KAAK;QACtB;QACA,IAAI,CAAC,MAAM,GAAG,QAAQ,MAAM;IAC9B;AACF;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 567, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/util/plugins.mjs"],"sourcesContent":["import { invokeArgs } from 'ramda-adjunct';\nimport PluginError from \"../errors/PluginError.mjs\";\n/**\n * Filters the given plugins, returning only the ones return `true` for the given method.\n */\nexport const filter = async (method, parameters, plugins) => {\n  const pluginResults = await Promise.all(plugins.map(invokeArgs([method], parameters)));\n  return plugins.filter((plugin, index) => pluginResults[index]);\n};\n\n/**\n * Runs the specified method of the given plugins, in order,\n * until one of them returns a successful result.\n * Each method can return a synchronous value or a Promise.\n * If the promise resolves successfully then the result\n * is immediately returned and no further plugins are called.\n * If the promise rejects then the next plugin is called.\n * If ALL plugins fail, then the last error is thrown.\n */\nexport const run = async (method, parameters, plugins) => {\n  let lastError;\n  for (const plugin of plugins) {\n    try {\n      const result = await plugin[method].call(plugin, ...parameters); // eslint-disable-line no-await-in-loop\n      return {\n        plugin,\n        result\n      };\n    } catch (error) {\n      lastError = new PluginError('Error while running plugin', {\n        cause: error,\n        plugin\n      });\n    }\n  }\n  return Promise.reject(lastError);\n};"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAIO,MAAM,SAAS,OAAO,QAAQ,YAAY;IAC/C,MAAM,gBAAgB,MAAM,QAAQ,GAAG,CAAC,QAAQ,GAAG,CAAC,IAAA,8MAAU,EAAC;QAAC;KAAO,EAAE;IACzE,OAAO,QAAQ,MAAM,CAAC,CAAC,QAAQ,QAAU,aAAa,CAAC,MAAM;AAC/D;AAWO,MAAM,MAAM,OAAO,QAAQ,YAAY;IAC5C,IAAI;IACJ,KAAK,MAAM,UAAU,QAAS;QAC5B,IAAI;YACF,MAAM,SAAS,MAAM,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,aAAa,uCAAuC;YACxG,OAAO;gBACL;gBACA;YACF;QACF,EAAE,OAAO,OAAO;YACd,YAAY,IAAI,sMAAW,CAAC,8BAA8B;gBACxD,OAAO;gBACP;YACF;QACF;IACF;IACA,OAAO,QAAQ,MAAM,CAAC;AACxB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 605, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/errors/ParseError.mjs"],"sourcesContent":["import { ApiDOMError } from '@swagger-api/apidom-error';\n\n/**\n * @public\n */\nclass ParseError extends ApiDOMError {}\nexport default ParseError;"],"names":[],"mappings":";;;;AAAA;;AAEA;;CAEC,GACD,MAAM,mBAAmB,sOAAW;AAAE;uCACvB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 620, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/errors/ResolveError.mjs"],"sourcesContent":["import { ApiDOMError } from '@swagger-api/apidom-error';\n\n/**\n * @public\n */\nclass ResolveError extends ApiDOMError {}\nexport default ResolveError;"],"names":[],"mappings":";;;;AAAA;;AAEA;;CAEC,GACD,MAAM,qBAAqB,sOAAW;AAAE;uCACzB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 635, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/errors/ResolverError.mjs"],"sourcesContent":["import ResolveError from \"./ResolveError.mjs\";\n/**\n * @public\n */\nclass ResolverError extends ResolveError {}\nexport default ResolverError;"],"names":[],"mappings":";;;;AAAA;;AACA;;CAEC,GACD,MAAM,sBAAsB,uMAAY;AAAE;uCAC3B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 650, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/errors/UnmatchedResolverError.mjs"],"sourcesContent":["import ResolverError from \"./ResolverError.mjs\";\n/**\n * @public\n */\nclass UnmatchedResolverError extends ResolverError {}\nexport default UnmatchedResolverError;"],"names":[],"mappings":";;;;AAAA;;AACA;;CAEC,GACD,MAAM,+BAA+B,wMAAa;AAAE;uCACrC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 665, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/resolve/util.mjs"],"sourcesContent":["import { isEmpty } from 'ramda';\nimport * as plugins from \"../util/plugins.mjs\";\nimport ResolveError from \"../errors/ResolveError.mjs\";\nimport UnmatchedResolverError from \"../errors/UnmatchedResolverError.mjs\";\n/**\n * Reads the given file, using the configured resolver plugins.\n */\n// eslint-disable-next-line import/prefer-default-export\nexport const readFile = async (file, options) => {\n  const optsBoundResolvers = options.resolve.resolvers.map(resolver => {\n    const clonedResolver = Object.create(resolver);\n    return Object.assign(clonedResolver, options.resolve.resolverOpts);\n  });\n  const resolvers = await plugins.filter('canRead', [file, options], optsBoundResolvers);\n\n  // we couldn't find any resolver for this File\n  if (isEmpty(resolvers)) {\n    throw new UnmatchedResolverError(file.uri);\n  }\n  try {\n    const {\n      result\n    } = await plugins.run('read', [file], resolvers);\n    return result;\n  } catch (error) {\n    throw new ResolveError(`Error while reading file \"${file.uri}\"`, {\n      cause: error\n    });\n  }\n};"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAKO,MAAM,WAAW,OAAO,MAAM;IACnC,MAAM,qBAAqB,QAAQ,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,CAAA;QACvD,MAAM,iBAAiB,OAAO,MAAM,CAAC;QACrC,OAAO,OAAO,MAAM,CAAC,gBAAgB,QAAQ,OAAO,CAAC,YAAY;IACnE;IACA,MAAM,YAAY,MAAM,+LAAc,CAAC,WAAW;QAAC;QAAM;KAAQ,EAAE;IAEnE,8CAA8C;IAC9C,IAAI,IAAA,0LAAO,EAAC,YAAY;QACtB,MAAM,IAAI,iNAAsB,CAAC,KAAK,GAAG;IAC3C;IACA,IAAI;QACF,MAAM,EACJ,MAAM,EACP,GAAG,MAAM,4LAAW,CAAC,QAAQ;YAAC;SAAK,EAAE;QACtC,OAAO;IACT,EAAE,OAAO,OAAO;QACd,MAAM,IAAI,uMAAY,CAAC,CAAC,0BAA0B,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC,EAAE;YAC/D,OAAO;QACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 705, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/parse/index.mjs"],"sourcesContent":["import { isEmpty } from 'ramda';\nimport * as url from \"../util/url.mjs\";\nimport File from \"../File.mjs\";\nimport * as plugins from \"../util/plugins.mjs\";\nimport ParseError from \"../errors/ParseError.mjs\";\nimport UnmatchedResolverError from \"../errors/UnmatchedResolverError.mjs\";\nimport { readFile } from \"../resolve/util.mjs\";\n/**\n * Parses the given file's contents, using the configured parser plugins.\n */\nconst parseFile = async (file, options) => {\n  const optsBoundParsers = options.parse.parsers.map(parser => {\n    const clonedParser = Object.create(parser);\n    return Object.assign(clonedParser, options.parse.parserOpts);\n  });\n  const parsers = await plugins.filter('canParse', [file, options], optsBoundParsers);\n\n  // we couldn't find any parser for this File\n  if (isEmpty(parsers)) {\n    throw new UnmatchedResolverError(file.uri);\n  }\n  try {\n    const {\n      plugin,\n      result\n    } = await plugins.run('parse', [file, options], parsers);\n\n    // empty files handling\n    if (!plugin.allowEmpty && result.isEmpty) {\n      return Promise.reject(new ParseError(`Error while parsing file \"${file.uri}\". File is empty.`));\n    }\n    return result;\n  } catch (error) {\n    throw new ParseError(`Error while parsing file \"${file.uri}\"`, {\n      cause: error\n    });\n  }\n};\n\n/**\n * Parses a file into ApiDOM.\n */\nconst parse = async (uri, options) => {\n  /**\n   * If the path is a filesystem path, then convert it to a URL.\n   *\n   * NOTE: According to the JSON Reference spec, these should already be URLs,\n   * but, in practice, many people use local filesystem paths instead.\n   * So we're being generous here and doing the conversion automatically.\n   * This is not intended to be a 100% bulletproof solution.\n   * If it doesn't work for your use-case, then use a URL instead.\n   */\n  const file = new File({\n    uri: url.sanitize(url.stripHash(uri)),\n    mediaType: options.parse.mediaType\n  });\n  const data = await readFile(file, options);\n  return parseFile(new File({\n    ...file,\n    data\n  }), options);\n};\nexport default parse;"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AACA;;CAEC,GACD,MAAM,YAAY,OAAO,MAAM;IAC7B,MAAM,mBAAmB,QAAQ,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA;QACjD,MAAM,eAAe,OAAO,MAAM,CAAC;QACnC,OAAO,OAAO,MAAM,CAAC,cAAc,QAAQ,KAAK,CAAC,UAAU;IAC7D;IACA,MAAM,UAAU,MAAM,+LAAc,CAAC,YAAY;QAAC;QAAM;KAAQ,EAAE;IAElE,4CAA4C;IAC5C,IAAI,IAAA,0LAAO,EAAC,UAAU;QACpB,MAAM,IAAI,iNAAsB,CAAC,KAAK,GAAG;IAC3C;IACA,IAAI;QACF,MAAM,EACJ,MAAM,EACN,MAAM,EACP,GAAG,MAAM,4LAAW,CAAC,SAAS;YAAC;YAAM;SAAQ,EAAE;QAEhD,uBAAuB;QACvB,IAAI,CAAC,OAAO,UAAU,IAAI,OAAO,OAAO,EAAE;YACxC,OAAO,QAAQ,MAAM,CAAC,IAAI,qMAAU,CAAC,CAAC,0BAA0B,EAAE,KAAK,GAAG,CAAC,iBAAiB,CAAC;QAC/F;QACA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,MAAM,IAAI,qMAAU,CAAC,CAAC,0BAA0B,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC,EAAE;YAC7D,OAAO;QACT;IACF;AACF;AAEA;;CAEC,GACD,MAAM,QAAQ,OAAO,KAAK;IACxB;;;;;;;;GAQC,GACD,MAAM,OAAO,IAAI,qLAAI,CAAC;QACpB,KAAK,6LAAY,CAAC,8LAAa,CAAC;QAChC,WAAW,QAAQ,KAAK,CAAC,SAAS;IACpC;IACA,MAAM,OAAO,MAAM,IAAA,iMAAQ,EAAC,MAAM;IAClC,OAAO,UAAU,IAAI,qLAAI,CAAC;QACxB,GAAG,IAAI;QACP;IACF,IAAI;AACN;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 780, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/errors/UnmatchedResolveStrategyError.mjs"],"sourcesContent":["import ResolveError from \"./ResolveError.mjs\";\n/**\n * @public\n */\nclass UnmatchedResolveStrategyError extends ResolveError {}\nexport default UnmatchedResolveStrategyError;"],"names":[],"mappings":";;;;AAAA;;AACA;;CAEC,GACD,MAAM,sCAAsC,uMAAY;AAAE;uCAC3C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 795, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/resolve/index.mjs"],"sourcesContent":["import { isEmpty } from 'ramda';\nimport { isParseResultElement, ParseResultElement, cloneShallow } from '@swagger-api/apidom-core';\nimport { merge as mergeOptions } from \"../options/util.mjs\";\nimport parse from \"../parse/index.mjs\";\nimport * as plugins from \"../util/plugins.mjs\";\nimport File from \"../File.mjs\";\nimport ResolveError from \"../errors/ResolverError.mjs\";\nimport UnmatchedResolveStrategyError from \"../errors/UnmatchedResolveStrategyError.mjs\";\nimport * as url from \"../util/url.mjs\";\n/**\n * Resolves ApiDOM with all its external references.\n */\nexport const resolveApiDOM = async (element, options) => {\n  // @ts-ignore\n  let parseResult = element;\n\n  // wrap element into parse result\n  if (!isParseResultElement(element)) {\n    // shallow clone of the element\n    const elementClone = cloneShallow(element);\n    elementClone.classes.push('result');\n    parseResult = new ParseResultElement([elementClone]);\n  }\n  const sanitizedURI = url.sanitize(url.stripHash(options.resolve.baseURI));\n  const file = new File({\n    uri: sanitizedURI,\n    parseResult,\n    mediaType: options.parse.mediaType\n  });\n  const resolveStrategies = await plugins.filter('canResolve', [file, options], options.resolve.strategies);\n\n  // we couldn't find any resolver for this File\n  if (isEmpty(resolveStrategies)) {\n    throw new UnmatchedResolveStrategyError(file.uri);\n  }\n  try {\n    const {\n      result\n    } = await plugins.run('resolve', [file, options], resolveStrategies);\n    return result;\n  } catch (error) {\n    throw new ResolveError(`Error while resolving file \"${file.uri}\"`, {\n      cause: error\n    });\n  }\n};\n\n/**\n * Resolves a file with all its external references.\n */\nconst resolve = async (uri, options) => {\n  const parseResult = await parse(uri, options);\n  const mergedOptions = mergeOptions(options, {\n    resolve: {\n      baseURI: url.sanitize(uri)\n    }\n  });\n  return resolveApiDOM(parseResult, mergedOptions);\n};\nexport default resolve;"],"names":[],"mappings":";;;;;;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAIO,MAAM,gBAAgB,OAAO,SAAS;IAC3C,aAAa;IACb,IAAI,cAAc;IAElB,iCAAiC;IACjC,IAAI,CAAC,IAAA,4MAAoB,EAAC,UAAU;QAClC,+BAA+B;QAC/B,MAAM,eAAe,IAAA,+LAAY,EAAC;QAClC,aAAa,OAAO,CAAC,IAAI,CAAC;QAC1B,cAAc,IAAI,+PAAkB,CAAC;YAAC;SAAa;IACrD;IACA,MAAM,eAAe,6LAAY,CAAC,8LAAa,CAAC,QAAQ,OAAO,CAAC,OAAO;IACvE,MAAM,OAAO,IAAI,qLAAI,CAAC;QACpB,KAAK;QACL;QACA,WAAW,QAAQ,KAAK,CAAC,SAAS;IACpC;IACA,MAAM,oBAAoB,MAAM,+LAAc,CAAC,cAAc;QAAC;QAAM;KAAQ,EAAE,QAAQ,OAAO,CAAC,UAAU;IAExG,8CAA8C;IAC9C,IAAI,IAAA,0LAAO,EAAC,oBAAoB;QAC9B,MAAM,IAAI,wNAA6B,CAAC,KAAK,GAAG;IAClD;IACA,IAAI;QACF,MAAM,EACJ,MAAM,EACP,GAAG,MAAM,4LAAW,CAAC,WAAW;YAAC;YAAM;SAAQ,EAAE;QAClD,OAAO;IACT,EAAE,OAAO,OAAO;QACd,MAAM,IAAI,wMAAY,CAAC,CAAC,4BAA4B,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC,EAAE;YACjE,OAAO;QACT;IACF;AACF;AAEA;;CAEC,GACD,MAAM,UAAU,OAAO,KAAK;IAC1B,MAAM,cAAc,MAAM,IAAA,+LAAK,EAAC,KAAK;IACrC,MAAM,gBAAgB,IAAA,8LAAY,EAAC,SAAS;QAC1C,SAAS;YACP,SAAS,6LAAY,CAAC;QACxB;IACF;IACA,OAAO,cAAc,aAAa;AACpC;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 875, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/errors/DereferenceError.mjs"],"sourcesContent":["import { ApiDOMError } from '@swagger-api/apidom-error';\n\n/**\n * @public\n */\nclass DereferenceError extends ApiDOMError {}\nexport default DereferenceError;"],"names":[],"mappings":";;;;AAAA;;AAEA;;CAEC,GACD,MAAM,yBAAyB,sOAAW;AAAE;uCAC7B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 890, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/errors/UnmatchedDereferenceStrategyError.mjs"],"sourcesContent":["import DereferenceError from \"./DereferenceError.mjs\";\n/**\n * @public\n */\nclass UnmatchedDereferenceStrategyError extends DereferenceError {}\nexport default UnmatchedDereferenceStrategyError;"],"names":[],"mappings":";;;;AAAA;;AACA;;CAEC,GACD,MAAM,0CAA0C,2MAAgB;AAAE;uCACnD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 905, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/dereference/index.mjs"],"sourcesContent":["import { isEmpty, propEq } from 'ramda';\nimport { isParseResultElement, ParseResultElement, cloneShallow } from '@swagger-api/apidom-core';\nimport File from \"../File.mjs\";\nimport * as plugins from \"../util/plugins.mjs\";\nimport UnmatchedDereferenceStrategyError from \"../errors/UnmatchedDereferenceStrategyError.mjs\";\nimport DereferenceError from \"../errors/DereferenceError.mjs\";\nimport parse from \"../parse/index.mjs\";\nimport { merge as mergeOptions } from \"../options/util.mjs\";\nimport * as url from \"../util/url.mjs\";\n/**\n * Dereferences ApiDOM with all its external references.\n */\nexport const dereferenceApiDOM = async (element, options) => {\n  // @ts-ignore\n  let parseResult = element;\n  let surrogateWrapping = false;\n\n  // wrap element into parse result\n  if (!isParseResultElement(element)) {\n    const elementClone = cloneShallow(element);\n    elementClone.classes.push('result');\n    parseResult = new ParseResultElement([elementClone]);\n    surrogateWrapping = true;\n  }\n  const file = new File({\n    uri: options.resolve.baseURI,\n    parseResult,\n    mediaType: options.parse.mediaType\n  });\n  const dereferenceStrategies = await plugins.filter('canDereference', [file, options], options.dereference.strategies);\n\n  // we couldn't find any dereference strategy for this File\n  if (isEmpty(dereferenceStrategies)) {\n    throw new UnmatchedDereferenceStrategyError(file.uri);\n  }\n  try {\n    const {\n      result\n    } = await plugins.run('dereference', [file, options], dereferenceStrategies);\n    // unwrap the element from ParseResult assuming first element is the actual result\n    return surrogateWrapping ? result.get(0) : result;\n  } catch (error) {\n    throw new DereferenceError(`Error while dereferencing file \"${file.uri}\"`, {\n      cause: error\n    });\n  }\n};\n\n/**\n * Dereferences a file with all its external references.\n */\nconst dereference = async (uri, options) => {\n  const {\n    refSet\n  } = options.dereference;\n  const sanitizedURI = url.sanitize(uri);\n  let parseResult;\n\n  // if refSet was provided, use it to avoid unnecessary parsing\n  if (refSet !== null && refSet.has(sanitizedURI)) {\n    // @ts-ignore\n    ({\n      value: parseResult\n    } = refSet.find(propEq(sanitizedURI, 'uri')));\n  } else {\n    parseResult = await parse(uri, options);\n  }\n  const mergedOptions = mergeOptions(options, {\n    resolve: {\n      baseURI: sanitizedURI\n    },\n    dereference: {\n      // if refSet was not provided, then we can work in mutable mode\n      immutable: options.dereference.immutable && refSet !== null\n    }\n  });\n  return dereferenceApiDOM(parseResult, mergedOptions);\n};\nexport default dereference;"],"names":[],"mappings":";;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAIO,MAAM,oBAAoB,OAAO,SAAS;IAC/C,aAAa;IACb,IAAI,cAAc;IAClB,IAAI,oBAAoB;IAExB,iCAAiC;IACjC,IAAI,CAAC,IAAA,4MAAoB,EAAC,UAAU;QAClC,MAAM,eAAe,IAAA,+LAAY,EAAC;QAClC,aAAa,OAAO,CAAC,IAAI,CAAC;QAC1B,cAAc,IAAI,+PAAkB,CAAC;YAAC;SAAa;QACnD,oBAAoB;IACtB;IACA,MAAM,OAAO,IAAI,qLAAI,CAAC;QACpB,KAAK,QAAQ,OAAO,CAAC,OAAO;QAC5B;QACA,WAAW,QAAQ,KAAK,CAAC,SAAS;IACpC;IACA,MAAM,wBAAwB,MAAM,+LAAc,CAAC,kBAAkB;QAAC;QAAM;KAAQ,EAAE,QAAQ,WAAW,CAAC,UAAU;IAEpH,0DAA0D;IAC1D,IAAI,IAAA,0LAAO,EAAC,wBAAwB;QAClC,MAAM,IAAI,4NAAiC,CAAC,KAAK,GAAG;IACtD;IACA,IAAI;QACF,MAAM,EACJ,MAAM,EACP,GAAG,MAAM,4LAAW,CAAC,eAAe;YAAC;YAAM;SAAQ,EAAE;QACtD,kFAAkF;QAClF,OAAO,oBAAoB,OAAO,GAAG,CAAC,KAAK;IAC7C,EAAE,OAAO,OAAO;QACd,MAAM,IAAI,2MAAgB,CAAC,CAAC,gCAAgC,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC,EAAE;YACzE,OAAO;QACT;IACF;AACF;AAEA;;CAEC,GACD,MAAM,cAAc,OAAO,KAAK;IAC9B,MAAM,EACJ,MAAM,EACP,GAAG,QAAQ,WAAW;IACvB,MAAM,eAAe,6LAAY,CAAC;IAClC,IAAI;IAEJ,8DAA8D;IAC9D,IAAI,WAAW,QAAQ,OAAO,GAAG,CAAC,eAAe;QAC/C,aAAa;QACb,CAAC,EACC,OAAO,WAAW,EACnB,GAAG,OAAO,IAAI,CAAC,IAAA,uLAAM,EAAC,cAAc,OAAO;IAC9C,OAAO;QACL,cAAc,MAAM,IAAA,+LAAK,EAAC,KAAK;IACjC;IACA,MAAM,gBAAgB,IAAA,8LAAY,EAAC,SAAS;QAC1C,SAAS;YACP,SAAS;QACX;QACA,aAAa;YACX,+DAA+D;YAC/D,WAAW,QAAQ,WAAW,CAAC,SAAS,IAAI,WAAW;QACzD;IACF;IACA,OAAO,kBAAkB,aAAa;AACxC;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1000, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/errors/BundleError.mjs"],"sourcesContent":["import { ApiDOMError } from '@swagger-api/apidom-error';\n\n/**\n * @public\n */\nclass BundleError extends ApiDOMError {}\nexport default BundleError;"],"names":[],"mappings":";;;;AAAA;;AAEA;;CAEC,GACD,MAAM,oBAAoB,sOAAW;AAAE;uCACxB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1015, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/errors/UnmatchedBundleStrategyError.mjs"],"sourcesContent":["import BundleError from \"./BundleError.mjs\";\n/**\n * @public\n */\nclass UnmatchedBundleStrategyError extends BundleError {}\nexport default UnmatchedBundleStrategyError;"],"names":[],"mappings":";;;;AAAA;;AACA;;CAEC,GACD,MAAM,qCAAqC,sMAAW;AAAE;uCACzC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1030, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/bundle/index.mjs"],"sourcesContent":["import { isEmpty, propEq } from 'ramda';\nimport File from \"../File.mjs\";\nimport * as plugins from \"../util/plugins.mjs\";\nimport UnmatchedBundleStrategyError from \"../errors/UnmatchedBundleStrategyError.mjs\";\nimport BundleError from \"../errors/BundleError.mjs\";\nimport parse from \"../parse/index.mjs\";\nimport { merge as mergeOptions } from \"../options/util.mjs\";\nimport * as url from \"../util/url.mjs\";\n/**\n * Bundle a file with all its external references to a compound document.\n */\nconst bundle = async (uri, options) => {\n  const {\n    refSet\n  } = options.bundle;\n  const sanitizedURI = url.sanitize(uri);\n  const mergedOptions = mergeOptions(options, {\n    resolve: {\n      baseURI: sanitizedURI\n    }\n  });\n  let parseResult;\n\n  // if refSet was provided, use it to avoid unnecessary parsing\n  if (refSet !== null && refSet.has(sanitizedURI)) {\n    // @ts-ignore\n    ({\n      value: parseResult\n    } = refSet.find(propEq(sanitizedURI, 'uri')));\n  } else {\n    parseResult = await parse(uri, mergedOptions);\n  }\n  const file = new File({\n    uri: mergedOptions.resolve.baseURI,\n    parseResult,\n    mediaType: mergedOptions.parse.mediaType\n  });\n  const bundleStrategies = await plugins.filter('canBundle', [file, mergedOptions], mergedOptions.bundle.strategies);\n\n  // we couldn't find any bundle strategy for this File\n  if (isEmpty(bundleStrategies)) {\n    throw new UnmatchedBundleStrategyError(file.uri);\n  }\n  try {\n    const {\n      result\n    } = await plugins.run('bundle', [file, mergedOptions], bundleStrategies);\n    return result;\n  } catch (error) {\n    throw new BundleError(`Error while bundling file \"${file.uri}\"`, {\n      cause: error\n    });\n  }\n};\nexport default bundle;"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AACA;;CAEC,GACD,MAAM,SAAS,OAAO,KAAK;IACzB,MAAM,EACJ,MAAM,EACP,GAAG,QAAQ,MAAM;IAClB,MAAM,eAAe,6LAAY,CAAC;IAClC,MAAM,gBAAgB,IAAA,8LAAY,EAAC,SAAS;QAC1C,SAAS;YACP,SAAS;QACX;IACF;IACA,IAAI;IAEJ,8DAA8D;IAC9D,IAAI,WAAW,QAAQ,OAAO,GAAG,CAAC,eAAe;QAC/C,aAAa;QACb,CAAC,EACC,OAAO,WAAW,EACnB,GAAG,OAAO,IAAI,CAAC,IAAA,uLAAM,EAAC,cAAc,OAAO;IAC9C,OAAO;QACL,cAAc,MAAM,IAAA,+LAAK,EAAC,KAAK;IACjC;IACA,MAAM,OAAO,IAAI,qLAAI,CAAC;QACpB,KAAK,cAAc,OAAO,CAAC,OAAO;QAClC;QACA,WAAW,cAAc,KAAK,CAAC,SAAS;IAC1C;IACA,MAAM,mBAAmB,MAAM,+LAAc,CAAC,aAAa;QAAC;QAAM;KAAc,EAAE,cAAc,MAAM,CAAC,UAAU;IAEjH,qDAAqD;IACrD,IAAI,IAAA,0LAAO,EAAC,mBAAmB;QAC7B,MAAM,IAAI,uNAA4B,CAAC,KAAK,GAAG;IACjD;IACA,IAAI;QACF,MAAM,EACJ,MAAM,EACP,GAAG,MAAM,4LAAW,CAAC,UAAU;YAAC;YAAM;SAAc,EAAE;QACvD,OAAO;IACT,EAAE,OAAO,OAAO;QACd,MAAM,IAAI,sMAAW,CAAC,CAAC,2BAA2B,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC,EAAE;YAC/D,OAAO;QACT;IACF;AACF;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1099, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/index.mjs"],"sourcesContent":["import File from \"./File.mjs\";\nimport ReferenceSet from \"./ReferenceSet.mjs\";\nimport * as url from \"./util/url.mjs\";\nimport defaultOptions from \"./options/index.mjs\";\nimport { merge as mergeOptions } from \"./options/util.mjs\";\nimport parseFn from \"./parse/index.mjs\";\nimport resolveFn, { resolveApiDOM as resolveApiDOMFn } from \"./resolve/index.mjs\";\nimport { readFile as readFileFn } from \"./resolve/util.mjs\";\nimport dereferenceFn, { dereferenceApiDOM as dereferenceApiDOMFn } from \"./dereference/index.mjs\";\nimport bundleFn from \"./bundle/index.mjs\";\nexport { url };\nexport { default as Parser } from \"./parse/parsers/Parser.mjs\";\nexport { default as Resolver } from \"./resolve/resolvers/Resolver.mjs\";\nexport { default as HTTPResolver } from \"./resolve/resolvers/HTTPResolver.mjs\";\nexport { default as ResolveStrategy } from \"./resolve/strategies/ResolveStrategy.mjs\";\nexport { default as DereferenceStrategy } from \"./dereference/strategies/DereferenceStrategy.mjs\";\nexport { AncestorLineage as DereferenceAncestorLineage } from \"./dereference/util.mjs\";\nexport { default as BundleStrategy } from \"./bundle/strategies/BundleStrategy.mjs\";\nexport { default as options } from \"./options/index.mjs\";\nexport { merge as mergeOptions } from \"./options/util.mjs\";\nexport { File };\nexport { default as Reference } from \"./Reference.mjs\";\nexport { ReferenceSet };\nexport { default as BundleError } from \"./errors/BundleError.mjs\";\nexport { default as MaximumBundleDepthError } from \"./errors/MaximumBundleDepthError.mjs\";\nexport { default as UnmatchedBundleStrategyError } from \"./errors/UnmatchedBundleStrategyError.mjs\";\nexport { default as DereferenceError } from \"./errors/DereferenceError.mjs\";\nexport { default as EvaluationElementIdError } from \"./errors/EvaluationElementIdError.mjs\";\nexport { default as EvaluationJsonSchema$anchorError } from \"./errors/EvaluationJsonSchema$anchorError.mjs\";\nexport { default as EvaluationJsonSchemaUriError } from \"./errors/EvaluationJsonSchemaUriError.mjs\";\nexport { default as InvalidJsonSchema$anchorError } from \"./errors/InvalidJsonSchema$anchorError.mjs\";\nexport { default as JsonSchema$anchorError } from \"./errors/JsonSchema$anchorError.mjs\";\nexport { default as JsonSchemaURIError } from \"./errors/JsonSchemaUriError.mjs\";\nexport { default as MaximumDereferenceDepthError } from \"./errors/MaximumDereferenceDepthError.mjs\";\nexport { default as MaximumResolveDepthError } from \"./errors/MaximumResolveDepthError.mjs\";\nexport { default as ParseError } from \"./errors/ParseError.mjs\";\nexport { default as ParserError } from \"./errors/ParserError.mjs\";\nexport { default as PluginError } from \"./errors/PluginError.mjs\";\nexport { default as ResolveError } from \"./errors/ResolveError.mjs\";\nexport { default as ResolverError } from \"./errors/ResolverError.mjs\";\nexport { default as UnmatchedDereferenceStrategyError } from \"./errors/UnmatchedDereferenceStrategyError.mjs\";\nexport { default as UnmatchedResolveStrategyError } from \"./errors/UnmatchedResolveStrategyError.mjs\";\nexport { default as UnmatchedResolverError } from \"./errors/UnmatchedResolverError.mjs\";\n/**\n * @public\n */\nexport const readFile = async (uri, options = {}) => {\n  const mergedOptions = mergeOptions(defaultOptions, options);\n  const file = new File({\n    uri: url.sanitize(uri)\n  });\n  return readFileFn(file, mergedOptions);\n};\n\n/**\n * @public\n */\nexport const parse = async (uri, options = {}) => {\n  const mergedOptions = mergeOptions(defaultOptions, options);\n  return parseFn(uri, mergedOptions);\n};\n\n/**\n * @public\n */\nexport const resolve = async (uri, options = {}) => {\n  const mergedOptions = mergeOptions(defaultOptions, options);\n  return resolveFn(uri, mergedOptions);\n};\n\n/**\n * @public\n */\nexport const resolveApiDOM = async (element, options = {}) => {\n  const mergedOptions = mergeOptions(defaultOptions, options);\n  return resolveApiDOMFn(element, mergedOptions);\n};\n\n/**\n * @public\n */\nexport const dereference = async (uri, options = {}) => {\n  const mergedOptions = mergeOptions(defaultOptions, options);\n  return dereferenceFn(uri, mergedOptions);\n};\n\n/**\n * @public\n */\nexport const dereferenceApiDOM = async (element, options = {}) => {\n  const mergedOptions = mergeOptions(defaultOptions, options);\n  return dereferenceApiDOMFn(element, mergedOptions);\n};\n\n/**\n * @public\n */\nexport const bundle = async (uri, options = {}) => {\n  const mergedOptions = mergeOptions(defaultOptions, options);\n  return bundleFn(uri, mergedOptions);\n};"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCO,MAAM,WAAW,OAAO,KAAK,UAAU,CAAC,CAAC;IAC9C,MAAM,gBAAgB,IAAA,8LAAY,EAAC,iMAAc,EAAE;IACnD,MAAM,OAAO,IAAI,qLAAI,CAAC;QACpB,KAAK,6LAAY,CAAC;IACpB;IACA,OAAO,IAAA,iMAAU,EAAC,MAAM;AAC1B;AAKO,MAAM,QAAQ,OAAO,KAAK,UAAU,CAAC,CAAC;IAC3C,MAAM,gBAAgB,IAAA,8LAAY,EAAC,iMAAc,EAAE;IACnD,OAAO,IAAA,+LAAO,EAAC,KAAK;AACtB;AAKO,MAAM,UAAU,OAAO,KAAK,UAAU,CAAC,CAAC;IAC7C,MAAM,gBAAgB,IAAA,8LAAY,EAAC,iMAAc,EAAE;IACnD,OAAO,IAAA,iMAAS,EAAC,KAAK;AACxB;AAKO,MAAM,gBAAgB,OAAO,SAAS,UAAU,CAAC,CAAC;IACvD,MAAM,gBAAgB,IAAA,8LAAY,EAAC,iMAAc,EAAE;IACnD,OAAO,IAAA,uMAAe,EAAC,SAAS;AAClC;AAKO,MAAM,cAAc,OAAO,KAAK,UAAU,CAAC,CAAC;IACjD,MAAM,gBAAgB,IAAA,8LAAY,EAAC,iMAAc,EAAE;IACnD,OAAO,IAAA,qMAAa,EAAC,KAAK;AAC5B;AAKO,MAAM,oBAAoB,OAAO,SAAS,UAAU,CAAC,CAAC;IAC3D,MAAM,gBAAgB,IAAA,8LAAY,EAAC,iMAAc,EAAE;IACnD,OAAO,IAAA,+MAAmB,EAAC,SAAS;AACtC;AAKO,MAAM,SAAS,OAAO,KAAK,UAAU,CAAC,CAAC;IAC5C,MAAM,gBAAgB,IAAA,8LAAY,EAAC,iMAAc,EAAE;IACnD,OAAO,IAAA,gMAAQ,EAAC,KAAK;AACvB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1212, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/Reference.mjs"],"sourcesContent":["/**\n * @public\n */\n\n/**\n * @public\n */\nclass Reference {\n  uri;\n  depth;\n  value;\n  refSet;\n  errors;\n  constructor({\n    uri,\n    depth = 0,\n    refSet,\n    value\n  }) {\n    this.uri = uri;\n    this.value = value;\n    this.depth = depth;\n    this.refSet = refSet;\n    this.errors = [];\n  }\n}\nexport default Reference;"],"names":[],"mappings":"AAAA;;CAEC,GAED;;CAEC;;;;AACD,MAAM;IACJ,IAAI;IACJ,MAAM;IACN,MAAM;IACN,OAAO;IACP,OAAO;IACP,YAAY,EACV,GAAG,EACH,QAAQ,CAAC,EACT,MAAM,EACN,KAAK,EACN,CAAE;QACD,IAAI,CAAC,GAAG,GAAG;QACX,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,MAAM,GAAG,EAAE;IAClB;AACF;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1257, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/errors/ParserError.mjs"],"sourcesContent":["import ParseError from \"./ParseError.mjs\";\n/**\n * @public\n */\nclass ParserError extends ParseError {}\nexport default ParserError;"],"names":[],"mappings":";;;;AAAA;;AACA;;CAEC,GACD,MAAM,oBAAoB,qMAAU;AAAE;uCACvB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1272, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/parse/parsers/Parser.mjs"],"sourcesContent":["/**\n * @public\n */\n\n/**\n * @public\n */\nclass Parser {\n  name;\n\n  /**\n   * Whether to allow \"empty\" files. This includes zero-byte files.\n   */\n  allowEmpty;\n\n  /**\n   * Whether to generate source map during parsing.\n   */\n  sourceMap;\n\n  /**\n   * List of supported file extensions.\n   */\n  fileExtensions;\n\n  /**\n   * List of supported media types.\n   */\n  mediaTypes;\n  constructor({\n    name,\n    allowEmpty = true,\n    sourceMap = false,\n    fileExtensions = [],\n    mediaTypes = []\n  }) {\n    this.name = name;\n    this.allowEmpty = allowEmpty;\n    this.sourceMap = sourceMap;\n    this.fileExtensions = fileExtensions;\n    this.mediaTypes = mediaTypes;\n  }\n}\nexport default Parser;"],"names":[],"mappings":"AAAA;;CAEC,GAED;;CAEC;;;;AACD,MAAM;IACJ,KAAK;IAEL;;GAEC,GACD,WAAW;IAEX;;GAEC,GACD,UAAU;IAEV;;GAEC,GACD,eAAe;IAEf;;GAEC,GACD,WAAW;IACX,YAAY,EACV,IAAI,EACJ,aAAa,IAAI,EACjB,YAAY,KAAK,EACjB,iBAAiB,EAAE,EACnB,aAAa,EAAE,EAChB,CAAE;QACD,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,cAAc,GAAG;QACtB,IAAI,CAAC,UAAU,GAAG;IACpB;AACF;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1307, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/parse/parsers/binary/index-browser.mjs"],"sourcesContent":["import { ParseResultElement, StringElement } from '@swagger-api/apidom-core';\nimport ParserError from \"../../../errors/ParserError.mjs\";\nimport Parser from \"../Parser.mjs\";\n/**\n * Everything that is not recognized by other parsers will be considered by this parser\n * as a binary data and will be encoded to Base64 format.\n * @public\n */\n/**\n * @public\n */\nclass BinaryParser extends Parser {\n  constructor(options) {\n    super({\n      ...(options !== null && options !== void 0 ? options : {}),\n      name: 'binary'\n    });\n  }\n  canParse(file) {\n    return this.fileExtensions.length === 0 ? true : this.fileExtensions.includes(file.extension);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  parse(file) {\n    try {\n      /**\n       * More information about binary strings and btoa function in following link:\n       *   https://developer.mozilla.org/en-US/docs/Web/API/btoa\n       *\n       * @example\n       * ArrayBuffer to base64 conversion:\n       *\n       * const binaryString = String.fromCharCode.apply(null, file.data);\n       * base64String = btoa(binaryString);\n       */\n      const binaryString = unescape(encodeURIComponent(file.toString()));\n      const base64String = btoa(binaryString);\n      const parseResultElement = new ParseResultElement();\n      if (base64String.length !== 0) {\n        const base64StringElement = new StringElement(base64String);\n        base64StringElement.classes.push('result');\n        parseResultElement.push(base64StringElement);\n      }\n      return parseResultElement;\n    } catch (error) {\n      throw new ParserError(`Error parsing \"${file.uri}\"`, {\n        cause: error\n      });\n    }\n  }\n}\nexport default BinaryParser;"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AACA;;;;AACA;;;;CAIC,GACD;;CAEC,GACD,MAAM,qBAAqB,2MAAM;IAC/B,YAAY,OAAO,CAAE;QACnB,KAAK,CAAC;YACJ,GAAI,YAAY,QAAQ,YAAY,KAAK,IAAI,UAAU,CAAC,CAAC;YACzD,MAAM;QACR;IACF;IACA,SAAS,IAAI,EAAE;QACb,OAAO,IAAI,CAAC,cAAc,CAAC,MAAM,KAAK,IAAI,OAAO,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,KAAK,SAAS;IAC9F;IAEA,kDAAkD;IAClD,MAAM,IAAI,EAAE;QACV,IAAI;YACF;;;;;;;;;OASC,GACD,MAAM,eAAe,SAAS,mBAAmB,KAAK,QAAQ;YAC9D,MAAM,eAAe,KAAK;YAC1B,MAAM,qBAAqB,IAAI,+PAAkB;YACjD,IAAI,aAAa,MAAM,KAAK,GAAG;gBAC7B,MAAM,sBAAsB,IAAI,yJAAa,CAAC;gBAC9C,oBAAoB,OAAO,CAAC,IAAI,CAAC;gBACjC,mBAAmB,IAAI,CAAC;YAC1B;YACA,OAAO;QACT,EAAE,OAAO,OAAO;YACd,MAAM,IAAI,sMAAW,CAAC,CAAC,eAAe,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC,EAAE;gBACnD,OAAO;YACT;QACF;IACF;AACF;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1367, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/resolve/strategies/ResolveStrategy.mjs"],"sourcesContent":["/**\n * @public\n */\n\n/**\n * @public\n */\nclass ResolveStrategy {\n  name;\n  constructor({\n    name\n  }) {\n    this.name = name;\n  }\n}\nexport default ResolveStrategy;"],"names":[],"mappings":"AAAA;;CAEC,GAED;;CAEC;;;;AACD,MAAM;IACJ,KAAK;IACL,YAAY,EACV,IAAI,EACL,CAAE;QACD,IAAI,CAAC,IAAI,GAAG;IACd;AACF;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1386, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/resolve/strategies/openapi-3-1/index.mjs"],"sourcesContent":["import ResolveStrategy from \"../ResolveStrategy.mjs\";\nimport ReferenceSet from \"../../../ReferenceSet.mjs\";\nimport { merge as mergeOptions } from \"../../../options/util.mjs\";\nimport UnmatchedDereferenceStrategyError from \"../../../errors/UnmatchedDereferenceStrategyError.mjs\";\n/**\n * @public\n */\n/**\n * @public\n */\nclass OpenAPI3_1ResolveStrategy extends ResolveStrategy {\n  constructor(options) {\n    super({\n      ...(options !== null && options !== void 0 ? options : {}),\n      name: 'openapi-3-1'\n    });\n  }\n  canResolve(file, options) {\n    const dereferenceStrategy = options.dereference.strategies.find(strategy => strategy.name === 'openapi-3-1');\n    if (dereferenceStrategy === undefined) {\n      return false;\n    }\n    return dereferenceStrategy.canDereference(file, options);\n  }\n  async resolve(file, options) {\n    const dereferenceStrategy = options.dereference.strategies.find(strategy => strategy.name === 'openapi-3-1');\n    if (dereferenceStrategy === undefined) {\n      throw new UnmatchedDereferenceStrategyError('\"openapi-3-1\" dereference strategy is not available.');\n    }\n    const refSet = new ReferenceSet();\n    const mergedOptions = mergeOptions(options, {\n      resolve: {\n        internal: false\n      },\n      dereference: {\n        refSet\n      }\n    });\n    await dereferenceStrategy.dereference(file, mergedOptions);\n    return refSet;\n  }\n}\nexport default OpenAPI3_1ResolveStrategy;"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AACA;;CAEC,GACD;;CAEC,GACD,MAAM,kCAAkC,yNAAe;IACrD,YAAY,OAAO,CAAE;QACnB,KAAK,CAAC;YACJ,GAAI,YAAY,QAAQ,YAAY,KAAK,IAAI,UAAU,CAAC,CAAC;YACzD,MAAM;QACR;IACF;IACA,WAAW,IAAI,EAAE,OAAO,EAAE;QACxB,MAAM,sBAAsB,QAAQ,WAAW,CAAC,UAAU,CAAC,IAAI,CAAC,CAAA,WAAY,SAAS,IAAI,KAAK;QAC9F,IAAI,wBAAwB,WAAW;YACrC,OAAO;QACT;QACA,OAAO,oBAAoB,cAAc,CAAC,MAAM;IAClD;IACA,MAAM,QAAQ,IAAI,EAAE,OAAO,EAAE;QAC3B,MAAM,sBAAsB,QAAQ,WAAW,CAAC,UAAU,CAAC,IAAI,CAAC,CAAA,WAAY,SAAS,IAAI,KAAK;QAC9F,IAAI,wBAAwB,WAAW;YACrC,MAAM,IAAI,4NAAiC,CAAC;QAC9C;QACA,MAAM,SAAS,IAAI,6LAAY;QAC/B,MAAM,gBAAgB,IAAA,8LAAY,EAAC,SAAS;YAC1C,SAAS;gBACP,UAAU;YACZ;YACA,aAAa;gBACX;YACF;QACF;QACA,MAAM,oBAAoB,WAAW,CAAC,MAAM;QAC5C,OAAO;IACT;AACF;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1448, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/resolve/resolvers/Resolver.mjs"],"sourcesContent":["/**\n * @public\n */\n\n/**\n * @public\n */\nclass Resolver {\n  name;\n  constructor({\n    name\n  }) {\n    this.name = name;\n  }\n}\nexport default Resolver;"],"names":[],"mappings":"AAAA;;CAEC,GAED;;CAEC;;;;AACD,MAAM;IACJ,KAAK;IACL,YAAY,EACV,IAAI,EACL,CAAE;QACD,IAAI,CAAC,IAAI,GAAG;IACd;AACF;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1467, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/resolve/resolvers/HTTPResolver.mjs"],"sourcesContent":["import Resolver from \"./Resolver.mjs\";\nimport * as url from \"../../util/url.mjs\";\n/**\n * @public\n */\n/**\n * @public\n */\nclass HTTPResolver extends Resolver {\n  timeout;\n  redirects;\n  withCredentials;\n  constructor(options) {\n    const {\n      name = 'http-resolver',\n      timeout = 5000,\n      redirects = 5,\n      withCredentials = false\n    } = options !== null && options !== void 0 ? options : {};\n    super({\n      name\n    });\n    this.timeout = timeout;\n    this.redirects = redirects;\n    this.withCredentials = withCredentials;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  canRead(file) {\n    return url.isHttpUrl(file.uri);\n  }\n}\nexport default HTTPResolver;"],"names":[],"mappings":";;;;AAAA;AACA;;;AACA;;CAEC,GACD;;CAEC,GACD,MAAM,qBAAqB,iNAAQ;IACjC,QAAQ;IACR,UAAU;IACV,gBAAgB;IAChB,YAAY,OAAO,CAAE;QACnB,MAAM,EACJ,OAAO,eAAe,EACtB,UAAU,IAAI,EACd,YAAY,CAAC,EACb,kBAAkB,KAAK,EACxB,GAAG,YAAY,QAAQ,YAAY,KAAK,IAAI,UAAU,CAAC;QACxD,KAAK,CAAC;YACJ;QACF;QACA,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,eAAe,GAAG;IACzB;IAEA,kDAAkD;IAClD,QAAQ,IAAI,EAAE;QACZ,OAAO,8LAAa,CAAC,KAAK,GAAG;IAC/B;AACF;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1529, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/dereference/strategies/DereferenceStrategy.mjs"],"sourcesContent":["/**\n * @public\n */\n\n/**\n * @public\n */\nclass DereferenceStrategy {\n  name;\n  constructor({\n    name\n  }) {\n    this.name = name;\n  }\n}\nexport default DereferenceStrategy;"],"names":[],"mappings":"AAAA;;CAEC,GAED;;CAEC;;;;AACD,MAAM;IACJ,KAAK;IACL,YAAY,EACV,IAAI,EACL,CAAE;QACD,IAAI,CAAC,IAAI,GAAG;IACd;AACF;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1548, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/errors/JsonSchema%24anchorError.mjs"],"sourcesContent":["import { ApiDOMError } from '@swagger-api/apidom-error';\n\n/**\n * @public\n */\nclass JsonSchema$anchorError extends ApiDOMError {}\nexport default JsonSchema$anchorError;"],"names":[],"mappings":";;;;AAAA;;AAEA;;CAEC,GACD,MAAM,+BAA+B,sOAAW;AAAE;uCACnC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1563, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/errors/EvaluationJsonSchema%24anchorError.mjs"],"sourcesContent":["import JsonSchema$anchorError from \"./JsonSchema$anchorError.mjs\";\n/**\n * @public\n */\nclass EvaluationJsonSchema$anchorError extends JsonSchema$anchorError {}\nexport default EvaluationJsonSchema$anchorError;"],"names":[],"mappings":";;;;AAAA;;AACA;;CAEC,GACD,MAAM,yCAAyC,kNAAsB;AAAE;uCACxD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1578, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/errors/InvalidJsonSchema%24anchorError.mjs"],"sourcesContent":["import JsonSchema$anchorError from \"./JsonSchema$anchorError.mjs\";\n/**\n * @public\n */\nclass InvalidJsonSchema$anchorError extends JsonSchema$anchorError {\n  constructor(anchor) {\n    super(`Invalid JSON Schema $anchor \"${anchor}\".`);\n  }\n}\nexport default InvalidJsonSchema$anchorError;"],"names":[],"mappings":";;;;AAAA;;AACA;;CAEC,GACD,MAAM,sCAAsC,kNAAsB;IAChE,YAAY,MAAM,CAAE;QAClB,KAAK,CAAC,CAAC,6BAA6B,EAAE,OAAO,EAAE,CAAC;IAClD;AACF;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1596, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/dereference/strategies/openapi-3-1/selectors/%24anchor.mjs"],"sourcesContent":["import { trimCharsStart, isUndefined } from 'ramda-adjunct';\nimport { find, toValue } from '@swagger-api/apidom-core';\nimport { isSchemaElement } from '@swagger-api/apidom-ns-openapi-3-1';\nimport { getHash } from \"../../../../util/url.mjs\";\nimport EvaluationJsonSchema$anchorError from \"../../../../errors/EvaluationJsonSchema$anchorError.mjs\";\nimport InvalidJsonSchema$anchorError from \"../../../../errors/InvalidJsonSchema$anchorError.mjs\";\n/**\n * @public\n */\nexport const isAnchor = uri => {\n  /**\n   *  MUST start with a letter ([A-Za-z]) or underscore (\"_\"), followed by any number of letters,\n   *  digits ([0-9]), hyphens (\"-\"), underscores (\"_\"), and periods (\".\").\n   *\n   *  https://json-schema.org/draft/2020-12/json-schema-core.html#rfc.section.8.2.2\n   */\n  return /^[A-Za-z_][A-Za-z_0-9.-]*$/.test(uri);\n};\n\n/**\n * @public\n */\nexport const uriToAnchor = uri => {\n  const hash = getHash(uri);\n  return trimCharsStart('#', hash);\n};\n\n/**\n * @public\n */\nexport const parse = anchor => {\n  if (!isAnchor(anchor)) {\n    throw new InvalidJsonSchema$anchorError(anchor);\n  }\n  return anchor;\n};\n\n/**\n * Evaluates JSON Schema $anchor against ApiDOM fragment.\n * @public\n */\nexport const evaluate = (anchor, element) => {\n  const token = parse(anchor);\n\n  // @ts-ignore\n  const result = find(e => isSchemaElement(e) && toValue(e.$anchor) === token, element);\n  if (isUndefined(result)) {\n    throw new EvaluationJsonSchema$anchorError(`Evaluation failed on token: \"${token}\"`);\n  }\n\n  // @ts-ignore\n  return result;\n};\nexport { EvaluationJsonSchema$anchorError, InvalidJsonSchema$anchorError };\nexport { default as JsonSchema$anchorError } from \"../../../../errors/JsonSchema$anchorError.mjs\";"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;AAIO,MAAM,WAAW,CAAA;IACtB;;;;;GAKC,GACD,OAAO,6BAA6B,IAAI,CAAC;AAC3C;AAKO,MAAM,cAAc,CAAA;IACzB,MAAM,OAAO,IAAA,4LAAO,EAAC;IACrB,OAAO,IAAA,0NAAc,EAAC,KAAK;AAC7B;AAKO,MAAM,QAAQ,CAAA;IACnB,IAAI,CAAC,SAAS,SAAS;QACrB,MAAM,IAAI,yNAA6B,CAAC;IAC1C;IACA,OAAO;AACT;AAMO,MAAM,WAAW,CAAC,QAAQ;IAC/B,MAAM,QAAQ,MAAM;IAEpB,aAAa;IACb,MAAM,SAAS,IAAA,6NAAI,EAAC,CAAA,IAAK,IAAA,iNAAe,EAAC,MAAM,IAAA,+PAAO,EAAC,EAAE,OAAO,MAAM,OAAO;IAC7E,IAAI,IAAA,iNAAW,EAAC,SAAS;QACvB,MAAM,IAAI,4NAAgC,CAAC,CAAC,6BAA6B,EAAE,MAAM,CAAC,CAAC;IACrF;IAEA,aAAa;IACb,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1654, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/errors/JsonSchemaUriError.mjs"],"sourcesContent":["import { ApiDOMError } from '@swagger-api/apidom-error';\n\n/**\n * @public\n */\nclass JsonSchemaUriError extends ApiDOMError {}\nexport default JsonSchemaUriError;"],"names":[],"mappings":";;;;AAAA;;AAEA;;CAEC,GACD,MAAM,2BAA2B,sOAAW;AAAE;uCAC/B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1669, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/errors/EvaluationJsonSchemaUriError.mjs"],"sourcesContent":["import JsonSchemaUriError from \"./JsonSchemaUriError.mjs\";\n/**\n * @public\n */\nclass EvaluationJsonSchemaUriError extends JsonSchemaUriError {}\nexport default EvaluationJsonSchemaUriError;"],"names":[],"mappings":";;;;AAAA;;AACA;;CAEC,GACD,MAAM,qCAAqC,6MAAkB;AAAE;uCAChD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1684, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/dereference/strategies/openapi-3-1/util.mjs"],"sourcesContent":["import { reduce } from 'ramda';\nimport { isPrimitiveElement, toValue } from '@swagger-api/apidom-core';\nimport { SchemaElement } from '@swagger-api/apidom-ns-openapi-3-1';\nimport * as url from \"../../../util/url.mjs\";\n/**\n * @public\n */\nexport const resolveSchema$refField = (retrievalURI, schemaElement) => {\n  if (typeof schemaElement.$ref === 'undefined') {\n    return undefined;\n  }\n  const hash = url.getHash(toValue(schemaElement.$ref));\n  const ancestorsSchemaIdentifiers = toValue(schemaElement.meta.get('ancestorsSchemaIdentifiers'));\n  const $refBaseURI = reduce((acc, uri) => {\n    return url.resolve(acc, url.sanitize(url.stripHash(uri)));\n  }, retrievalURI, [...ancestorsSchemaIdentifiers, toValue(schemaElement.$ref)]);\n  return `${$refBaseURI}${hash === '#' ? '' : hash}`;\n};\n\n/**\n * @public\n */\nexport const resolveSchema$idField = (retrievalURI, schemaElement) => {\n  if (typeof schemaElement.$id === 'undefined') {\n    return undefined;\n  }\n  const ancestorsSchemaIdentifiers = toValue(schemaElement.meta.get('ancestorsSchemaIdentifiers'));\n  return reduce((acc, $id) => {\n    return url.resolve(acc, url.sanitize(url.stripHash($id)));\n  }, retrievalURI, ancestorsSchemaIdentifiers);\n};\n\n/**\n * Cached version of SchemaElement.refract.\n */\nexport const refractToSchemaElement = element => {\n  if (refractToSchemaElement.cache.has(element)) {\n    return refractToSchemaElement.cache.get(element);\n  }\n  const refracted = SchemaElement.refract(element);\n  refractToSchemaElement.cache.set(element, refracted);\n  return refracted;\n};\nrefractToSchemaElement.cache = new WeakMap();\n\n/**\n * @public\n */\nexport const maybeRefractToSchemaElement = element => {\n  /**\n   * Conditional version of refractToSchemaElement, that acts as an identity\n   * function for all non-primitive Element instances.\n   */\n  if (isPrimitiveElement(element)) {\n    return refractToSchemaElement(element);\n  }\n  return element;\n};"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AAAA;AACA;AACA;;;;;AAIO,MAAM,yBAAyB,CAAC,cAAc;IACnD,IAAI,OAAO,cAAc,IAAI,KAAK,aAAa;QAC7C,OAAO;IACT;IACA,MAAM,OAAO,4LAAW,CAAC,IAAA,+PAAO,EAAC,cAAc,IAAI;IACnD,MAAM,6BAA6B,IAAA,+PAAO,EAAC,cAAc,IAAI,CAAC,GAAG,CAAC;IAClE,MAAM,cAAc,IAAA,uLAAM,EAAC,CAAC,KAAK;QAC/B,OAAO,4LAAW,CAAC,KAAK,6LAAY,CAAC,8LAAa,CAAC;IACrD,GAAG,cAAc;WAAI;QAA4B,IAAA,+PAAO,EAAC,cAAc,IAAI;KAAE;IAC7E,OAAO,GAAG,cAAc,SAAS,MAAM,KAAK,MAAM;AACpD;AAKO,MAAM,wBAAwB,CAAC,cAAc;IAClD,IAAI,OAAO,cAAc,GAAG,KAAK,aAAa;QAC5C,OAAO;IACT;IACA,MAAM,6BAA6B,IAAA,+PAAO,EAAC,cAAc,IAAI,CAAC,GAAG,CAAC;IAClE,OAAO,IAAA,uLAAM,EAAC,CAAC,KAAK;QAClB,OAAO,4LAAW,CAAC,KAAK,6LAAY,CAAC,8LAAa,CAAC;IACrD,GAAG,cAAc;AACnB;AAKO,MAAM,yBAAyB,CAAA;IACpC,IAAI,uBAAuB,KAAK,CAAC,GAAG,CAAC,UAAU;QAC7C,OAAO,uBAAuB,KAAK,CAAC,GAAG,CAAC;IAC1C;IACA,MAAM,YAAY,mQAAa,CAAC,OAAO,CAAC;IACxC,uBAAuB,KAAK,CAAC,GAAG,CAAC,SAAS;IAC1C,OAAO;AACT;AACA,uBAAuB,KAAK,GAAG,IAAI;AAK5B,MAAM,8BAA8B,CAAA;IACzC;;;GAGC,GACD,IAAI,IAAA,0MAAkB,EAAC,UAAU;QAC/B,OAAO,uBAAuB;IAChC;IACA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1748, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/dereference/strategies/openapi-3-1/selectors/uri.mjs"],"sourcesContent":["import { isUndefined } from 'ramda-adjunct';\nimport { filter } from '@swagger-api/apidom-core';\nimport { isSchemaElement } from '@swagger-api/apidom-ns-openapi-3-1';\nimport { URIFragmentIdentifier, evaluate as jsonPointerEvaluate } from '@swagger-api/apidom-json-pointer/modern';\nimport * as url from \"../../../../util/url.mjs\";\nimport EvaluationJsonSchemaUriError from \"../../../../errors/EvaluationJsonSchemaUriError.mjs\";\nimport { isAnchor, uriToAnchor, evaluate as $anchorEvaluate } from \"./$anchor.mjs\";\nimport { resolveSchema$idField } from \"../util.mjs\";\n/**\n * Evaluates JSON Schema $ref containing unknown URI against ApiDOM fragment.\n * @public\n */\nexport const evaluate = (uri, element) => {\n  const {\n    cache\n  } = evaluate;\n  const uriStrippedHash = url.stripHash(uri);\n  const isSchemaElementWith$id = e => isSchemaElement(e) && typeof e.$id !== 'undefined';\n\n  // warm the cache\n  if (!cache.has(element)) {\n    const schemaObjectElements = filter(isSchemaElementWith$id, element);\n    cache.set(element, Array.from(schemaObjectElements));\n  }\n\n  // search for the matching schema\n  const result = cache.get(element).find(e => {\n    const $idBaseURI = resolveSchema$idField(uriStrippedHash, e);\n    return $idBaseURI === uriStrippedHash;\n  });\n  if (isUndefined(result)) {\n    throw new EvaluationJsonSchemaUriError(`Evaluation failed on URI: \"${uri}\"`);\n  }\n  if (isAnchor(uriToAnchor(uri))) {\n    // we're dealing with JSON Schema $anchor here\n    return $anchorEvaluate(uriToAnchor(uri), result);\n  }\n  return jsonPointerEvaluate(result, URIFragmentIdentifier.fromURIReference(uri));\n};\nevaluate.cache = new WeakMap();\nexport { EvaluationJsonSchemaUriError };\nexport { default as JsonSchemaUriError } from \"../../../../errors/JsonSchemaUriError.mjs\";"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;AAKO,MAAM,WAAW,CAAC,KAAK;IAC5B,MAAM,EACJ,KAAK,EACN,GAAG;IACJ,MAAM,kBAAkB,8LAAa,CAAC;IACtC,MAAM,yBAAyB,CAAA,IAAK,IAAA,iNAAe,EAAC,MAAM,OAAO,EAAE,GAAG,KAAK;IAE3E,iBAAiB;IACjB,IAAI,CAAC,MAAM,GAAG,CAAC,UAAU;QACvB,MAAM,uBAAuB,IAAA,mOAAM,EAAC,wBAAwB;QAC5D,MAAM,GAAG,CAAC,SAAS,MAAM,IAAI,CAAC;IAChC;IAEA,iCAAiC;IACjC,MAAM,SAAS,MAAM,GAAG,CAAC,SAAS,IAAI,CAAC,CAAA;QACrC,MAAM,aAAa,IAAA,qPAAqB,EAAC,iBAAiB;QAC1D,OAAO,eAAe;IACxB;IACA,IAAI,IAAA,iNAAW,EAAC,SAAS;QACvB,MAAM,IAAI,uNAA4B,CAAC,CAAC,2BAA2B,EAAE,IAAI,CAAC,CAAC;IAC7E;IACA,IAAI,IAAA,yQAAQ,EAAC,IAAA,4QAAW,EAAC,OAAO;QAC9B,8CAA8C;QAC9C,OAAO,IAAA,yQAAe,EAAC,IAAA,4QAAW,EAAC,MAAM;IAC3C;IACA,OAAO,IAAA,2PAAmB,EAAC,QAAQ,yRAAqB,CAAC,gBAAgB,CAAC;AAC5E;AACA,SAAS,KAAK,GAAG,IAAI","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1799, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/errors/MaximumDereferenceDepthError.mjs"],"sourcesContent":["import DereferenceError from \"./DereferenceError.mjs\";\n/**\n * @public\n */\nclass MaximumDereferenceDepthError extends DereferenceError {}\nexport default MaximumDereferenceDepthError;"],"names":[],"mappings":";;;;AAAA;;AACA;;CAEC,GACD,MAAM,qCAAqC,2MAAgB;AAAE;uCAC9C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1814, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/errors/MaximumResolveDepthError.mjs"],"sourcesContent":["import ResolveError from \"./ResolveError.mjs\";\n/**\n * @public\n */\nclass MaximumResolveDepthError extends ResolveError {}\nexport default MaximumResolveDepthError;"],"names":[],"mappings":";;;;AAAA;;AACA;;CAEC,GACD,MAAM,iCAAiC,uMAAY;AAAE;uCACtC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1829, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/dereference/util.mjs"],"sourcesContent":["import { isElement } from '@swagger-api/apidom-core';\n\n/**\n * @public\n */\n// eslint-disable-next-line import/prefer-default-export\nexport class AncestorLineage extends Array {\n  includesCycle(element) {\n    return this.filter(ancestors => ancestors.has(element)).length > 1;\n  }\n  includes(searchElement, fromIndex) {\n    if (searchElement instanceof Set) {\n      return super.includes(searchElement, fromIndex);\n    }\n    return this.some(ancestors => ancestors.has(searchElement));\n  }\n  findItem(predicate) {\n    for (const set of this) {\n      for (const item of set) {\n        if (isElement(item) && predicate(item)) {\n          return item;\n        }\n      }\n    }\n    return undefined;\n  }\n}"],"names":[],"mappings":";;;;AAAA;;AAMO,MAAM,wBAAwB;IACnC,cAAc,OAAO,EAAE;QACrB,OAAO,IAAI,CAAC,MAAM,CAAC,CAAA,YAAa,UAAU,GAAG,CAAC,UAAU,MAAM,GAAG;IACnE;IACA,SAAS,aAAa,EAAE,SAAS,EAAE;QACjC,IAAI,yBAAyB,KAAK;YAChC,OAAO,KAAK,CAAC,SAAS,eAAe;QACvC;QACA,OAAO,IAAI,CAAC,IAAI,CAAC,CAAA,YAAa,UAAU,GAAG,CAAC;IAC9C;IACA,SAAS,SAAS,EAAE;QAClB,KAAK,MAAM,OAAO,IAAI,CAAE;YACtB,KAAK,MAAM,QAAQ,IAAK;gBACtB,IAAI,IAAA,iMAAS,EAAC,SAAS,UAAU,OAAO;oBACtC,OAAO;gBACT;YACF;QACF;QACA,OAAO;IACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1860, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/dereference/strategies/openapi-3-1/visitor.mjs"],"sourcesContent":["import { propEq, none } from 'ramda';\nimport { isUndefined } from 'ramda-adjunct';\nimport { isElement, isPrimitiveElement, isStringElement, isMemberElement, isObjectElement, IdentityManager, visit, find, cloneShallow, cloneDeep, toValue, RefElement } from '@swagger-api/apidom-core';\nimport { ApiDOMError } from '@swagger-api/apidom-error';\nimport { evaluate as jsonPointerEvaluate, URIFragmentIdentifier } from '@swagger-api/apidom-json-pointer/modern';\nimport { getNodeType, isReferenceLikeElement, keyMap, ReferenceElement, PathItemElement, OperationElement, SchemaElement, isPathItemElement, isReferenceElement, isSchemaElement, isOperationElement, isBooleanJsonSchemaElement } from '@swagger-api/apidom-ns-openapi-3-1';\nimport { isAnchor, uriToAnchor, evaluate as $anchorEvaluate } from \"./selectors/$anchor.mjs\";\nimport { evaluate as uriEvaluate } from \"./selectors/uri.mjs\";\nimport MaximumDereferenceDepthError from \"../../../errors/MaximumDereferenceDepthError.mjs\";\nimport MaximumResolveDepthError from \"../../../errors/MaximumResolveDepthError.mjs\";\nimport * as url from \"../../../util/url.mjs\";\nimport parse from \"../../../parse/index.mjs\";\nimport Reference from \"../../../Reference.mjs\";\nimport File from \"../../../File.mjs\";\nimport { resolveSchema$refField, maybeRefractToSchemaElement } from \"./util.mjs\";\nimport { AncestorLineage } from \"../../util.mjs\";\nimport EvaluationJsonSchemaUriError from \"../../../errors/EvaluationJsonSchemaUriError.mjs\";\n// @ts-ignore\nconst visitAsync = visit[Symbol.for('nodejs.util.promisify.custom')];\n\n// initialize element identity manager\nconst identityManager = new IdentityManager();\n\n/**\n * Custom mutation replacer.\n * @public\n */\nexport const mutationReplacer = (newElement, oldElement, key, parent) => {\n  if (isMemberElement(parent)) {\n    parent.value = newElement; // eslint-disable-line no-param-reassign\n  } else if (Array.isArray(parent)) {\n    parent[key] = newElement; // eslint-disable-line no-param-reassign\n  }\n};\n\n/**\n * @public\n */\n\n/**\n * @public\n */\nclass OpenAPI3_1DereferenceVisitor {\n  indirections;\n  namespace;\n  reference;\n  options;\n  ancestors;\n  refractCache;\n  allOfDiscriminatorMapping;\n  constructor({\n    reference,\n    namespace,\n    options,\n    indirections = [],\n    ancestors = new AncestorLineage(),\n    refractCache = new Map(),\n    allOfDiscriminatorMapping = new Map()\n  }) {\n    this.indirections = indirections;\n    this.namespace = namespace;\n    this.reference = reference;\n    this.options = options;\n    this.ancestors = new AncestorLineage(...ancestors);\n    this.refractCache = refractCache;\n    this.allOfDiscriminatorMapping = allOfDiscriminatorMapping;\n  }\n  toBaseURI(uri) {\n    return url.resolve(this.reference.uri, url.sanitize(url.stripHash(uri)));\n  }\n  async toReference(uri) {\n    // detect maximum depth of resolution\n    if (this.reference.depth >= this.options.resolve.maxDepth) {\n      throw new MaximumResolveDepthError(`Maximum resolution depth of ${this.options.resolve.maxDepth} has been exceeded by file \"${this.reference.uri}\"`);\n    }\n    const baseURI = this.toBaseURI(uri);\n    const {\n      refSet\n    } = this.reference;\n\n    // we've already processed this Reference in past\n    if (refSet.has(baseURI)) {\n      return refSet.find(propEq(baseURI, 'uri'));\n    }\n    const parseResult = await parse(url.unsanitize(baseURI), {\n      ...this.options,\n      parse: {\n        ...this.options.parse,\n        mediaType: 'text/plain'\n      }\n    });\n\n    // register new mutable reference with a refSet\n    const mutableReference = new Reference({\n      uri: baseURI,\n      value: cloneDeep(parseResult),\n      depth: this.reference.depth + 1\n    });\n    refSet.add(mutableReference);\n    if (this.options.dereference.immutable) {\n      // register new immutable reference with a refSet\n      const immutableReference = new Reference({\n        uri: `immutable://${baseURI}`,\n        value: parseResult,\n        depth: this.reference.depth + 1\n      });\n      refSet.add(immutableReference);\n    }\n    return mutableReference;\n  }\n  toAncestorLineage(ancestors) {\n    /**\n     * Compute full ancestors lineage.\n     * Ancestors are flatten to unwrap all Element instances.\n     */\n    const directAncestors = new Set(ancestors.filter(isElement));\n    const ancestorsLineage = new AncestorLineage(...this.ancestors, directAncestors);\n    return [ancestorsLineage, directAncestors];\n  }\n  OpenApi3_1Element = {\n    leave: (openApi3_1Element, key, parent, path, ancestors, link) => {\n      var _this$options$derefer;\n      if (!((_this$options$derefer = this.options.dereference.strategyOpts['openapi-3-1']) !== null && _this$options$derefer !== void 0 && _this$options$derefer.dereferenceDiscriminatorMapping)) {\n        return undefined;\n      }\n      const openApi3_1ElementCopy = cloneShallow(openApi3_1Element);\n      openApi3_1ElementCopy.setMetaProperty('allOfDiscriminatorMapping', Object.fromEntries(this.allOfDiscriminatorMapping));\n      link.replaceWith(openApi3_1ElementCopy, mutationReplacer);\n      return !parent ? openApi3_1ElementCopy : undefined;\n    }\n  };\n  async ReferenceElement(referencingElement, key, parent, path, ancestors, link) {\n    // skip current referencing element as it's already been access\n    if (this.indirections.includes(referencingElement)) {\n      return false;\n    }\n    const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n    const retrievalURI = this.toBaseURI(toValue(referencingElement.$ref));\n    const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n    const isExternalReference = !isInternalReference;\n\n    // ignore resolving internal Reference Objects\n    if (!this.options.resolve.internal && isInternalReference) {\n      // skip traversing this reference element and all it's child elements\n      return false;\n    }\n    // ignore resolving external Reference Objects\n    if (!this.options.resolve.external && isExternalReference) {\n      // skip traversing this reference element and all it's child elements\n      return false;\n    }\n    const reference = await this.toReference(toValue(referencingElement.$ref));\n    const $refBaseURI = url.resolve(retrievalURI, toValue(referencingElement.$ref));\n    this.indirections.push(referencingElement);\n    const jsonPointer = URIFragmentIdentifier.fromURIReference($refBaseURI);\n\n    // possibly non-semantic fragment\n    let referencedElement = jsonPointerEvaluate(reference.value.result, jsonPointer);\n    referencedElement.id = identityManager.identify(referencedElement);\n\n    // applying semantics to a fragment\n    if (isPrimitiveElement(referencedElement)) {\n      const referencedElementType = toValue(referencingElement.meta.get('referenced-element'));\n      const cacheKey = `${referencedElementType}-${toValue(identityManager.identify(referencedElement))}`;\n      if (this.refractCache.has(cacheKey)) {\n        referencedElement = this.refractCache.get(cacheKey);\n      } else if (isReferenceLikeElement(referencedElement)) {\n        // handling indirect references\n        referencedElement = ReferenceElement.refract(referencedElement);\n        referencedElement.setMetaProperty('referenced-element', referencedElementType);\n        this.refractCache.set(cacheKey, referencedElement);\n      } else {\n        // handling direct references\n        const ElementClass = this.namespace.getElementClass(referencedElementType);\n        referencedElement = ElementClass.refract(referencedElement);\n        this.refractCache.set(cacheKey, referencedElement);\n      }\n    }\n\n    // detect direct or indirect reference\n    if (referencingElement === referencedElement) {\n      throw new ApiDOMError('Recursive Reference Object detected');\n    }\n\n    // detect maximum depth of dereferencing\n    if (this.indirections.length > this.options.dereference.maxDepth) {\n      throw new MaximumDereferenceDepthError(`Maximum dereference depth of \"${this.options.dereference.maxDepth}\" has been exceeded in file \"${this.reference.uri}\"`);\n    }\n\n    // detect second deep dive into the same fragment and avoid it\n    if (ancestorsLineage.includes(referencedElement)) {\n      reference.refSet.circular = true;\n      if (this.options.dereference.circular === 'error') {\n        throw new ApiDOMError('Circular reference detected');\n      } else if (this.options.dereference.circular === 'replace') {\n        var _this$options$derefer2, _this$options$derefer3;\n        const refElement = new RefElement(referencedElement.id, {\n          type: 'reference',\n          uri: reference.uri,\n          $ref: toValue(referencingElement.$ref)\n        });\n        const replacer = (_this$options$derefer2 = (_this$options$derefer3 = this.options.dereference.strategyOpts['openapi-3-1']) === null || _this$options$derefer3 === void 0 ? void 0 : _this$options$derefer3.circularReplacer) !== null && _this$options$derefer2 !== void 0 ? _this$options$derefer2 : this.options.dereference.circularReplacer;\n        const replacement = replacer(refElement);\n        link.replaceWith(replacement, mutationReplacer);\n        return !parent ? replacement : false;\n      }\n    }\n\n    /**\n     * Dive deep into the fragment.\n     *\n     * Cases to consider:\n     *  1. We're crossing document boundary\n     *  2. Fragment is from non-root document\n     *  3. Fragment is a Reference Object. We need to follow it to get the eventual value\n     *  4. We are dereferencing the fragment lazily/eagerly depending on circular mode\n     */\n    const isNonRootDocument = url.stripHash(reference.refSet.rootRef.uri) !== reference.uri;\n    const shouldDetectCircular = ['error', 'replace'].includes(this.options.dereference.circular);\n    if ((isExternalReference || isNonRootDocument || isReferenceElement(referencedElement) || shouldDetectCircular) && !ancestorsLineage.includesCycle(referencedElement)) {\n      // append referencing reference to ancestors lineage\n      directAncestors.add(referencingElement);\n      const visitor = new OpenAPI3_1DereferenceVisitor({\n        reference,\n        namespace: this.namespace,\n        indirections: [...this.indirections],\n        options: this.options,\n        refractCache: this.refractCache,\n        ancestors: ancestorsLineage,\n        allOfDiscriminatorMapping: this.allOfDiscriminatorMapping\n      });\n      referencedElement = await visitAsync(referencedElement, visitor, {\n        keyMap,\n        nodeTypeGetter: getNodeType\n      });\n\n      // remove referencing reference from ancestors lineage\n      directAncestors.delete(referencingElement);\n    }\n    this.indirections.pop();\n\n    /**\n     * Creating a new version of referenced element to avoid modifying the original one.\n     */\n    const mergedElement = cloneShallow(referencedElement);\n    // assign unique id to merged element\n    mergedElement.setMetaProperty('id', identityManager.generateId());\n    // annotate fragment with info about original Reference element\n    mergedElement.setMetaProperty('ref-fields', {\n      $ref: toValue(referencingElement.$ref),\n      // @ts-ignore\n      description: toValue(referencingElement.description),\n      // @ts-ignore\n      summary: toValue(referencingElement.summary)\n    });\n    // annotate fragment with info about origin\n    mergedElement.setMetaProperty('ref-origin', reference.uri);\n    // annotate fragment with info about referencing element\n    mergedElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n\n    // override description and summary (outer has higher priority then inner)\n    if (isObjectElement(referencedElement) && isObjectElement(mergedElement)) {\n      if (referencingElement.hasKey('description') && 'description' in referencedElement) {\n        mergedElement.remove('description');\n        mergedElement.set('description', referencingElement.get('description'));\n      }\n      if (referencingElement.hasKey('summary') && 'summary' in referencedElement) {\n        mergedElement.remove('summary');\n        mergedElement.set('summary', referencingElement.get('summary'));\n      }\n    }\n\n    /**\n     * Transclude referencing element with merged referenced element.\n     */\n    link.replaceWith(mergedElement, mutationReplacer);\n\n    /**\n     * We're at the root of the tree, so we're just replacing the entire tree.\n     */\n    return !parent ? mergedElement : false;\n  }\n  async PathItemElement(referencingElement, key, parent, path, ancestors, link) {\n    // ignore PathItemElement without $ref field\n    if (!isStringElement(referencingElement.$ref)) {\n      return undefined;\n    }\n\n    // skip current referencing element as it's already been access\n    if (this.indirections.includes(referencingElement)) {\n      return false;\n    }\n    const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n    const retrievalURI = this.toBaseURI(toValue(referencingElement.$ref));\n    const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n    const isExternalReference = !isInternalReference;\n\n    // ignore resolving external Path Item Objects\n    if (!this.options.resolve.internal && isInternalReference) {\n      // skip traversing this Path Item element but traverse all it's child elements\n      return undefined;\n    }\n    // ignore resolving external Path Item Objects\n    if (!this.options.resolve.external && isExternalReference) {\n      // skip traversing this Path Item element but traverse all it's child elements\n      return undefined;\n    }\n    const reference = await this.toReference(toValue(referencingElement.$ref));\n    const $refBaseURI = url.resolve(retrievalURI, toValue(referencingElement.$ref));\n    this.indirections.push(referencingElement);\n    const jsonPointer = URIFragmentIdentifier.fromURIReference($refBaseURI);\n\n    // possibly non-semantic referenced element\n    let referencedElement = jsonPointerEvaluate(reference.value.result, jsonPointer);\n    referencedElement.id = identityManager.identify(referencedElement);\n\n    /**\n     * Applying semantics to a referenced element if semantics are missing.\n     */\n    if (isPrimitiveElement(referencedElement)) {\n      const cacheKey = `path-item-${toValue(identityManager.identify(referencedElement))}`;\n      if (this.refractCache.has(cacheKey)) {\n        referencedElement = this.refractCache.get(cacheKey);\n      } else {\n        referencedElement = PathItemElement.refract(referencedElement);\n        this.refractCache.set(cacheKey, referencedElement);\n      }\n    }\n\n    // detect direct or indirect reference\n    if (referencingElement === referencedElement) {\n      throw new ApiDOMError('Recursive Path Item Object reference detected');\n    }\n\n    // detect maximum depth of dereferencing\n    if (this.indirections.length > this.options.dereference.maxDepth) {\n      throw new MaximumDereferenceDepthError(`Maximum dereference depth of \"${this.options.dereference.maxDepth}\" has been exceeded in file \"${this.reference.uri}\"`);\n    }\n\n    // detect second deep dive into the same fragment and avoid it\n    if (ancestorsLineage.includes(referencedElement)) {\n      reference.refSet.circular = true;\n      if (this.options.dereference.circular === 'error') {\n        throw new ApiDOMError('Circular reference detected');\n      } else if (this.options.dereference.circular === 'replace') {\n        var _this$options$derefer4, _this$options$derefer5;\n        const refElement = new RefElement(referencedElement.id, {\n          type: 'path-item',\n          uri: reference.uri,\n          $ref: toValue(referencingElement.$ref)\n        });\n        const replacer = (_this$options$derefer4 = (_this$options$derefer5 = this.options.dereference.strategyOpts['openapi-3-1']) === null || _this$options$derefer5 === void 0 ? void 0 : _this$options$derefer5.circularReplacer) !== null && _this$options$derefer4 !== void 0 ? _this$options$derefer4 : this.options.dereference.circularReplacer;\n        const replacement = replacer(refElement);\n        link.replaceWith(replacement, mutationReplacer);\n        return !parent ? replacement : false;\n      }\n    }\n\n    /**\n     * Dive deep into the fragment.\n     *\n     * Cases to consider:\n     *  1. We're crossing document boundary\n     *  2. Fragment is from non-root document\n     *  3. Fragment is a Path Item Object with $ref field. We need to follow it to get the eventual value\n     *  4. We are dereferencing the fragment lazily/eagerly depending on circular mode\n     */\n    const isNonRootDocument = url.stripHash(reference.refSet.rootRef.uri) !== reference.uri;\n    const shouldDetectCircular = ['error', 'replace'].includes(this.options.dereference.circular);\n    if ((isExternalReference || isNonRootDocument || isPathItemElement(referencedElement) && isStringElement(referencedElement.$ref) || shouldDetectCircular) && !ancestorsLineage.includesCycle(referencedElement)) {\n      // append referencing reference to ancestors lineage\n      directAncestors.add(referencingElement);\n      const visitor = new OpenAPI3_1DereferenceVisitor({\n        reference,\n        namespace: this.namespace,\n        indirections: [...this.indirections],\n        options: this.options,\n        refractCache: this.refractCache,\n        ancestors: ancestorsLineage,\n        allOfDiscriminatorMapping: this.allOfDiscriminatorMapping\n      });\n      referencedElement = await visitAsync(referencedElement, visitor, {\n        keyMap,\n        nodeTypeGetter: getNodeType\n      });\n\n      // remove referencing reference from ancestors lineage\n      directAncestors.delete(referencingElement);\n    }\n    this.indirections.pop();\n\n    /**\n     * Creating a new version of Path Item by merging fields from referenced Path Item with referencing one.\n     */\n    if (isPathItemElement(referencedElement)) {\n      const mergedElement = new PathItemElement([...referencedElement.content], cloneDeep(referencedElement.meta), cloneDeep(referencedElement.attributes));\n      // assign unique id to merged element\n      mergedElement.setMetaProperty('id', identityManager.generateId());\n      // existing keywords from referencing PathItemElement overrides ones from referenced element\n      referencingElement.forEach((value, keyElement, item) => {\n        mergedElement.remove(toValue(keyElement));\n        mergedElement.content.push(item);\n      });\n      mergedElement.remove('$ref');\n\n      // annotate referenced element with info about original referencing element\n      mergedElement.setMetaProperty('ref-fields', {\n        $ref: toValue(referencingElement.$ref)\n      });\n      // annotate referenced element with info about origin\n      mergedElement.setMetaProperty('ref-origin', reference.uri);\n      // annotate fragment with info about referencing element\n      mergedElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n      referencedElement = mergedElement;\n    }\n\n    /**\n     * Transclude referencing element with merged referenced element.\n     */\n    link.replaceWith(referencedElement, mutationReplacer);\n\n    /**\n     * We're at the root of the tree, so we're just replacing the entire tree.\n     */\n    return !parent ? referencedElement : undefined;\n  }\n  async LinkElement(linkElement, key, parent, path, ancestors, link) {\n    // ignore LinkElement without operationRef or operationId field\n    if (!isStringElement(linkElement.operationRef) && !isStringElement(linkElement.operationId)) {\n      return undefined;\n    }\n\n    // operationRef and operationId fields are mutually exclusive\n    if (isStringElement(linkElement.operationRef) && isStringElement(linkElement.operationId)) {\n      throw new ApiDOMError('LinkElement operationRef and operationId fields are mutually exclusive.');\n    }\n    let operationElement;\n    if (isStringElement(linkElement.operationRef)) {\n      var _linkElementCopy$oper;\n      // possibly non-semantic referenced element\n      const jsonPointer = URIFragmentIdentifier.fromURIReference(toValue(linkElement.operationRef));\n      const retrievalURI = this.toBaseURI(toValue(linkElement.operationRef));\n      const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n      const isExternalReference = !isInternalReference;\n\n      // ignore resolving internal Operation Object reference\n      if (!this.options.resolve.internal && isInternalReference) {\n        // skip traversing this Link element but traverse all it's child elements\n        return undefined;\n      }\n      // ignore resolving external Operation Object reference\n      if (!this.options.resolve.external && isExternalReference) {\n        // skip traversing this Link element but traverse all it's child elements\n        return undefined;\n      }\n      const reference = await this.toReference(toValue(linkElement.operationRef));\n      operationElement = jsonPointerEvaluate(reference.value.result, jsonPointer);\n      // applying semantics to a referenced element\n      if (isPrimitiveElement(operationElement)) {\n        const cacheKey = `operation-${toValue(identityManager.identify(operationElement))}`;\n        if (this.refractCache.has(cacheKey)) {\n          operationElement = this.refractCache.get(cacheKey);\n        } else {\n          operationElement = OperationElement.refract(operationElement);\n          this.refractCache.set(cacheKey, operationElement);\n        }\n      }\n      // create shallow clone to be able to annotate with metadata\n      operationElement = cloneShallow(operationElement);\n      // annotate operation element with info about origin\n      operationElement.setMetaProperty('ref-origin', reference.uri);\n      const linkElementCopy = cloneShallow(linkElement);\n      (_linkElementCopy$oper = linkElementCopy.operationRef) === null || _linkElementCopy$oper === void 0 || _linkElementCopy$oper.meta.set('operation', operationElement);\n\n      /**\n       * Transclude Link Object containing Operation Object in its meta.\n       */\n      link.replaceWith(linkElementCopy, mutationReplacer);\n\n      /**\n       * We're at the root of the tree, so we're just replacing the entire tree.\n       */\n      return !parent ? linkElementCopy : undefined;\n    }\n    if (isStringElement(linkElement.operationId)) {\n      var _linkElementCopy$oper2;\n      const operationId = toValue(linkElement.operationId);\n      const reference = await this.toReference(url.unsanitize(this.reference.uri));\n      operationElement = find(e => isOperationElement(e) && isElement(e.operationId) && e.operationId.equals(operationId), reference.value.result);\n      // OperationElement not found by its operationId\n      if (isUndefined(operationElement)) {\n        throw new ApiDOMError(`OperationElement(operationId=${operationId}) not found.`);\n      }\n      const linkElementCopy = cloneShallow(linkElement);\n      (_linkElementCopy$oper2 = linkElementCopy.operationId) === null || _linkElementCopy$oper2 === void 0 || _linkElementCopy$oper2.meta.set('operation', operationElement);\n\n      /**\n       * Transclude Link Object containing Operation Object in its meta.\n       */\n      link.replaceWith(linkElementCopy, mutationReplacer);\n\n      /**\n       * We're at the root of the tree, so we're just replacing the entire tree.\n       */\n      return !parent ? linkElementCopy : undefined;\n    }\n    return undefined;\n  }\n  async ExampleElement(exampleElement, key, parent, path, ancestors, link) {\n    // ignore ExampleElement without externalValue field\n    if (!isStringElement(exampleElement.externalValue)) {\n      return undefined;\n    }\n\n    // value and externalValue fields are mutually exclusive\n    if (exampleElement.hasKey('value') && isStringElement(exampleElement.externalValue)) {\n      throw new ApiDOMError('ExampleElement value and externalValue fields are mutually exclusive.');\n    }\n    const retrievalURI = this.toBaseURI(toValue(exampleElement.externalValue));\n    const isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n    const isExternalReference = !isInternalReference;\n\n    // ignore resolving internal Example Objects\n    if (!this.options.resolve.internal && isInternalReference) {\n      // skip traversing this Example element but traverse all it's child elements\n      return undefined;\n    }\n    // ignore resolving external Example Objects\n    if (!this.options.resolve.external && isExternalReference) {\n      // skip traversing this Example element but traverse all it's child elements\n      return undefined;\n    }\n    const reference = await this.toReference(toValue(exampleElement.externalValue));\n\n    // shallow clone of the referenced element\n    const valueElement = cloneShallow(reference.value.result);\n    // annotate operation element with info about origin\n    valueElement.setMetaProperty('ref-origin', reference.uri);\n    const exampleElementCopy = cloneShallow(exampleElement);\n    exampleElementCopy.value = valueElement;\n\n    /**\n     * Transclude Example Object containing external value.\n     */\n    link.replaceWith(exampleElementCopy, mutationReplacer);\n\n    /**\n     * We're at the root of the tree, so we're just replacing the entire tree.\n     */\n    return !parent ? exampleElementCopy : undefined;\n  }\n  async MemberElement(memberElement, key, parent, path, ancestors, link) {\n    var _this$options$derefer6;\n    const parentElement = ancestors[ancestors.length - 1];\n\n    // skip current MemberElement if its parent is not a DiscriminatorElement\n    if (!isObjectElement(parentElement) || !parentElement.classes.contains('discriminator-mapping')) {\n      return undefined;\n    }\n\n    // skip current MemberElement if discriminator mapping dereferencing option is not enabled\n    if (!((_this$options$derefer6 = this.options.dereference.strategyOpts['openapi-3-1']) !== null && _this$options$derefer6 !== void 0 && _this$options$derefer6.dereferenceDiscriminatorMapping)) {\n      return false;\n    }\n\n    // skip current MemberElement if its key or value is not a StringElement\n    if (!isStringElement(memberElement.key) || !isStringElement(memberElement.value)) {\n      return false;\n    }\n\n    // skip current referencing MemberElement as it's already been accessed\n    if (this.indirections.includes(memberElement)) {\n      return false;\n    }\n    this.indirections.push(memberElement);\n    const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n    const parentSchemaElement = [...directAncestors].findLast(isSchemaElement);\n    const ancestorsSchemaIdentifiers = cloneDeep(parentSchemaElement.getMetaProperty('ancestorsSchemaIdentifiers'));\n\n    // get the reference from the MemberElement value\n    const memberElementValue = toValue(memberElement.value);\n    const namePattern = /^[a-zA-Z0-9\\\\.\\\\-_]+$/;\n    const memberElementRef = namePattern.test(memberElementValue) ? `#/components/schemas/${memberElementValue}` : memberElementValue;\n\n    // create SchemaElement with the reference from the MemberElement value\n    const schemaElement = new SchemaElement({\n      $ref: memberElementRef\n    });\n    schemaElement.setMetaProperty('ancestorsSchemaIdentifiers', ancestorsSchemaIdentifiers);\n\n    // append referencing reference to ancestors lineage\n    directAncestors.add(schemaElement);\n    const visitor = new OpenAPI3_1DereferenceVisitor({\n      reference: this.reference,\n      namespace: this.namespace,\n      indirections: [...this.indirections],\n      options: this.options,\n      refractCache: this.refractCache,\n      ancestors: ancestorsLineage,\n      allOfDiscriminatorMapping: this.allOfDiscriminatorMapping\n    });\n    const referencedElement = await visitAsync(schemaElement, visitor, {\n      keyMap,\n      nodeTypeGetter: getNodeType\n    });\n\n    // remove referencing reference from ancestors lineage\n    directAncestors.delete(schemaElement);\n    this.indirections.pop();\n\n    // annotate MemberElement with referenced schema\n    const memberElementCopy = cloneShallow(memberElement);\n    memberElementCopy.value.setMetaProperty('ref-schema', referencedElement);\n\n    /**\n     * Transclude MemberElement containing referenced schema in its meta.\n     */\n    link.replaceWith(memberElementCopy, mutationReplacer);\n\n    /**\n     * We're at the root of the tree, so we're just replacing the entire tree.\n     */\n    return !parent ? memberElementCopy : undefined;\n  }\n  async SchemaElement(referencingElement, key, parent, path, ancestors, link) {\n    // skip current referencing schema as $ref keyword was not defined\n    if (!isStringElement(referencingElement.$ref)) {\n      return undefined;\n    }\n\n    // skip current referencing element as it's already been access\n    if (this.indirections.includes(referencingElement)) {\n      return false;\n    }\n    const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);\n\n    // compute baseURI using rules around $id and $ref keywords\n    let reference = await this.toReference(url.unsanitize(this.reference.uri));\n    let {\n      uri: retrievalURI\n    } = reference;\n    const $refBaseURI = resolveSchema$refField(retrievalURI, referencingElement);\n    const $refBaseURIStrippedHash = url.stripHash($refBaseURI);\n    const file = new File({\n      uri: $refBaseURIStrippedHash\n    });\n    const isUnknownURI = none(r => r.canRead(file), this.options.resolve.resolvers);\n    const isURL = !isUnknownURI;\n    let isInternalReference = url.stripHash(this.reference.uri) === $refBaseURI;\n    let isExternalReference = !isInternalReference;\n    this.indirections.push(referencingElement);\n\n    // determining reference, proper evaluation and selection mechanism\n    let referencedElement;\n    try {\n      if (isUnknownURI || isURL) {\n        // we're dealing with canonical URI or URL with possible fragment\n        retrievalURI = this.toBaseURI($refBaseURI);\n        const selector = $refBaseURI;\n        const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n        referencedElement = uriEvaluate(selector, referenceAsSchema);\n        referencedElement = maybeRefractToSchemaElement(referencedElement);\n        referencedElement.id = identityManager.identify(referencedElement);\n\n        // ignore resolving internal Schema Objects\n        if (!this.options.resolve.internal && isInternalReference) {\n          // skip traversing this schema element but traverse all it's child elements\n          return undefined;\n        }\n        // ignore resolving external Schema Objects\n        if (!this.options.resolve.external && isExternalReference) {\n          // skip traversing this schema element but traverse all it's child elements\n          return undefined;\n        }\n      } else {\n        // we're assuming here that we're dealing with JSON Pointer here\n        retrievalURI = this.toBaseURI($refBaseURI);\n        isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n        isExternalReference = !isInternalReference;\n\n        // ignore resolving internal Schema Objects\n        if (!this.options.resolve.internal && isInternalReference) {\n          // skip traversing this schema element but traverse all it's child elements\n          return undefined;\n        }\n        // ignore resolving external Schema Objects\n        if (!this.options.resolve.external && isExternalReference) {\n          // skip traversing this schema element but traverse all it's child elements\n          return undefined;\n        }\n        reference = await this.toReference(url.unsanitize($refBaseURI));\n        const selector = URIFragmentIdentifier.fromURIReference($refBaseURI);\n        const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n        referencedElement = jsonPointerEvaluate(referenceAsSchema, selector);\n        referencedElement = maybeRefractToSchemaElement(referencedElement);\n        referencedElement.id = identityManager.identify(referencedElement);\n      }\n    } catch (error) {\n      /**\n       * No SchemaElement($id=URL) was not found, so we're going to try to resolve\n       * the URL and assume the returned response is a JSON Schema.\n       */\n      if (isURL && error instanceof EvaluationJsonSchemaUriError) {\n        if (isAnchor(uriToAnchor($refBaseURI))) {\n          // we're dealing with JSON Schema $anchor here\n          isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n          isExternalReference = !isInternalReference;\n\n          // ignore resolving internal Schema Objects\n          if (!this.options.resolve.internal && isInternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          // ignore resolving external Schema Objects\n          if (!this.options.resolve.external && isExternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          reference = await this.toReference(url.unsanitize($refBaseURI));\n          const selector = uriToAnchor($refBaseURI);\n          const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n          referencedElement = $anchorEvaluate(selector, referenceAsSchema);\n          referencedElement = maybeRefractToSchemaElement(referencedElement);\n          referencedElement.id = identityManager.identify(referencedElement);\n        } else {\n          // we're assuming here that we're dealing with JSON Pointer here\n          retrievalURI = this.toBaseURI($refBaseURI);\n          isInternalReference = url.stripHash(this.reference.uri) === retrievalURI;\n          isExternalReference = !isInternalReference;\n\n          // ignore resolving internal Schema Objects\n          if (!this.options.resolve.internal && isInternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          // ignore resolving external Schema Objects\n          if (!this.options.resolve.external && isExternalReference) {\n            // skip traversing this schema element but traverse all it's child elements\n            return undefined;\n          }\n          reference = await this.toReference(url.unsanitize($refBaseURI));\n          const selector = URIFragmentIdentifier.fromURIReference($refBaseURI);\n          const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);\n          referencedElement = jsonPointerEvaluate(referenceAsSchema, selector);\n          referencedElement = maybeRefractToSchemaElement(referencedElement);\n          referencedElement.id = identityManager.identify(referencedElement);\n        }\n      } else {\n        throw error;\n      }\n    }\n\n    // detect direct or indirect reference\n    if (referencingElement === referencedElement) {\n      throw new ApiDOMError('Recursive Schema Object reference detected');\n    }\n\n    // detect maximum depth of dereferencing\n    if (this.indirections.length > this.options.dereference.maxDepth) {\n      throw new MaximumDereferenceDepthError(`Maximum dereference depth of \"${this.options.dereference.maxDepth}\" has been exceeded in file \"${this.reference.uri}\"`);\n    }\n\n    // detect second deep dive into the same fragment and avoid it\n    if (ancestorsLineage.includes(referencedElement)) {\n      reference.refSet.circular = true;\n      if (this.options.dereference.circular === 'error') {\n        throw new ApiDOMError('Circular reference detected');\n      } else if (this.options.dereference.circular === 'replace') {\n        var _this$options$derefer7, _this$options$derefer8;\n        const refElement = new RefElement(referencedElement.id, {\n          type: 'json-schema',\n          uri: reference.uri,\n          $ref: toValue(referencingElement.$ref)\n        });\n        const replacer = (_this$options$derefer7 = (_this$options$derefer8 = this.options.dereference.strategyOpts['openapi-3-1']) === null || _this$options$derefer8 === void 0 ? void 0 : _this$options$derefer8.circularReplacer) !== null && _this$options$derefer7 !== void 0 ? _this$options$derefer7 : this.options.dereference.circularReplacer;\n        const replacement = replacer(refElement);\n        link.replaceWith(replacement, mutationReplacer);\n        return !parent ? replacement : false;\n      }\n    }\n\n    /**\n     * Dive deep into the fragment.\n     *\n     * Cases to consider:\n     *  1. We're crossing document boundary\n     *  2. Fragment is from non-root document\n     *  3. Fragment is a Schema Object with $ref field. We need to follow it to get the eventual value\n     *  4. We are dereferencing the fragment lazily/eagerly depending on circular mode\n     */\n    const isNonRootDocument = url.stripHash(reference.refSet.rootRef.uri) !== reference.uri;\n    const shouldDetectCircular = ['error', 'replace'].includes(this.options.dereference.circular);\n    if ((isExternalReference || isNonRootDocument || isSchemaElement(referencedElement) && isStringElement(referencedElement.$ref) || shouldDetectCircular) && !ancestorsLineage.includesCycle(referencedElement)) {\n      // append referencing reference to ancestors lineage\n      directAncestors.add(referencingElement);\n      const visitor = new OpenAPI3_1DereferenceVisitor({\n        reference,\n        namespace: this.namespace,\n        indirections: [...this.indirections],\n        options: this.options,\n        refractCache: this.refractCache,\n        ancestors: ancestorsLineage,\n        allOfDiscriminatorMapping: this.allOfDiscriminatorMapping\n      });\n      referencedElement = await visitAsync(referencedElement, visitor, {\n        keyMap,\n        nodeTypeGetter: getNodeType\n      });\n\n      // remove referencing reference from ancestors lineage\n      directAncestors.delete(referencingElement);\n    }\n    this.indirections.pop();\n\n    // Boolean JSON Schemas\n    if (isBooleanJsonSchemaElement(referencedElement)) {\n      const booleanJsonSchemaElement = cloneDeep(referencedElement);\n      // assign unique id to merged element\n      booleanJsonSchemaElement.setMetaProperty('id', identityManager.generateId());\n      // annotate referenced element with info about original referencing element\n      booleanJsonSchemaElement.setMetaProperty('ref-fields', {\n        $ref: toValue(referencingElement.$ref),\n        $refBaseURI\n      });\n      // annotate referenced element with info about origin\n      booleanJsonSchemaElement.setMetaProperty('ref-origin', reference.uri);\n      // annotate fragment with info about referencing element\n      booleanJsonSchemaElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n      link.replaceWith(booleanJsonSchemaElement, mutationReplacer);\n      return !parent ? booleanJsonSchemaElement : false;\n    }\n\n    /**\n     * Creating a new version of Schema Object by merging fields from referenced Schema Object with referencing one.\n     */\n    if (isSchemaElement(referencedElement)) {\n      var _this$options$derefer9;\n      const mergedElement = new SchemaElement([...referencedElement.content], cloneDeep(referencedElement.meta), cloneDeep(referencedElement.attributes));\n      // assign unique id to merged element\n      mergedElement.setMetaProperty('id', identityManager.generateId());\n      // existing keywords from referencing schema overrides ones from referenced schema\n      referencingElement.forEach((value, keyElement, item) => {\n        mergedElement.remove(toValue(keyElement));\n        mergedElement.content.push(item);\n      });\n      mergedElement.remove('$ref');\n      // annotate referenced element with info about original referencing element\n      mergedElement.setMetaProperty('ref-fields', {\n        $ref: toValue(referencingElement.$ref),\n        $refBaseURI\n      });\n      // annotate fragment with info about origin\n      mergedElement.setMetaProperty('ref-origin', reference.uri);\n      // annotate fragment with info about referencing element\n      mergedElement.setMetaProperty('ref-referencing-element-id', cloneDeep(identityManager.identify(referencingElement)));\n\n      // creating mapping for allOf discriminator\n      if ((_this$options$derefer9 = this.options.dereference.strategyOpts['openapi-3-1']) !== null && _this$options$derefer9 !== void 0 && _this$options$derefer9.dereferenceDiscriminatorMapping) {\n        var _parentElement$classe;\n        const parentElement = ancestors[ancestors.length - 1];\n        const parentSchemaElement = [...directAncestors].findLast(isSchemaElement);\n        const parentSchemaElementName = parentSchemaElement === null || parentSchemaElement === void 0 ? void 0 : parentSchemaElement.getMetaProperty('schemaName');\n        const mergedElementName = toValue(mergedElement.getMetaProperty('schemaName'));\n        if (mergedElementName && parentSchemaElementName && // @ts-ignore\n        parentElement !== null && parentElement !== void 0 && (_parentElement$classe = parentElement.classes) !== null && _parentElement$classe !== void 0 && _parentElement$classe.contains('json-schema-allOf')) {\n          var _this$allOfDiscrimina;\n          const currentMapping = (_this$allOfDiscrimina = this.allOfDiscriminatorMapping.get(mergedElementName)) !== null && _this$allOfDiscrimina !== void 0 ? _this$allOfDiscrimina : [];\n          currentMapping.push(parentSchemaElement);\n          this.allOfDiscriminatorMapping.set(mergedElementName, currentMapping);\n        }\n      }\n      referencedElement = mergedElement;\n    }\n    /**\n     * Transclude referencing element with merged referenced element.\n     */\n    link.replaceWith(referencedElement, mutationReplacer);\n\n    /**\n     * We're at the root of the tree, so we're just replacing the entire tree.\n     */\n    return !parent ? referencedElement : undefined;\n  }\n}\nexport default OpenAPI3_1DereferenceVisitor;"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2716, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lokes/Desktop/projects/whatsnext/node_modules/%40swagger-api/apidom-reference/src/dereference/strategies/openapi-3-1/index.mjs"],"sourcesContent":["import { propEq } from 'ramda';\nimport { createNamespace, visit, cloneDeep } from '@swagger-api/apidom-core';\nimport openApi3_1Namespace, { getNodeType, isOpenApi3_1Element, keyMap, mediaTypes } from '@swagger-api/apidom-ns-openapi-3-1';\nimport DereferenceStrategy from \"../DereferenceStrategy.mjs\";\nimport Reference from \"../../../Reference.mjs\";\nimport ReferenceSet from \"../../../ReferenceSet.mjs\";\nimport OpenAPI3_1DereferenceVisitor from \"./visitor.mjs\";\n// @ts-ignore\nconst visitAsync = visit[Symbol.for('nodejs.util.promisify.custom')];\n\n/**\n * @public\n */\n\n/**\n * @public\n */\nclass OpenAPI3_1DereferenceStrategy extends DereferenceStrategy {\n  constructor(options) {\n    super({\n      ...(options !== null && options !== void 0 ? options : {}),\n      name: 'openapi-3-1'\n    });\n  }\n  canDereference(file) {\n    var _file$parseResult;\n    // assert by media type\n    if (file.mediaType !== 'text/plain') {\n      return mediaTypes.includes(file.mediaType);\n    }\n\n    // assert by inspecting ApiDOM\n    return isOpenApi3_1Element((_file$parseResult = file.parseResult) === null || _file$parseResult === void 0 ? void 0 : _file$parseResult.result);\n  }\n  async dereference(file, options) {\n    var _options$dereference$;\n    const namespace = createNamespace(openApi3_1Namespace);\n    const immutableRefSet = (_options$dereference$ = options.dereference.refSet) !== null && _options$dereference$ !== void 0 ? _options$dereference$ : new ReferenceSet();\n    const mutableRefSet = new ReferenceSet();\n    let refSet = immutableRefSet;\n    let reference;\n    if (!immutableRefSet.has(file.uri)) {\n      reference = new Reference({\n        uri: file.uri,\n        value: file.parseResult\n      });\n      immutableRefSet.add(reference);\n    } else {\n      // pre-computed refSet was provided as configuration option\n      reference = immutableRefSet.find(propEq(file.uri, 'uri'));\n    }\n\n    /**\n     * Clone refSet due the dereferencing process being mutable.\n     * We don't want to mutate the original refSet and the references.\n     */\n    if (options.dereference.immutable) {\n      immutableRefSet.refs.map(ref => new Reference({\n        ...ref,\n        value: cloneDeep(ref.value)\n      })).forEach(ref => mutableRefSet.add(ref));\n      reference = mutableRefSet.find(ref => ref.uri === file.uri);\n      refSet = mutableRefSet;\n    }\n    const visitor = new OpenAPI3_1DereferenceVisitor({\n      reference: reference,\n      namespace,\n      options\n    });\n    const dereferencedElement = await visitAsync(refSet.rootRef.value, visitor, {\n      keyMap,\n      nodeTypeGetter: getNodeType\n    });\n\n    /**\n     * If immutable option is set, replay refs from the refSet.\n     */\n    if (options.dereference.immutable) {\n      mutableRefSet.refs.filter(ref => ref.uri.startsWith('immutable://')).map(ref => new Reference({\n        ...ref,\n        uri: ref.uri.replace(/^immutable:\\/\\//, '')\n      })).forEach(ref => immutableRefSet.add(ref));\n    }\n\n    /**\n     * Release all memory if this refSet was not provided as an configuration option.\n     * If provided as configuration option, then provider is responsible for cleanup.\n     */\n    if (options.dereference.refSet === null) {\n      immutableRefSet.clean();\n    }\n    mutableRefSet.clean();\n    return dereferencedElement;\n  }\n}\nexport { OpenAPI3_1DereferenceVisitor };\nexport { resolveSchema$refField, resolveSchema$idField, maybeRefractToSchemaElement } from \"./util.mjs\";\nexport default OpenAPI3_1DereferenceStrategy;"],"names":[],"mappings":";;;;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;AACA,aAAa;AACb,MAAM,aAAa,8MAAK,CAAC,OAAO,GAAG,CAAC,gCAAgC;AAEpE;;CAEC,GAED;;CAEC,GACD,MAAM,sCAAsC,iOAAmB;IAC7D,YAAY,OAAO,CAAE;QACnB,KAAK,CAAC;YACJ,GAAI,YAAY,QAAQ,YAAY,KAAK,IAAI,UAAU,CAAC,CAAC;YACzD,MAAM;QACR;IACF;IACA,eAAe,IAAI,EAAE;QACnB,IAAI;QACJ,uBAAuB;QACvB,IAAI,KAAK,SAAS,KAAK,cAAc;YACnC,OAAO,yPAAU,CAAC,QAAQ,CAAC,KAAK,SAAS;QAC3C;QAEA,8BAA8B;QAC9B,OAAO,IAAA,qNAAmB,EAAC,CAAC,oBAAoB,KAAK,WAAW,MAAM,QAAQ,sBAAsB,KAAK,IAAI,KAAK,IAAI,kBAAkB,MAAM;IAChJ;IACA,MAAM,YAAY,IAAI,EAAE,OAAO,EAAE;QAC/B,IAAI;QACJ,MAAM,YAAY,IAAA,6LAAe,EAAC,wMAAmB;QACrD,MAAM,kBAAkB,CAAC,wBAAwB,QAAQ,WAAW,CAAC,MAAM,MAAM,QAAQ,0BAA0B,KAAK,IAAI,wBAAwB,IAAI,6LAAY;QACpK,MAAM,gBAAgB,IAAI,6LAAY;QACtC,IAAI,SAAS;QACb,IAAI;QACJ,IAAI,CAAC,gBAAgB,GAAG,CAAC,KAAK,GAAG,GAAG;YAClC,YAAY,IAAI,0LAAS,CAAC;gBACxB,KAAK,KAAK,GAAG;gBACb,OAAO,KAAK,WAAW;YACzB;YACA,gBAAgB,GAAG,CAAC;QACtB,OAAO;YACL,2DAA2D;YAC3D,YAAY,gBAAgB,IAAI,CAAC,IAAA,uLAAM,EAAC,KAAK,GAAG,EAAE;QACpD;QAEA;;;KAGC,GACD,IAAI,QAAQ,WAAW,CAAC,SAAS,EAAE;YACjC,gBAAgB,IAAI,CAAC,GAAG,CAAC,CAAA,MAAO,IAAI,0LAAS,CAAC;oBAC5C,GAAG,GAAG;oBACN,OAAO,IAAA,4LAAS,EAAC,IAAI,KAAK;gBAC5B,IAAI,OAAO,CAAC,CAAA,MAAO,cAAc,GAAG,CAAC;YACrC,YAAY,cAAc,IAAI,CAAC,CAAA,MAAO,IAAI,GAAG,KAAK,KAAK,GAAG;YAC1D,SAAS;QACX;QACA,MAAM,UAAU,IAAI,0OAA4B,CAAC;YAC/C,WAAW;YACX;YACA;QACF;QACA,MAAM,sBAAsB,MAAM,WAAW,OAAO,OAAO,CAAC,KAAK,EAAE,SAAS;YAC1E,QAAA,kNAAM;YACN,gBAAgB,uNAAW;QAC7B;QAEA;;KAEC,GACD,IAAI,QAAQ,WAAW,CAAC,SAAS,EAAE;YACjC,cAAc,IAAI,CAAC,MAAM,CAAC,CAAA,MAAO,IAAI,GAAG,CAAC,UAAU,CAAC,iBAAiB,GAAG,CAAC,CAAA,MAAO,IAAI,0LAAS,CAAC;oBAC5F,GAAG,GAAG;oBACN,KAAK,IAAI,GAAG,CAAC,OAAO,CAAC,mBAAmB;gBAC1C,IAAI,OAAO,CAAC,CAAA,MAAO,gBAAgB,GAAG,CAAC;QACzC;QAEA;;;KAGC,GACD,IAAI,QAAQ,WAAW,CAAC,MAAM,KAAK,MAAM;YACvC,gBAAgB,KAAK;QACvB;QACA,cAAc,KAAK;QACnB,OAAO;IACT;AACF;;;uCAGe","ignoreList":[0],"debugId":null}}]
}